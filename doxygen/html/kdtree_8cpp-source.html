<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pbrt: kdtree.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>kdtree.cpp</h1><a href="kdtree_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> * pbrt source code Copyright(c) 1998-2005 Matt Pharr and Greg Humphreys</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * All Rights Reserved.</span>
00006 <span class="comment"> * For educational use only; commercial use expressly forbidden.</span>
00007 <span class="comment"> * NO WARRANTY, express or implied, for this software.</span>
00008 <span class="comment"> * (See file License.txt for complete license)</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">// kdtree.cpp*</span>
00012 <span class="preprocessor">#include "<a class="code" href="pbrt_8h.html">pbrt.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="primitive_8h.html">primitive.h</a>"</span>
00014 <span class="comment">// KdAccelNode Declarations</span>
00015 <span class="keyword">struct </span><a class="code" href="structMailboxPrim.html">MailboxPrim</a> {
<a name="l00016"></a><a class="code" href="structMailboxPrim.html#a1">00016</a>         <a class="code" href="structMailboxPrim.html">MailboxPrim</a>(<span class="keyword">const</span> <a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> &amp;p) {
00017                 <a class="code" href="structMailboxPrim.html#o0">primitive</a> = p;
00018                 <a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> = -1;
00019         }
<a name="l00020"></a><a class="code" href="structMailboxPrim.html#o2">00020</a>         <a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> <a class="code" href="structMailboxPrim.html#o0">primitive</a>;
<a name="l00021"></a><a class="code" href="structMailboxPrim.html#o1">00021</a>         <span class="keywordtype">int</span> <a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a>;
00022 };
<a name="l00023"></a><a class="code" href="structKdAccelNode.html">00023</a> <span class="keyword">struct </span><a class="code" href="structKdAccelNode.html">KdAccelNode</a> {
00024         <span class="comment">// KdAccelNode Methods</span>
<a name="l00025"></a><a class="code" href="structKdAccelNode.html#a0">00025</a>         <span class="keywordtype">void</span> <a class="code" href="structKdAccelNode.html#a0">initLeaf</a>(<span class="keywordtype">int</span> *primNums, <span class="keywordtype">int</span> np,
00026                         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *mailboxPrims, <a class="code" href="classMemoryArena.html">MemoryArena</a> &amp;arena) {
00027                 <span class="comment">// Update kd leaf node allocation statistics</span>
00028                 <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> numLeafMade(<span class="stringliteral">"Kd-Tree Accelerator"</span>,
00029                                                 <span class="stringliteral">"Leaf kd-tree nodes made"</span>);
00030                 <span class="comment">//static StatsCounter maxDepth("Kd-Tree Accelerator",</span>
00031                 <span class="comment">//                             "Maximum kd-tree depth");</span>
00032                 <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> maxLeafPrims(<span class="stringliteral">"Kd-Tree Accelerator"</span>,
00033                         <span class="stringliteral">"Maximum number of primitives in leaf node"</span>);
00034                 ++numLeafMade;
00035                 <span class="comment">//maxDepth.Max(depth);</span>
00036                 maxLeafPrims.<a class="code" href="classStatsCounter.html#a3">Max</a>(np);
00037                 <span class="keyword">static</span> <a class="code" href="classStatsRatio.html">StatsRatio</a> leafPrims(<span class="stringliteral">"Kd-Tree Accelerator"</span>,
00038                         <span class="stringliteral">"Avg. number of primitives in leaf nodes"</span>);
00039                 leafPrims.<a class="code" href="classStatsRatio.html#a1">Add</a>(np, 1);
00040                 <a class="code" href="structKdAccelNode.html#o2">nPrims</a> = np &lt;&lt; 2;
00041                 <a class="code" href="structKdAccelNode.html#o0">flags</a> |= 3;
00042                 <span class="comment">// Store _MailboxPrim *_s for leaf node</span>
00043                 <span class="keywordflow">if</span> (np == 0)
00044                         <a class="code" href="structKdAccelNode.html#o4">onePrimitive</a> = NULL;
00045                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (np == 1)
00046                         <a class="code" href="structKdAccelNode.html#o4">onePrimitive</a> = &amp;mailboxPrims[primNums[0]];
00047                 <span class="keywordflow">else</span> {
00048                         <a class="code" href="structKdAccelNode.html#o5">primitives</a> = (<a class="code" href="structMailboxPrim.html">MailboxPrim</a> **)arena.<a class="code" href="classMemoryArena.html#a2">Alloc</a>(np *
00049                                 <span class="keyword">sizeof</span>(<a class="code" href="structMailboxPrim.html">MailboxPrim</a> *));
00050                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; np; ++i)
00051                                 <a class="code" href="structKdAccelNode.html#o5">primitives</a>[i] = &amp;mailboxPrims[primNums[i]];
00052                 }
00053         }
<a name="l00054"></a><a class="code" href="structKdAccelNode.html#a1">00054</a>         <span class="keywordtype">void</span> <a class="code" href="structKdAccelNode.html#a1">initInterior</a>(<span class="keywordtype">int</span> axis, <span class="keywordtype">float</span> s) {
00055                 <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> nodesMade(<span class="stringliteral">"Kd-Tree Accelerator"</span>, <span class="stringliteral">"Interior kd-tree nodes made"</span>); <span class="comment">// NOBOOK</span>
00056                 ++nodesMade; <span class="comment">// NOBOOK</span>
00057                 <a class="code" href="structKdAccelNode.html#o1">split</a> = s;
00058                 <a class="code" href="structKdAccelNode.html#o0">flags</a> &amp;= ~3;
00059                 <a class="code" href="structKdAccelNode.html#o0">flags</a> |= axis;
00060         }
<a name="l00061"></a><a class="code" href="structKdAccelNode.html#a2">00061</a>         <span class="keywordtype">float</span> <a class="code" href="structKdAccelNode.html#a2">SplitPos</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structKdAccelNode.html#o1">split</a>; }
<a name="l00062"></a><a class="code" href="structKdAccelNode.html#a3">00062</a>         <span class="keywordtype">int</span> <a class="code" href="structKdAccelNode.html#a3">nPrimitives</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structKdAccelNode.html#o2">nPrims</a> &gt;&gt; 2; }
<a name="l00063"></a><a class="code" href="structKdAccelNode.html#a4">00063</a>         <span class="keywordtype">int</span> <a class="code" href="structKdAccelNode.html#a4">SplitAxis</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structKdAccelNode.html#o0">flags</a> &amp; 3; }
<a name="l00064"></a><a class="code" href="structKdAccelNode.html#a5">00064</a>         <span class="keywordtype">bool</span> <a class="code" href="structKdAccelNode.html#a5">IsLeaf</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<a class="code" href="structKdAccelNode.html#o0">flags</a> &amp; 3) == 3; }
00065         <span class="keyword">union </span>{
<a name="l00066"></a><a class="code" href="structKdAccelNode.html#o0">00066</a>                 <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structKdAccelNode.html#o0">flags</a>;   <span class="comment">// Both</span>
<a name="l00067"></a><a class="code" href="structKdAccelNode.html#o1">00067</a>                 <span class="keywordtype">float</span> <a class="code" href="structKdAccelNode.html#o1">split</a>;   <span class="comment">// Interior</span>
<a name="l00068"></a><a class="code" href="structKdAccelNode.html#o2">00068</a>                 <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structKdAccelNode.html#o2">nPrims</a>;  <span class="comment">// Leaf</span>
00069         };
00070         <span class="keyword">union </span>{
<a name="l00071"></a><a class="code" href="structKdAccelNode.html#o3">00071</a>                 <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structKdAccelNode.html#o3">aboveChild</a>;           <span class="comment">// Interior</span>
<a name="l00072"></a><a class="code" href="structKdAccelNode.html#o4">00072</a>                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *<a class="code" href="structKdAccelNode.html#o4">onePrimitive</a>;  <span class="comment">// Leaf</span>
<a name="l00073"></a><a class="code" href="structKdAccelNode.html#o5">00073</a>                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **<a class="code" href="structKdAccelNode.html#o5">primitives</a>;   <span class="comment">// Leaf</span>
00074         };
00075 };
<a name="l00076"></a><a class="code" href="structBoundEdge.html">00076</a> <span class="keyword">struct </span><a class="code" href="structBoundEdge.html">BoundEdge</a> {
00077         <span class="comment">// BoundEdge Public Methods</span>
<a name="l00078"></a><a class="code" href="structBoundEdge.html#a0">00078</a>         <a class="code" href="structBoundEdge.html#a0">BoundEdge</a>() { }
<a name="l00079"></a><a class="code" href="structBoundEdge.html#a1">00079</a>         <a class="code" href="structBoundEdge.html#a0">BoundEdge</a>(<span class="keywordtype">float</span> tt, <span class="keywordtype">int</span> pn, <span class="keywordtype">bool</span> starting) {
00080                 <a class="code" href="structBoundEdge.html#o0">t</a> = tt;
00081                 <a class="code" href="structBoundEdge.html#o1">primNum</a> = pn;
00082                 <a class="code" href="structBoundEdge.html#o2">type</a> = starting ? <a class="code" href="structBoundEdge.html#w2w0">START</a> : <a class="code" href="structBoundEdge.html#w2w1">END</a>;
00083         }
<a name="l00084"></a><a class="code" href="structBoundEdge.html#a2">00084</a>         <span class="keywordtype">bool</span> <a class="code" href="structBoundEdge.html#a2">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="structBoundEdge.html">BoundEdge</a> &amp;e)<span class="keyword"> const </span>{
00085                 <span class="keywordflow">if</span> (<a class="code" href="structBoundEdge.html#o0">t</a> == e.<a class="code" href="structBoundEdge.html#o0">t</a>)
00086                         <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)<a class="code" href="structBoundEdge.html#o2">type</a> &lt; (<span class="keywordtype">int</span>)e.<a class="code" href="structBoundEdge.html#o2">type</a>;
00087                 <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="structBoundEdge.html#o0">t</a> &lt; e.<a class="code" href="structBoundEdge.html#o0">t</a>;
00088         }
<a name="l00089"></a><a class="code" href="structBoundEdge.html#o0">00089</a>         <span class="keywordtype">float</span> <a class="code" href="structBoundEdge.html#o0">t</a>;
<a name="l00090"></a><a class="code" href="structBoundEdge.html#o1">00090</a>         <span class="keywordtype">int</span> <a class="code" href="structBoundEdge.html#o1">primNum</a>;
00091         <span class="keyword">enum</span> { <a class="code" href="structBoundEdge.html#w2w0">START</a>, <a class="code" href="structBoundEdge.html#w2w1">END</a> } type;
00092 };
00093 <span class="comment">// KdTreeAccel Declarations</span>
00094 <span class="keyword">struct </span><a class="code" href="structKdAccelNode.html">KdAccelNode</a>;
<a name="l00095"></a><a class="code" href="classKdTreeAccel.html">00095</a> <span class="keyword">class  </span><a class="code" href="classKdTreeAccel.html">KdTreeAccel</a> : <span class="keyword">public</span> <a class="code" href="classAggregate.html">Aggregate</a> {
00096 <span class="keyword">public</span>:
00097         <span class="comment">// KdTreeAccel Public Methods</span>
00098         KdTreeAccel::
00099             KdTreeAccel(<span class="keyword">const</span> vector&lt;<a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> &gt; &amp;p,
00100                 <span class="keywordtype">int</span> icost, <span class="keywordtype">int</span> scost,
00101                 <span class="keywordtype">float</span> ebonus, <span class="keywordtype">int</span> maxp, <span class="keywordtype">int</span> maxDepth);
<a name="l00102"></a><a class="code" href="classKdTreeAccel.html#a1">00102</a>         <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classKdTreeAccel.html#a1">WorldBound</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classKdTreeAccel.html#r10">bounds</a>; }
<a name="l00103"></a><a class="code" href="classKdTreeAccel.html#a2">00103</a>         <span class="keywordtype">bool</span> <a class="code" href="classKdTreeAccel.html#a2">CanIntersect</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
00104         <a class="code" href="classKdTreeAccel.html#a3">~KdTreeAccel</a>();
00105         <span class="keywordtype">void</span> buildTree(<span class="keywordtype">int</span> nodeNum, <span class="keyword">const</span> <a class="code" href="classBBox.html">BBox</a> &amp;bounds,
00106             <span class="keyword">const</span> vector&lt;BBox&gt; &amp;primBounds,
00107                 <span class="keywordtype">int</span> *primNums, <span class="keywordtype">int</span> nprims, <span class="keywordtype">int</span> depth,
00108                 <a class="code" href="structBoundEdge.html">BoundEdge</a> *edges[3],
00109                 <span class="keywordtype">int</span> *prims0, <span class="keywordtype">int</span> *prims1, <span class="keywordtype">int</span> badRefines = 0);
00110         <span class="keywordtype">bool</span> Intersect(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray, <a class="code" href="structIntersection.html">Intersection</a> *isect) <span class="keyword">const</span>;
00111         <span class="keywordtype">bool</span> IntersectP(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray) <span class="keyword">const</span>;
00112 <span class="keyword">private</span>:
00113         <span class="comment">// KdTreeAccel Private Data</span>
<a name="l00114"></a><a class="code" href="classKdTreeAccel.html#r1">00114</a>         <span class="keywordtype">int</span> <a class="code" href="classKdTreeAccel.html#r0">isectCost</a>, <a class="code" href="classKdTreeAccel.html#r1">traversalCost</a>, <a class="code" href="classKdTreeAccel.html#r2">maxPrims</a>;
<a name="l00115"></a><a class="code" href="classKdTreeAccel.html#r3">00115</a>         <span class="keywordtype">float</span> <a class="code" href="classKdTreeAccel.html#r3">emptyBonus</a>;
<a name="l00116"></a><a class="code" href="classKdTreeAccel.html#r4">00116</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="classKdTreeAccel.html#r4">nMailboxes</a>;
<a name="l00117"></a><a class="code" href="classKdTreeAccel.html#r5">00117</a>         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *<a class="code" href="classKdTreeAccel.html#r5">mailboxPrims</a>;
<a name="l00118"></a><a class="code" href="classKdTreeAccel.html#r6">00118</a>         <span class="keyword">mutable</span> <span class="keywordtype">int</span> <a class="code" href="classKdTreeAccel.html#r6">curMailboxId</a>;
<a name="l00119"></a><a class="code" href="classKdTreeAccel.html#r7">00119</a>         <a class="code" href="structKdAccelNode.html">KdAccelNode</a> *<a class="code" href="classKdTreeAccel.html#r7">nodes</a>;
<a name="l00120"></a><a class="code" href="classKdTreeAccel.html#r9">00120</a>         <span class="keywordtype">int</span> <a class="code" href="classKdTreeAccel.html#r8">nAllocedNodes</a>, <a class="code" href="classKdTreeAccel.html#r9">nextFreeNode</a>;
<a name="l00121"></a><a class="code" href="classKdTreeAccel.html#r10">00121</a>         <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classKdTreeAccel.html#r10">bounds</a>;
<a name="l00122"></a><a class="code" href="classKdTreeAccel.html#r11">00122</a>         <a class="code" href="classMemoryArena.html">MemoryArena</a> <a class="code" href="classKdTreeAccel.html#r11">arena</a>;
00123 };
<a name="l00124"></a><a class="code" href="structKdToDo.html">00124</a> <span class="keyword">struct </span><a class="code" href="structKdToDo.html">KdToDo</a> {
<a name="l00125"></a><a class="code" href="structKdToDo.html#o0">00125</a>         <span class="keyword">const</span> <a class="code" href="structKdAccelNode.html">KdAccelNode</a> *<a class="code" href="structKdToDo.html#o0">node</a>;
<a name="l00126"></a><a class="code" href="structKdToDo.html#o1">00126</a>         <span class="keywordtype">float</span> <a class="code" href="structKdToDo.html#o1">tmin</a>, <a class="code" href="structKdToDo.html#o2">tmax</a>;
00127 };
00128 <span class="comment">// KdTreeAccel Method Definitions</span>
00129 KdTreeAccel::
<a name="l00130"></a><a class="code" href="classKdTreeAccel.html#a0">00130</a>     KdTreeAccel(<span class="keyword">const</span> vector&lt;<a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> &gt; &amp;p,
00131                 <span class="keywordtype">int</span> icost, <span class="keywordtype">int</span> tcost,
00132                 <span class="keywordtype">float</span> ebonus, <span class="keywordtype">int</span> maxp, <span class="keywordtype">int</span> maxDepth)
00133         : isectCost(icost), traversalCost(tcost),
00134         maxPrims(maxp), emptyBonus(ebonus) {
00135         vector&lt;Reference&lt;Primitive &gt; &gt; prims;
00136         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; p.size(); ++i)
00137                 p[i]-&gt;FullyRefine(prims);
00138         <span class="comment">// Initialize mailboxes for _KdTreeAccel_</span>
00139         <a class="code" href="classKdTreeAccel.html#r6">curMailboxId</a> = 0;
00140         <a class="code" href="classKdTreeAccel.html#r4">nMailboxes</a> = prims.size();
00141         <a class="code" href="classKdTreeAccel.html#r5">mailboxPrims</a> = (<a class="code" href="structMailboxPrim.html">MailboxPrim</a> *)<a class="code" href="util_8cpp.html#a28">AllocAligned</a>(<a class="code" href="classKdTreeAccel.html#r4">nMailboxes</a> *
00142                 <span class="keyword">sizeof</span>(<a class="code" href="structMailboxPrim.html">MailboxPrim</a>));
00143         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="classKdTreeAccel.html#r4">nMailboxes</a>; ++i)
00144                 <span class="keyword">new</span> (&amp;<a class="code" href="classKdTreeAccel.html#r5">mailboxPrims</a>[i]) MailboxPrim(prims[i]);
00145         <span class="comment">// Build kd-tree for accelerator</span>
00146         <a class="code" href="classKdTreeAccel.html#r9">nextFreeNode</a> = <a class="code" href="classKdTreeAccel.html#r8">nAllocedNodes</a> = 0;
00147         <span class="keywordflow">if</span> (maxDepth &lt;= 0)
00148                 maxDepth =
00149                     <a class="code" href="pbrt_8h.html#a104">Round2Int</a>(8 + 1.3f * <a class="code" href="pbrt_8h.html#a101">Log2Int</a>(<span class="keywordtype">float</span>(prims.size())));
00150         <span class="comment">// Compute bounds for kd-tree construction</span>
00151         vector&lt;BBox&gt; primBounds;
00152         primBounds.reserve(prims.size());
00153         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; prims.size(); ++i) {
00154                 <a class="code" href="classBBox.html">BBox</a> b = prims[i]-&gt;WorldBound();
00155                 <a class="code" href="classKdTreeAccel.html#r10">bounds</a> = <a class="code" href="geometry_8cpp.html#a1">Union</a>(<a class="code" href="classKdTreeAccel.html#r10">bounds</a>, b);
00156                 primBounds.push_back(b);
00157         }
00158         <span class="comment">// Allocate working memory for kd-tree construction</span>
00159         <a class="code" href="structBoundEdge.html">BoundEdge</a> *edges[3];
00160         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)
00161                 edges[i] = <span class="keyword">new</span> <a class="code" href="structBoundEdge.html">BoundEdge</a>[2*prims.size()];
00162         <span class="keywordtype">int</span> *prims0 = <span class="keyword">new</span> <span class="keywordtype">int</span>[prims.size()];
00163         <span class="keywordtype">int</span> *prims1 = <span class="keyword">new</span> <span class="keywordtype">int</span>[(maxDepth+1) * prims.size()];
00164         <span class="comment">// Initialize _primNums_ for kd-tree construction</span>
00165         <span class="keywordtype">int</span> *primNums = <span class="keyword">new</span> <span class="keywordtype">int</span>[prims.size()];
00166         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; prims.size(); ++i)
00167                 primNums[i] = i;
00168         <span class="comment">// Start recursive construction of kd-tree</span>
00169         <a class="code" href="classKdTreeAccel.html#a4">buildTree</a>(0, <a class="code" href="classKdTreeAccel.html#r10">bounds</a>, primBounds, primNums,
00170                   prims.size(), maxDepth, edges,
00171                           prims0, prims1);
00172         <span class="comment">// Free working memory for kd-tree construction</span>
00173         <span class="keyword">delete</span>[] primNums;
00174         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)
00175                 <span class="keyword">delete</span>[] edges[i];
00176         <span class="keyword">delete</span>[] prims0;
00177         <span class="keyword">delete</span>[] prims1;
00178 }
<a name="l00179"></a><a class="code" href="classKdTreeAccel.html#a3">00179</a> <a class="code" href="classKdTreeAccel.html#a3">KdTreeAccel::~KdTreeAccel</a>() {
00180         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="classKdTreeAccel.html#r4">nMailboxes</a>; ++i)
00181                 <a class="code" href="classKdTreeAccel.html#r5">mailboxPrims</a>[i].~MailboxPrim();
00182         <a class="code" href="util_8cpp.html#a29">FreeAligned</a>(<a class="code" href="classKdTreeAccel.html#r5">mailboxPrims</a>);
00183         <a class="code" href="util_8cpp.html#a29">FreeAligned</a>(<a class="code" href="classKdTreeAccel.html#r7">nodes</a>);
00184 }
<a name="l00185"></a><a class="code" href="classKdTreeAccel.html#a4">00185</a> <span class="keywordtype">void</span> <a class="code" href="classKdTreeAccel.html#a4">KdTreeAccel::buildTree</a>(<span class="keywordtype">int</span> nodeNum,
00186         <span class="keyword">const</span> <a class="code" href="classBBox.html">BBox</a> &amp;nodeBounds,
00187                 <span class="keyword">const</span> vector&lt;BBox&gt; &amp;allPrimBounds, <span class="keywordtype">int</span> *primNums,
00188                 <span class="keywordtype">int</span> nPrims, <span class="keywordtype">int</span> depth, <a class="code" href="structBoundEdge.html">BoundEdge</a> *edges[3],
00189                 <span class="keywordtype">int</span> *prims0, <span class="keywordtype">int</span> *prims1, <span class="keywordtype">int</span> badRefines) {
00190         <a class="code" href="pbrt_8h.html#a14">Assert</a>(nodeNum == <a class="code" href="classKdTreeAccel.html#r9">nextFreeNode</a>); <span class="comment">// NOBOOK</span>
00191         <span class="comment">// Get next free node from _nodes_ array</span>
00192         <span class="keywordflow">if</span> (nextFreeNode == <a class="code" href="classKdTreeAccel.html#r8">nAllocedNodes</a>) {
00193                 <span class="keywordtype">int</span> nAlloc = max(2 * <a class="code" href="classKdTreeAccel.html#r8">nAllocedNodes</a>, 512);
00194                 <a class="code" href="structKdAccelNode.html">KdAccelNode</a> *n = (<a class="code" href="structKdAccelNode.html">KdAccelNode</a> *)<a class="code" href="util_8cpp.html#a28">AllocAligned</a>(nAlloc *
00195                         <span class="keyword">sizeof</span>(<a class="code" href="structKdAccelNode.html">KdAccelNode</a>));
00196                 <span class="keywordflow">if</span> (<a class="code" href="classKdTreeAccel.html#r8">nAllocedNodes</a> &gt; 0) {
00197                         <a class="code" href="pbrtparse_8y.html#a40">memcpy</a>(n, <a class="code" href="classKdTreeAccel.html#r7">nodes</a>,
00198                                <a class="code" href="classKdTreeAccel.html#r8">nAllocedNodes</a> * <span class="keyword">sizeof</span>(KdAccelNode));
00199                         <a class="code" href="util_8cpp.html#a29">FreeAligned</a>(<a class="code" href="classKdTreeAccel.html#r7">nodes</a>);
00200                 }
00201                 <a class="code" href="classKdTreeAccel.html#r7">nodes</a> = n;
00202                 <a class="code" href="classKdTreeAccel.html#r8">nAllocedNodes</a> = nAlloc;
00203         }
00204         ++nextFreeNode;
00205         <span class="comment">// Initialize leaf node if termination criteria met</span>
00206         <span class="keywordflow">if</span> (nPrims &lt;= <a class="code" href="classKdTreeAccel.html#r2">maxPrims</a> || depth == 0) {
00207                 <a class="code" href="classKdTreeAccel.html#r7">nodes</a>[nodeNum].<a class="code" href="structKdAccelNode.html#a0">initLeaf</a>(primNums, nPrims,
00208                                        <a class="code" href="classKdTreeAccel.html#r5">mailboxPrims</a>, <a class="code" href="classKdTreeAccel.html#r11">arena</a>);
00209                 <span class="keywordflow">return</span>;
00210         }
00211         <span class="comment">// Initialize interior node and continue recursion</span>
00212         <span class="comment">// Choose split axis position for interior node</span>
00213         <span class="keywordtype">int</span> bestAxis = -1, bestOffset = -1;
00214         <span class="keywordtype">float</span> bestCost = <a class="code" href="pbrt_8h.html#a9">INFINITY</a>;
00215         <span class="keywordtype">float</span> oldCost = <a class="code" href="classKdTreeAccel.html#r0">isectCost</a> * float(nPrims);
00216         <a class="code" href="classVector.html">Vector</a> d = nodeBounds.<a class="code" href="classBBox.html#o1">pMax</a> - nodeBounds.<a class="code" href="classBBox.html#o0">pMin</a>;
00217         <span class="keywordtype">float</span> totalSA = (2.f * (d.<a class="code" href="classVector.html#o0">x</a>*d.<a class="code" href="classVector.html#o1">y</a> + d.<a class="code" href="classVector.html#o0">x</a>*d.<a class="code" href="classVector.html#o2">z</a> + d.<a class="code" href="classVector.html#o1">y</a>*d.<a class="code" href="classVector.html#o2">z</a>));
00218         <span class="keywordtype">float</span> invTotalSA = 1.f / totalSA;
00219         <span class="comment">// Choose which axis to split along</span>
00220         <span class="keywordtype">int</span> axis;
00221         <span class="keywordflow">if</span> (d.<a class="code" href="classVector.html#o0">x</a> &gt; d.<a class="code" href="classVector.html#o1">y</a> &amp;&amp; d.<a class="code" href="classVector.html#o0">x</a> &gt; d.<a class="code" href="classVector.html#o2">z</a>) axis = 0;
00222         <span class="keywordflow">else</span> axis = (d.<a class="code" href="classVector.html#o1">y</a> &gt; d.<a class="code" href="classVector.html#o2">z</a>) ? 1 : 2;
00223         <span class="keywordtype">int</span> retries = 0;
00224         retrySplit:
00225         <span class="comment">// Initialize edges for _axis_</span>
00226         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nPrims; ++i) {
00227                 <span class="keywordtype">int</span> pn = primNums[i];
00228                 <span class="keyword">const</span> <a class="code" href="classBBox.html">BBox</a> &amp;bbox = allPrimBounds[pn];
00229                 edges[axis][2*i] =
00230                     <a class="code" href="structBoundEdge.html">BoundEdge</a>(bbox.<a class="code" href="classBBox.html#o0">pMin</a>[axis], pn, <span class="keyword">true</span>);
00231                 edges[axis][2*i+1] =
00232                         BoundEdge(bbox.<a class="code" href="classBBox.html#o1">pMax</a>[axis], pn, <span class="keyword">false</span>);
00233         }
00234         sort(&amp;edges[axis][0], &amp;edges[axis][2*nPrims]);
00235         <span class="comment">// Compute cost of all splits for _axis_ to find best</span>
00236         <span class="keywordtype">int</span> nBelow = 0, nAbove = nPrims;
00237         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2*nPrims; ++i) {
00238                 <span class="keywordflow">if</span> (edges[axis][i].<a class="code" href="structBoundEdge.html#o2">type</a> == BoundEdge::END) --nAbove;
00239                 <span class="keywordtype">float</span> edget = edges[axis][i].<a class="code" href="structBoundEdge.html#o0">t</a>;
00240                 <span class="keywordflow">if</span> (edget &gt; nodeBounds.<a class="code" href="classBBox.html#o0">pMin</a>[axis] &amp;&amp;
00241                         edget &lt; nodeBounds.<a class="code" href="classBBox.html#o1">pMax</a>[axis]) {
00242                         <span class="comment">// Compute cost for split at _i_th edge</span>
00243                         <span class="keywordtype">int</span> otherAxis[3][2] = { {1,2}, {0,2}, {0,1} };
00244                         <span class="keywordtype">int</span> otherAxis0 = otherAxis[axis][0];
00245                         <span class="keywordtype">int</span> otherAxis1 = otherAxis[axis][1];
00246                         <span class="keywordtype">float</span> belowSA = 2 * (d[otherAxis0] * d[otherAxis1] +
00247                                                 (edget - nodeBounds.<a class="code" href="classBBox.html#o0">pMin</a>[axis]) *
00248                                                 (d[otherAxis0] + d[otherAxis1]));
00249                         <span class="keywordtype">float</span> aboveSA = 2 * (d[otherAxis0] * d[otherAxis1] +
00250                                                                 (nodeBounds.<a class="code" href="classBBox.html#o1">pMax</a>[axis] - edget) *
00251                                                                 (d[otherAxis0] + d[otherAxis1]));
00252                         <span class="keywordtype">float</span> pBelow = belowSA * invTotalSA;
00253                         <span class="keywordtype">float</span> pAbove = aboveSA * invTotalSA;
00254                         <span class="keywordtype">float</span> eb = (nAbove == 0 || nBelow == 0) ? <a class="code" href="classKdTreeAccel.html#r3">emptyBonus</a> : 0.f;
00255                         <span class="keywordtype">float</span> cost = <a class="code" href="classKdTreeAccel.html#r1">traversalCost</a> + <a class="code" href="classKdTreeAccel.html#r0">isectCost</a> * (1.f - eb) *
00256                                 (pBelow * nBelow + pAbove * nAbove);
00257                         <span class="comment">// Update best split if this is lowest cost so far</span>
00258                         <span class="keywordflow">if</span> (cost &lt; bestCost)  {
00259                                 bestCost = cost;
00260                                 bestAxis = axis;
00261                                 bestOffset = i;
00262                         }
00263                 }
00264                 <span class="keywordflow">if</span> (edges[axis][i].type == BoundEdge::START) ++nBelow;
00265         }
00266         <a class="code" href="pbrt_8h.html#a14">Assert</a>(nBelow == nPrims &amp;&amp; nAbove == 0); <span class="comment">// NOBOOK</span>
00267         <span class="comment">// Create leaf if no good splits were found</span>
00268         <span class="keywordflow">if</span> (bestAxis == -1 &amp;&amp; retries &lt; 2) {
00269                 ++retries;
00270                 axis = (axis+1) % 3;
00271                 <span class="keywordflow">goto</span> retrySplit;
00272         }
00273         <span class="keywordflow">if</span> (bestCost &gt; oldCost) ++badRefines;
00274         <span class="keywordflow">if</span> ((bestCost &gt; 4.f * oldCost &amp;&amp; nPrims &lt; 16) ||
00275                 bestAxis == -1 || badRefines == 3) {
00276                 <a class="code" href="classKdTreeAccel.html#r7">nodes</a>[nodeNum].<a class="code" href="structKdAccelNode.html#a0">initLeaf</a>(primNums, nPrims,
00277                                      <a class="code" href="classKdTreeAccel.html#r5">mailboxPrims</a>, <a class="code" href="classKdTreeAccel.html#r11">arena</a>);
00278                 <span class="keywordflow">return</span>;
00279         }
00280         <span class="comment">// Classify primitives with respect to split</span>
00281         <span class="keywordtype">int</span> n0 = 0, n1 = 0;
00282         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; bestOffset; ++i)
00283                 <span class="keywordflow">if</span> (edges[bestAxis][i].<a class="code" href="structBoundEdge.html#o2">type</a> == BoundEdge::START)
00284                         prims0[n0++] = edges[bestAxis][i].<a class="code" href="structBoundEdge.html#o1">primNum</a>;
00285         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = bestOffset+1; i &lt; 2*nPrims; ++i)
00286                 <span class="keywordflow">if</span> (edges[bestAxis][i].type == BoundEdge::END)
00287                         prims1[n1++] = edges[bestAxis][i].primNum;
00288         <span class="comment">// Recursively initialize children nodes</span>
00289         <span class="keywordtype">float</span> tsplit = edges[bestAxis][bestOffset].t;
00290         <a class="code" href="classKdTreeAccel.html#r7">nodes</a>[nodeNum].<a class="code" href="structKdAccelNode.html#a1">initInterior</a>(bestAxis, tsplit);
00291         <a class="code" href="classBBox.html">BBox</a> bounds0 = nodeBounds, bounds1 = nodeBounds;
00292         bounds0.<a class="code" href="classBBox.html#o1">pMax</a>[bestAxis] = bounds1.<a class="code" href="classBBox.html#o0">pMin</a>[bestAxis] = tsplit;
00293         <a class="code" href="classKdTreeAccel.html#a4">buildTree</a>(nodeNum+1, bounds0,
00294                 allPrimBounds, prims0, n0, depth-1, edges,
00295                 prims0, prims1 + nPrims, badRefines);
00296         <a class="code" href="classKdTreeAccel.html#r7">nodes</a>[nodeNum].<a class="code" href="structKdAccelNode.html#o3">aboveChild</a> = nextFreeNode;
00297         <a class="code" href="classKdTreeAccel.html#a4">buildTree</a>(<a class="code" href="classKdTreeAccel.html#r7">nodes</a>[nodeNum].aboveChild, bounds1, allPrimBounds,
00298                 prims1, n1, depth-1, edges,
00299                 prims0, prims1 + nPrims, badRefines);
00300 }
<a name="l00301"></a><a class="code" href="classKdTreeAccel.html#a5">00301</a> <span class="keywordtype">bool</span> <a class="code" href="classKdTreeAccel.html#a5">KdTreeAccel::Intersect</a>(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray,
00302                 <a class="code" href="structIntersection.html">Intersection</a> *isect)<span class="keyword"> const </span>{
00303         <span class="comment">// Compute initial parametric range of ray inside kd-tree extent</span>
00304         <span class="keywordtype">float</span> tmin, tmax;
00305         <span class="keywordflow">if</span> (!<a class="code" href="classKdTreeAccel.html#r10">bounds</a>.<a class="code" href="classBBox.html#a9">IntersectP</a>(ray, &amp;tmin, &amp;tmax))
00306                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00307         <span class="comment">// Prepare to traverse kd-tree for ray</span>
00308         <span class="keywordtype">int</span> rayId = <a class="code" href="classKdTreeAccel.html#r6">curMailboxId</a>++;
00309         <a class="code" href="classVector.html">Vector</a> invDir(1.f/ray.<a class="code" href="classRay.html#o1">d</a>.<a class="code" href="classVector.html#o0">x</a>, 1.f/ray.<a class="code" href="classRay.html#o1">d</a>.<a class="code" href="classVector.html#o1">y</a>, 1.f/ray.<a class="code" href="classRay.html#o1">d</a>.<a class="code" href="classVector.html#o2">z</a>);
00310 <span class="preprocessor">        #define MAX_TODO 64</span>
00311 <span class="preprocessor"></span>        <a class="code" href="structKdToDo.html">KdToDo</a> todo[<a class="code" href="kdtree_8cpp.html#a0">MAX_TODO</a>];
00312         <span class="keywordtype">int</span> todoPos = 0;
00313         <span class="comment">// Traverse kd-tree nodes in order for ray</span>
00314         <span class="keywordtype">bool</span> hit = <span class="keyword">false</span>;
00315         <span class="keyword">const</span> <a class="code" href="structKdAccelNode.html">KdAccelNode</a> *node = &amp;<a class="code" href="classKdTreeAccel.html#r7">nodes</a>[0];
00316         <span class="keywordflow">while</span> (node != NULL) {
00317                 <span class="comment">// Bail out if we found a hit closer than the current node</span>
00318                 <span class="keywordflow">if</span> (ray.<a class="code" href="classRay.html#o3">maxt</a> &lt; tmin) <span class="keywordflow">break</span>;
00319                 <span class="comment">//static StatsCounter nodesTraversed("Kd-Tree Accelerator", //NOBOOK</span>
00320                 <span class="comment">//      "Number of kd-tree nodes traversed by normal rays"); //NOBOOK</span>
00321                 <span class="comment">//++nodesTraversed; //NOBOOK</span>
00322                 <span class="keywordflow">if</span> (!node-&gt;<a class="code" href="structKdAccelNode.html#a5">IsLeaf</a>()) {
00323                         <span class="comment">// Process kd-tree interior node</span>
00324                         <span class="comment">// Compute parametric distance along ray to split plane</span>
00325                         <span class="keywordtype">int</span> axis = node-&gt;<a class="code" href="structKdAccelNode.html#a4">SplitAxis</a>();
00326                         <span class="keywordtype">float</span> tplane = (node-&gt;<a class="code" href="structKdAccelNode.html#a2">SplitPos</a>() - ray.<a class="code" href="classRay.html#o0">o</a>[axis]) *
00327                                 invDir[axis];
00328                         <span class="comment">// Get node children pointers for ray</span>
00329                         <span class="keyword">const</span> <a class="code" href="structKdAccelNode.html">KdAccelNode</a> *firstChild, *secondChild;
00330                         <span class="keywordtype">int</span> belowFirst = ray.<a class="code" href="classRay.html#o0">o</a>[axis] &lt;= node-&gt;<a class="code" href="structKdAccelNode.html#a2">SplitPos</a>();
00331                         <span class="keywordflow">if</span> (belowFirst) {
00332                                 firstChild = node + 1;
00333                                 secondChild = &amp;nodes[node-&gt;aboveChild];
00334                         }
00335                         <span class="keywordflow">else</span> {
00336                                 firstChild = &amp;nodes[node-&gt;<a class="code" href="structKdAccelNode.html#o3">aboveChild</a>];
00337                                 secondChild = node + 1;
00338                         }
00339                         <span class="comment">// Advance to next child node, possibly enqueue other child</span>
00340                         <span class="keywordflow">if</span> (tplane &gt; tmax || tplane &lt; 0)
00341                                 node = firstChild;
00342                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tplane &lt; tmin)
00343                                 node = secondChild;
00344                         <span class="keywordflow">else</span> {
00345                                 <span class="comment">// Enqueue _secondChild_ in todo list</span>
00346                                 todo[todoPos].<a class="code" href="structKdToDo.html#o0">node</a> = secondChild;
00347                                 todo[todoPos].<a class="code" href="structKdToDo.html#o1">tmin</a> = tplane;
00348                                 todo[todoPos].<a class="code" href="structKdToDo.html#o2">tmax</a> = tmax;
00349                                 ++todoPos;
00350                                 node = firstChild;
00351                                 tmax = tplane;
00352                         }
00353                 }
00354                 <span class="keywordflow">else</span> {
00355                         <span class="comment">// Check for intersections inside leaf node</span>
00356                         <a class="code" href="pbrt_8h.html#a51">u_int</a> nPrimitives = node-&gt;<a class="code" href="structKdAccelNode.html#a3">nPrimitives</a>();
00357                         <span class="keywordflow">if</span> (nPrimitives == 1) {
00358                                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *mp = node-&gt;<a class="code" href="structKdAccelNode.html#o4">onePrimitive</a>;
00359                                 <span class="comment">// Check one primitive inside leaf node</span>
00360                                 <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> != rayId) {
00361                                         mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> = rayId;
00362                                         <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;Intersect(ray, isect))
00363                                                 hit = <span class="keyword">true</span>;
00364                                 }
00365                         }
00366                         <span class="keywordflow">else</span> {
00367                                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **prims = node-&gt;<a class="code" href="structKdAccelNode.html#o5">primitives</a>;
00368                                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; nPrimitives; ++i) {
00369                                         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *mp = prims[i];
00370                                         <span class="comment">// Check one primitive inside leaf node</span>
00371                                         <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> != rayId) {
00372                                                 mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> = rayId;
00373                                                 <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;Intersect(ray, isect))
00374                                                         hit = <span class="keyword">true</span>;
00375                                         }
00376                                 }
00377                         }
00378                         <span class="comment">// Grab next node to process from todo list</span>
00379                         <span class="keywordflow">if</span> (todoPos &gt; 0) {
00380                                 --todoPos;
00381                                 node = todo[todoPos].<a class="code" href="structKdToDo.html#o0">node</a>;
00382                                 tmin = todo[todoPos].tmin;
00383                                 tmax = todo[todoPos].tmax;
00384                         }
00385                         <span class="keywordflow">else</span>
00386                                 <span class="keywordflow">break</span>;
00387                 }
00388         }
00389         <span class="keywordflow">return</span> hit;
00390 }
<a name="l00391"></a><a class="code" href="classKdTreeAccel.html#a6">00391</a> <span class="keywordtype">bool</span> <a class="code" href="classKdTreeAccel.html#a6">KdTreeAccel::IntersectP</a>(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray)<span class="keyword"> const </span>{
00392         <span class="comment">// Compute initial parametric range of ray inside kd-tree extent</span>
00393         <span class="keywordtype">float</span> tmin, tmax;
00394         <span class="keywordflow">if</span> (!<a class="code" href="classKdTreeAccel.html#r10">bounds</a>.<a class="code" href="classBBox.html#a9">IntersectP</a>(ray, &amp;tmin, &amp;tmax))
00395                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00396         <span class="comment">// Prepare to traverse kd-tree for ray</span>
00397         <span class="keywordtype">int</span> rayId = <a class="code" href="classKdTreeAccel.html#r6">curMailboxId</a>++;
00398         <a class="code" href="classVector.html">Vector</a> invDir(1.f/ray.<a class="code" href="classRay.html#o1">d</a>.<a class="code" href="classVector.html#o0">x</a>, 1.f/ray.<a class="code" href="classRay.html#o1">d</a>.<a class="code" href="classVector.html#o1">y</a>, 1.f/ray.<a class="code" href="classRay.html#o1">d</a>.<a class="code" href="classVector.html#o2">z</a>);
00399 <span class="preprocessor">        #define MAX_TODO 64</span>
00400 <span class="preprocessor"></span>        <a class="code" href="structKdToDo.html">KdToDo</a> todo[<a class="code" href="kdtree_8cpp.html#a0">MAX_TODO</a>];
00401         <span class="keywordtype">int</span> todoPos = 0;
00402         <span class="keyword">const</span> <a class="code" href="structKdAccelNode.html">KdAccelNode</a> *node = &amp;<a class="code" href="classKdTreeAccel.html#r7">nodes</a>[0];
00403         <span class="keywordflow">while</span> (node != NULL) {
00404                 <span class="comment">// Update kd-tree shadow ray traversal statistics</span>
00405                 <span class="comment">//static StatsCounter nodesTraversed("Kd-Tree Accelerator",</span>
00406                 <span class="comment">//      "Number of kd-tree nodes traversed by shadow rays");</span>
00407                 <span class="comment">//++nodesTraversed;</span>
00408                 <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structKdAccelNode.html#a5">IsLeaf</a>()) {
00409                         <span class="comment">// Check for shadow ray intersections inside leaf node</span>
00410                         <a class="code" href="pbrt_8h.html#a51">u_int</a> nPrimitives = node-&gt;<a class="code" href="structKdAccelNode.html#a3">nPrimitives</a>();
00411                         <span class="keywordflow">if</span> (nPrimitives == 1) {
00412                                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *mp = node-&gt;<a class="code" href="structKdAccelNode.html#o4">onePrimitive</a>;
00413                                 <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> != rayId) {
00414                                         mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> = rayId;
00415                                         <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;IntersectP(ray))
00416                                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00417                                 }
00418                         }
00419                         <span class="keywordflow">else</span> {
00420                                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **prims = node-&gt;<a class="code" href="structKdAccelNode.html#o5">primitives</a>;
00421                                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; nPrimitives; ++i) {
00422                                         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *mp = prims[i];
00423                                         <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> != rayId) {
00424                                                 mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> = rayId;
00425                                                 <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;IntersectP(ray))
00426                                                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00427                                         }
00428                                 }
00429                         }
00430                         <span class="comment">// Grab next node to process from todo list</span>
00431                         <span class="keywordflow">if</span> (todoPos &gt; 0) {
00432                                 --todoPos;
00433                                 node = todo[todoPos].<a class="code" href="structKdToDo.html#o0">node</a>;
00434                                 tmin = todo[todoPos].tmin;
00435                                 tmax = todo[todoPos].tmax;
00436                         }
00437                         <span class="keywordflow">else</span>
00438                                 <span class="keywordflow">break</span>;
00439                 }
00440                 <span class="keywordflow">else</span> {
00441                         <span class="comment">// Process kd-tree interior node</span>
00442                         <span class="comment">// Compute parametric distance along ray to split plane</span>
00443                         <span class="keywordtype">int</span> axis = node-&gt;<a class="code" href="structKdAccelNode.html#a4">SplitAxis</a>();
00444                         <span class="keywordtype">float</span> tplane = (node-&gt;<a class="code" href="structKdAccelNode.html#a2">SplitPos</a>() - ray.<a class="code" href="classRay.html#o0">o</a>[axis]) *
00445                                 invDir[axis];
00446                         <span class="comment">// Get node children pointers for ray</span>
00447                         <span class="keyword">const</span> <a class="code" href="structKdAccelNode.html">KdAccelNode</a> *firstChild, *secondChild;
00448                         <span class="keywordtype">int</span> belowFirst = ray.<a class="code" href="classRay.html#o0">o</a>[axis] &lt;= node-&gt;<a class="code" href="structKdAccelNode.html#a2">SplitPos</a>();
00449                         <span class="keywordflow">if</span> (belowFirst) {
00450                                 firstChild = node + 1;
00451                                 secondChild = &amp;nodes[node-&gt;aboveChild];
00452                         }
00453                         <span class="keywordflow">else</span> {
00454                                 firstChild = &amp;nodes[node-&gt;<a class="code" href="structKdAccelNode.html#o3">aboveChild</a>];
00455                                 secondChild = node + 1;
00456                         }
00457                         <span class="comment">// Advance to next child node, possibly enqueue other child</span>
00458                         <span class="keywordflow">if</span> (tplane &gt; tmax || tplane &lt; 0)
00459                                 node = firstChild;
00460                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tplane &lt; tmin)
00461                                 node = secondChild;
00462                         <span class="keywordflow">else</span> {
00463                                 <span class="comment">// Enqueue _secondChild_ in todo list</span>
00464                                 todo[todoPos].<a class="code" href="structKdToDo.html#o0">node</a> = secondChild;
00465                                 todo[todoPos].<a class="code" href="structKdToDo.html#o1">tmin</a> = tplane;
00466                                 todo[todoPos].<a class="code" href="structKdToDo.html#o2">tmax</a> = tmax;
00467                                 ++todoPos;
00468                                 node = firstChild;
00469                                 tmax = tplane;
00470                         }
00471                 }
00472         }
00473         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00474 }
<a name="l00475"></a><a class="code" href="kdtree_8cpp.html#a2">00475</a> <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <a class="code" href="pbrt_8h.html#a2">DLLEXPORT</a> <a class="code" href="classPrimitive.html">Primitive</a> *<a class="code" href="kdtree_8cpp.html#a2">CreateAccelerator</a>(<span class="keyword">const</span> vector&lt;<a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> &gt; &amp;prims,
00476                 <span class="keyword">const</span> <a class="code" href="classParamSet.html">ParamSet</a> &amp;ps) {
00477         <span class="keywordtype">int</span> isectCost = ps.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"intersectcost"</span>, 80);
00478         <span class="keywordtype">int</span> travCost = ps.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"traversalcost"</span>, 1);
00479         <span class="keywordtype">float</span> emptyBonus = ps.<a class="code" href="classParamSet.html#a21">FindOneFloat</a>(<span class="stringliteral">"emptybonus"</span>, 0.5f);
00480         <span class="keywordtype">int</span> maxPrims = ps.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"maxprims"</span>, 1);
00481         <span class="keywordtype">int</span> maxDepth = ps.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"maxdepth"</span>, -1);
00482         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classKdTreeAccel.html">KdTreeAccel</a>(prims, isectCost, travCost,
00483                 emptyBonus, maxPrims, maxDepth);
00484 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Mon Apr 25 19:00:21 2005 for pbrt by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
