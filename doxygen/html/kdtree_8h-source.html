<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pbrt: kdtree.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>kdtree.h</h1><a href="kdtree_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> * pbrt source code Copyright(c) 1998-2005 Matt Pharr and Greg Humphreys</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * All Rights Reserved.</span>
00006 <span class="comment"> * For educational use only; commercial use expressly forbidden.</span>
00007 <span class="comment"> * NO WARRANTY, express or implied, for this software.</span>
00008 <span class="comment"> * (See file License.txt for complete license)</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="preprocessor">#ifndef PBRT_KDTREE_H</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define PBRT_KDTREE_H</span>
00013 <span class="preprocessor"></span><span class="comment">// kdtree.h*</span>
00014 <span class="preprocessor">#include "<a class="code" href="pbrt_8h.html">pbrt.h</a>"</span>
00015 <span class="preprocessor">#include "<a class="code" href="geometry_8h.html">geometry.h</a>"</span>
00016 <span class="comment">// KdTree Declarations</span>
<a name="l00017"></a><a class="code" href="structKdNode.html">00017</a> <span class="keyword">struct </span><a class="code" href="structKdNode.html">KdNode</a> {
<a name="l00018"></a><a class="code" href="structKdNode.html#a0">00018</a>         <span class="keywordtype">void</span> <a class="code" href="structKdNode.html#a0">init</a>(<span class="keywordtype">float</span> p, u_int a) {
00019                 <a class="code" href="structKdNode.html#o0">splitPos</a> = p;
00020                 <a class="code" href="structKdNode.html#o1">splitAxis</a> = a;
00021                 <a class="code" href="structKdNode.html#o3">rightChild</a> = ~(0U);
00022                 <a class="code" href="structKdNode.html#o2">hasLeftChild</a> = 0;
00023         }
<a name="l00024"></a><a class="code" href="structKdNode.html#a1">00024</a>         <span class="keywordtype">void</span> <a class="code" href="structKdNode.html#a1">initLeaf</a>() {
00025                 <a class="code" href="structKdNode.html#o1">splitAxis</a> = 3;
00026                 <a class="code" href="structKdNode.html#o3">rightChild</a> = ~(0U);
00027                 <a class="code" href="structKdNode.html#o2">hasLeftChild</a> = 0;
00028         }
00029         <span class="comment">// KdNode Data</span>
<a name="l00030"></a><a class="code" href="structKdNode.html#o0">00030</a>         <span class="keywordtype">float</span> <a class="code" href="structKdNode.html#o0">splitPos</a>;
<a name="l00031"></a><a class="code" href="structKdNode.html#o1">00031</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structKdNode.html#o1">splitAxis</a>:2;
<a name="l00032"></a><a class="code" href="structKdNode.html#o2">00032</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structKdNode.html#o2">hasLeftChild</a>:1;
<a name="l00033"></a><a class="code" href="structKdNode.html#o3">00033</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structKdNode.html#o3">rightChild</a>:29;
00034 };
<a name="l00035"></a><a class="code" href="classKdTree.html">00035</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> NodeData, <span class="keyword">class</span> LookupProc&gt; <span class="keyword">class </span><a class="code" href="classKdTree.html">KdTree</a> {
00036 <span class="keyword">public</span>:
00037         <span class="comment">// KdTree Public Methods</span>
00038         <a class="code" href="classKdTree.html">KdTree</a>(<span class="keyword">const</span> vector&lt;NodeData&gt; &amp;data);
<a name="l00039"></a><a class="code" href="classKdTree.html#a1">00039</a>         <a class="code" href="classKdTree.html#a1">~KdTree</a>() {
00040                 <a class="code" href="util_8cpp.html#a29">FreeAligned</a>(nodes);
00041                 <span class="keyword">delete</span>[] nodeData;
00042         }
00043         <span class="keywordtype">void</span> recursiveBuild(u_int nodeNum, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end,
00044                 vector&lt;const NodeData *&gt; &amp;buildNodes);
00045         <span class="keywordtype">void</span> Lookup(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p, <span class="keyword">const</span> LookupProc &amp;process,
00046                         <span class="keywordtype">float</span> &amp;maxDistSquared) <span class="keyword">const</span>;
00047 <span class="keyword">private</span>:
00048         <span class="comment">// KdTree Private Methods</span>
00049         <span class="keywordtype">void</span> privateLookup(u_int nodeNum, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p,
00050                 <span class="keyword">const</span> LookupProc &amp;process, <span class="keywordtype">float</span> &amp;maxDistSquared) <span class="keyword">const</span>;
00051         <span class="comment">// KdTree Private Data</span>
<a name="l00052"></a><a class="code" href="classKdTree.html#r0">00052</a>         <a class="code" href="structKdNode.html">KdNode</a> *nodes;
<a name="l00053"></a><a class="code" href="classKdTree.html#r1">00053</a>         NodeData *nodeData;
<a name="l00054"></a><a class="code" href="classKdTree.html#r2">00054</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> nNodes, nextFreeNode;
00055 };
<a name="l00056"></a><a class="code" href="structCompareNode.html">00056</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodeData&gt; <span class="keyword">struct </span><a class="code" href="structCompareNode.html">CompareNode</a> {
<a name="l00057"></a><a class="code" href="structCompareNode.html#a0">00057</a>         <a class="code" href="structCompareNode.html">CompareNode</a>(<span class="keywordtype">int</span> a) { <a class="code" href="structCompareNode.html#o0">axis</a> = a; }
<a name="l00058"></a><a class="code" href="structCompareNode.html#o0">00058</a>         <span class="keywordtype">int</span> <a class="code" href="structCompareNode.html#o0">axis</a>;
<a name="l00059"></a><a class="code" href="structCompareNode.html#a1">00059</a>         <span class="keywordtype">bool</span> <a class="code" href="structCompareNode.html#a1">operator()</a>(<span class="keyword">const</span> NodeData *d1,
00060                         <span class="keyword">const</span> NodeData *d2)<span class="keyword"> const </span>{
00061                 <span class="keywordflow">return</span> d1-&gt;p[<a class="code" href="structCompareNode.html#o0">axis</a>] == d2-&gt;p[<a class="code" href="structCompareNode.html#o0">axis</a>] ? (d1 &lt; d2) :
00062                         d1-&gt;p[<a class="code" href="structCompareNode.html#o0">axis</a>] &lt; d2-&gt;p[<a class="code" href="structCompareNode.html#o0">axis</a>];
00063         }
00064 };
00065 <span class="comment">// KdTree Method Definitions</span>
00066 <span class="keyword">template</span> &lt;<span class="keyword">class</span> NodeData, <span class="keyword">class</span> LookupProc&gt;
00067 <a class="code" href="classKdTree.html">KdTree</a>&lt;NodeData,
<a name="l00068"></a><a class="code" href="classKdTree.html#a0">00068</a>        LookupProc&gt;<a class="code" href="classKdTree.html">::KdTree</a>(<span class="keyword">const</span> vector&lt;NodeData&gt; &amp;d) {
00069         nNodes = d.size();
00070         nextFreeNode = 1;
00071         nodes = (<a class="code" href="structKdNode.html">KdNode</a> *)<a class="code" href="util_8cpp.html#a28">AllocAligned</a>(nNodes * <span class="keyword">sizeof</span>(<a class="code" href="structKdNode.html">KdNode</a>));
00072         nodeData = <span class="keyword">new</span> NodeData[nNodes];
00073         vector&lt;const NodeData *&gt; buildNodes;
00074         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; nNodes; ++i)
00075                 buildNodes.push_back(&amp;d[i]);
00076         <span class="comment">// Begin the KdTree building process</span>
00077         recursiveBuild(0, 0, nNodes, buildNodes);
00078 }
00079 <span class="keyword">template</span> &lt;<span class="keyword">class</span> NodeData, <span class="keyword">class</span> LookupProc&gt; <span class="keywordtype">void</span>
<a name="l00080"></a><a class="code" href="classKdTree.html#a2">00080</a> <a class="code" href="classKdTree.html">KdTree&lt;NodeData, LookupProc&gt;::recursiveBuild</a>(u_int nodeNum,
00081                 <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end,
00082                 vector&lt;const NodeData *&gt; &amp;buildNodes) {
00083         <span class="comment">// Create leaf node of kd-tree if we've reached the bottom</span>
00084         <span class="keywordflow">if</span> (start + 1 == end) {
00085                 <a class="code" href="classKdTree.html#r0">nodes</a>[nodeNum].<a class="code" href="structKdNode.html#a1">initLeaf</a>();
00086                 <a class="code" href="classKdTree.html#r1">nodeData</a>[nodeNum] = *buildNodes[start];
00087                 <span class="keywordflow">return</span>;
00088         }
00089         <span class="comment">// Choose split direction and partition data</span>
00090         <span class="comment">// Compute bounds of data from _start_ to _end_</span>
00091         <a class="code" href="classBBox.html">BBox</a> bound;
00092         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = start; i &lt; end; ++i)
00093                 bound = <a class="code" href="geometry_8cpp.html#a1">Union</a>(bound, buildNodes[i]-&gt;p);
00094         <span class="keywordtype">int</span> splitAxis = bound.<a class="code" href="classBBox.html#a7">MaximumExtent</a>();
00095         <span class="keywordtype">int</span> splitPos = (start+end)/2;
00096         std::nth_element(&amp;buildNodes[start], &amp;buildNodes[splitPos],
00097                 &amp;buildNodes[end], <a class="code" href="structCompareNode.html">CompareNode&lt;NodeData&gt;</a>(splitAxis));
00098         <span class="comment">// Allocate kd-tree node and continue recursively</span>
00099         <a class="code" href="classKdTree.html#r0">nodes</a>[nodeNum].<a class="code" href="structKdNode.html#a0">init</a>(buildNodes[splitPos]-&gt;p[splitAxis],
00100                 splitAxis);
00101         <a class="code" href="classKdTree.html#r1">nodeData</a>[nodeNum] = *buildNodes[splitPos];
00102         <span class="keywordflow">if</span> (start &lt; splitPos) {
00103                 <a class="code" href="classKdTree.html#r0">nodes</a>[nodeNum].<a class="code" href="structKdNode.html#o2">hasLeftChild</a> = 1;
00104                 <a class="code" href="pbrt_8h.html#a51">u_int</a> childNum = <a class="code" href="classKdTree.html#r3">nextFreeNode</a>++;
00105                 <a class="code" href="classKdTree.html#a2">recursiveBuild</a>(childNum, start, splitPos, buildNodes);
00106         }
00107         <span class="keywordflow">if</span> (splitPos+1 &lt; end) {
00108                 <a class="code" href="classKdTree.html#r0">nodes</a>[nodeNum].<a class="code" href="structKdNode.html#o3">rightChild</a> = <a class="code" href="classKdTree.html#r3">nextFreeNode</a>++;
00109                 <a class="code" href="classKdTree.html#a2">recursiveBuild</a>(<a class="code" href="classKdTree.html#r0">nodes</a>[nodeNum].rightChild, splitPos+1,
00110                                end, buildNodes);
00111         }
00112 }
00113 <span class="keyword">template</span> &lt;<span class="keyword">class</span> NodeData, <span class="keyword">class</span> LookupProc&gt; <span class="keywordtype">void</span>
<a name="l00114"></a><a class="code" href="classKdTree.html#a3">00114</a> <a class="code" href="classKdTree.html">KdTree&lt;NodeData, LookupProc&gt;::Lookup</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p,
00115                 <span class="keyword">const</span> LookupProc &amp;proc,
00116                 <span class="keywordtype">float</span> &amp;maxDistSquared)<span class="keyword"> const </span>{
00117         <a class="code" href="classKdTree.html#d0">privateLookup</a>(0, p, proc, maxDistSquared);
00118 }
00119 <span class="keyword">template</span> &lt;<span class="keyword">class</span> NodeData, <span class="keyword">class</span> LookupProc&gt; <span class="keywordtype">void</span>
<a name="l00120"></a><a class="code" href="classKdTree.html#d0">00120</a> <a class="code" href="classKdTree.html">KdTree&lt;NodeData, LookupProc&gt;::privateLookup</a>(u_int nodeNum,
00121                 <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p, <span class="keyword">const</span> LookupProc &amp;process,
00122                 <span class="keywordtype">float</span> &amp;maxDistSquared)<span class="keyword"> const </span>{
00123         <a class="code" href="structKdNode.html">KdNode</a> *node = &amp;<a class="code" href="classKdTree.html#r0">nodes</a>[nodeNum];
00124         <span class="comment">// Process kd-tree node's children</span>
00125         <span class="keywordtype">int</span> axis = node-&gt;<a class="code" href="structKdNode.html#o1">splitAxis</a>;
00126         <span class="keywordflow">if</span> (axis != 3) {
00127                 <span class="keywordtype">float</span> dist2 = (p[axis] - node-&gt;<a class="code" href="structKdNode.html#o0">splitPos</a>) *
00128                         (p[axis] - node-&gt;<a class="code" href="structKdNode.html#o0">splitPos</a>);
00129                 <span class="keywordflow">if</span> (p[axis] &lt;= node-&gt;<a class="code" href="structKdNode.html#o0">splitPos</a>) {
00130                         <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structKdNode.html#o2">hasLeftChild</a>)
00131                                 <a class="code" href="classKdTree.html#d0">privateLookup</a>(nodeNum+1, p,
00132                                               process, maxDistSquared);
00133                         <span class="keywordflow">if</span> (dist2 &lt; maxDistSquared &amp;&amp;
00134                             node-&gt;<a class="code" href="structKdNode.html#o3">rightChild</a> &lt; <a class="code" href="classKdTree.html#r2">nNodes</a>)
00135                                 <a class="code" href="classKdTree.html#d0">privateLookup</a>(node-&gt;<a class="code" href="structKdNode.html#o3">rightChild</a>,
00136                                               p,
00137                                                           process,
00138                                                           maxDistSquared);
00139                 }
00140                 <span class="keywordflow">else</span> {
00141                         <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structKdNode.html#o3">rightChild</a> &lt; <a class="code" href="classKdTree.html#r2">nNodes</a>)
00142                                 <a class="code" href="classKdTree.html#d0">privateLookup</a>(node-&gt;<a class="code" href="structKdNode.html#o3">rightChild</a>,
00143                                               p,
00144                                                           process,
00145                                                           maxDistSquared);
00146                         <span class="keywordflow">if</span> (dist2 &lt; maxDistSquared &amp;&amp; node-&gt;<a class="code" href="structKdNode.html#o2">hasLeftChild</a>)
00147                                 <a class="code" href="classKdTree.html#d0">privateLookup</a>(nodeNum+1,
00148                                               p,
00149                                                           process,
00150                                                           maxDistSquared);
00151                 }
00152         }
00153         <span class="comment">// Hand kd-tree node to processing function</span>
00154         <span class="keywordtype">float</span> dist2 = <a class="code" href="geometry_8h.html#a10">DistanceSquared</a>(<a class="code" href="classKdTree.html#r1">nodeData</a>[nodeNum].p, p);
00155         <span class="keywordflow">if</span> (dist2 &lt; maxDistSquared)
00156                 process(<a class="code" href="classKdTree.html#r1">nodeData</a>[nodeNum], dist2, maxDistSquared);
00157 }
00158 <span class="preprocessor">#endif // PBRT_KDTREE_H</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Mon Apr 25 19:00:21 2005 for pbrt by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
