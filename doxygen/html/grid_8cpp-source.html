<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pbrt: grid.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>grid.cpp</h1><a href="grid_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> * pbrt source code Copyright(c) 1998-2005 Matt Pharr and Greg Humphreys</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * All Rights Reserved.</span>
00006 <span class="comment"> * For educational use only; commercial use expressly forbidden.</span>
00007 <span class="comment"> * NO WARRANTY, express or implied, for this software.</span>
00008 <span class="comment"> * (See file License.txt for complete license)</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">// grid.cpp*</span>
00012 <span class="preprocessor">#include "<a class="code" href="pbrt_8h.html">pbrt.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="primitive_8h.html">primitive.h</a>"</span>
00014 <span class="keyword">static</span> <a class="code" href="classStatsRatio.html">StatsRatio</a> <a class="code" href="grid_8cpp.html#a0">rayTests</a>(<span class="stringliteral">"Grid Accelerator"</span>, <span class="stringliteral">"Intersection tests per ray"</span>); <span class="comment">// NOBOOK</span>
00015 <span class="keyword">static</span> <a class="code" href="classStatsRatio.html">StatsRatio</a> <a class="code" href="grid_8cpp.html#a1">rayHits</a>(<span class="stringliteral">"Grid Accelerator"</span>, <span class="stringliteral">"Intersections found per ray"</span>); <span class="comment">// NOBOOK</span>
00016 <span class="comment">// GridAccel Forward Declarations</span>
00017 <span class="keyword">struct </span><a class="code" href="structMailboxPrim.html">MailboxPrim</a>;
00018 <span class="keyword">struct </span><a class="code" href="structVoxel.html">Voxel</a>;
00019 <span class="comment">// MailboxPrim Declarations</span>
<a name="l00020"></a><a class="code" href="structMailboxPrim.html">00020</a> <span class="keyword">struct </span><a class="code" href="structMailboxPrim.html">MailboxPrim</a> {
<a name="l00021"></a><a class="code" href="structMailboxPrim.html#a0">00021</a>         <a class="code" href="structMailboxPrim.html">MailboxPrim</a>(<span class="keyword">const</span> <a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> &amp;p) {
00022                 <a class="code" href="structMailboxPrim.html#o0">primitive</a> = p;
00023                 <a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> = -1;
00024         }
<a name="l00025"></a><a class="code" href="structMailboxPrim.html#o0">00025</a>         <a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> <a class="code" href="structMailboxPrim.html#o0">primitive</a>;
00026         <span class="keywordtype">int</span> <a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a>;
00027 };
00028 <span class="comment">// Voxel Declarations</span>
<a name="l00029"></a><a class="code" href="structVoxel.html">00029</a> <span class="keyword">struct </span><a class="code" href="structVoxel.html">Voxel</a> {
00030         <span class="comment">// Voxel Public Methods</span>
<a name="l00031"></a><a class="code" href="structVoxel.html#a0">00031</a>         <a class="code" href="structVoxel.html">Voxel</a>(<a class="code" href="structMailboxPrim.html">MailboxPrim</a> *op) {
00032                 <a class="code" href="structVoxel.html#o2">allCanIntersect</a> = <span class="keyword">false</span>;
00033                 <a class="code" href="structVoxel.html#o3">nPrimitives</a> = 1;
00034                 <a class="code" href="structVoxel.html#o0">onePrimitive</a> = op;
00035         }
<a name="l00036"></a><a class="code" href="structVoxel.html#a1">00036</a>         <span class="keywordtype">void</span> <a class="code" href="structVoxel.html#a1">AddPrimitive</a>(<a class="code" href="structMailboxPrim.html">MailboxPrim</a> *prim) {
00037                 <span class="keywordflow">if</span> (<a class="code" href="structVoxel.html#o3">nPrimitives</a> == 1) {
00038                         <span class="comment">// Allocate initial _primitives_ array in voxel</span>
00039                         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **p = <span class="keyword">new</span> <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *[2];
00040                         p[0] = <a class="code" href="structVoxel.html#o0">onePrimitive</a>;
00041                         <a class="code" href="structVoxel.html#o1">primitives</a> = p;
00042                 }
00043                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="pbrt_8h.html#a102">IsPowerOf2</a>(<a class="code" href="structVoxel.html#o3">nPrimitives</a>)) {
00044                         <span class="comment">// Increase size of _primitives_ array in voxel</span>
00045                         <span class="keywordtype">int</span> nAlloc = 2 * <a class="code" href="structVoxel.html#o3">nPrimitives</a>;
00046                         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **p = <span class="keyword">new</span> <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *[nAlloc];
00047                         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; nPrimitives; ++i)
00048                                 p[i] = <a class="code" href="structVoxel.html#o1">primitives</a>[i];
00049                         <span class="keyword">delete</span>[] primitives;
00050                         primitives = p;
00051                 }
00052                 <a class="code" href="structVoxel.html#o1">primitives</a>[<a class="code" href="structVoxel.html#o3">nPrimitives</a>] = prim;
00053                 ++<a class="code" href="structVoxel.html#o3">nPrimitives</a>;
00054         }
<a name="l00055"></a><a class="code" href="structVoxel.html#a2">00055</a>         <a class="code" href="structVoxel.html#a2">~Voxel</a>() {
00056                 <span class="keywordflow">if</span> (<a class="code" href="structVoxel.html#o3">nPrimitives</a> &gt; 1) <span class="keyword">delete</span>[] <a class="code" href="structVoxel.html#o1">primitives</a>;
00057         }
00058         <span class="keywordtype">bool</span> Intersect(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray,
00059                        <a class="code" href="structIntersection.html">Intersection</a> *isect,
00060                                    <span class="keywordtype">int</span> rayId);
00061         <span class="keywordtype">bool</span> IntersectP(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray, <span class="keywordtype">int</span> rayId);
00062         <span class="keyword">union </span>{
<a name="l00063"></a><a class="code" href="structVoxel.html#o0">00063</a>                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *<a class="code" href="structVoxel.html#o0">onePrimitive</a>;
<a name="l00064"></a><a class="code" href="structVoxel.html#o1">00064</a>                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **<a class="code" href="structVoxel.html#o1">primitives</a>;
00065         };
<a name="l00066"></a><a class="code" href="structVoxel.html#o2">00066</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structVoxel.html#o2">allCanIntersect</a>:1;
<a name="l00067"></a><a class="code" href="structVoxel.html#o3">00067</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structVoxel.html#o3">nPrimitives</a>:31;
00068 };
00069 <span class="comment">// GridAccel Declarations</span>
<a name="l00070"></a><a class="code" href="classGridAccel.html">00070</a> <span class="keyword">class  </span><a class="code" href="classGridAccel.html">GridAccel</a> : <span class="keyword">public</span> <a class="code" href="classAggregate.html">Aggregate</a> {
00071 <span class="keyword">public</span>:
00072         <span class="comment">// GridAccel Public Methods</span>
00073         <a class="code" href="classGridAccel.html">GridAccel</a>(<span class="keyword">const</span> vector&lt;<a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> &gt; &amp;p,
00074                   <span class="keywordtype">bool</span> forRefined, <span class="keywordtype">bool</span> refineImmediately);
00075         <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classGridAccel.html#a1">WorldBound</a>() <span class="keyword">const</span>;
<a name="l00076"></a><a class="code" href="classGridAccel.html#a2">00076</a>         <span class="keywordtype">bool</span> <a class="code" href="classGridAccel.html#a2">CanIntersect</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
00077         <a class="code" href="classGridAccel.html#a3">~GridAccel</a>();
00078         <span class="keywordtype">bool</span> Intersect(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray, <a class="code" href="structIntersection.html">Intersection</a> *isect) <span class="keyword">const</span>;
00079         <span class="keywordtype">bool</span> IntersectP(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray) <span class="keyword">const</span>;
00080 <span class="keyword">private</span>:
00081         <span class="comment">// GridAccel Private Methods</span>
<a name="l00082"></a><a class="code" href="classGridAccel.html#d0">00082</a>         <span class="keywordtype">int</span> <a class="code" href="classGridAccel.html#d0">PosToVoxel</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;P, <span class="keywordtype">int</span> axis)<span class="keyword"> const </span>{
00083                 <span class="keywordtype">int</span> v = <a class="code" href="pbrt_8h.html#a105">Float2Int</a>((P[axis] - <a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#o0">pMin</a>[axis]) *
00084                                   <a class="code" href="classGridAccel.html#r6">InvWidth</a>[axis]);
00085                 <span class="keywordflow">return</span> <a class="code" href="pbrt_8h.html#a96">Clamp</a>(v, 0, <a class="code" href="classGridAccel.html#r3">NVoxels</a>[axis]-1);
00086         }
<a name="l00087"></a><a class="code" href="classGridAccel.html#d1">00087</a>         <span class="keywordtype">float</span> <a class="code" href="classGridAccel.html#d1">VoxelToPos</a>(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> axis)<span class="keyword"> const </span>{
00088                 <span class="keywordflow">return</span> <a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#o0">pMin</a>[axis] + p * <a class="code" href="classGridAccel.html#r5">Width</a>[axis];
00089         }
<a name="l00090"></a><a class="code" href="classGridAccel.html#d2">00090</a>         <a class="code" href="classPoint.html">Point</a> VoxelToPos(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z)<span class="keyword"> const </span>{
00091                 <span class="keywordflow">return</span> <a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#o0">pMin</a> +
00092                         <a class="code" href="classVector.html">Vector</a>(x * <a class="code" href="classGridAccel.html#r5">Width</a>[0], y * Width[1], z * Width[2]);
00093         }
<a name="l00094"></a><a class="code" href="classGridAccel.html#d3">00094</a>         <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classGridAccel.html#d3">Offset</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z)<span class="keyword"> const </span>{
00095                 <span class="keywordflow">return</span> z*<a class="code" href="classGridAccel.html#r3">NVoxels</a>[0]*NVoxels[1] + y*NVoxels[0] + x;
00096         }
00097         <span class="comment">// GridAccel Private Data</span>
<a name="l00098"></a><a class="code" href="classGridAccel.html#r0">00098</a>         <span class="keywordtype">bool</span> <a class="code" href="classGridAccel.html#r0">gridForRefined</a>;
<a name="l00099"></a><a class="code" href="classGridAccel.html#r1">00099</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="classGridAccel.html#r1">nMailboxes</a>;
<a name="l00100"></a><a class="code" href="classGridAccel.html#r2">00100</a>         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *<a class="code" href="classGridAccel.html#r2">mailboxes</a>;
<a name="l00101"></a><a class="code" href="classGridAccel.html#r3">00101</a>         <span class="keywordtype">int</span> <a class="code" href="classGridAccel.html#r3">NVoxels</a>[3];
<a name="l00102"></a><a class="code" href="classGridAccel.html#r4">00102</a>         <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classGridAccel.html#r4">bounds</a>;
<a name="l00103"></a><a class="code" href="classGridAccel.html#r5">00103</a>         <a class="code" href="classVector.html">Vector</a> <a class="code" href="classGridAccel.html#r5">Width</a>, <a class="code" href="classGridAccel.html#r6">InvWidth</a>;
<a name="l00104"></a><a class="code" href="classGridAccel.html#r7">00104</a>         <a class="code" href="structVoxel.html">Voxel</a> **<a class="code" href="classGridAccel.html#r7">voxels</a>;
<a name="l00105"></a><a class="code" href="classGridAccel.html#r8">00105</a>         <a class="code" href="classObjectArena.html">ObjectArena&lt;Voxel&gt;</a> <a class="code" href="classGridAccel.html#r8">voxelArena</a>;
00106         <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="classGridAccel.html#v0">curMailboxId</a>;
00107 };
00108 <span class="comment">// GridAccel Method Definitions</span>
<a name="l00109"></a><a class="code" href="classGridAccel.html#a0">00109</a> <a class="code" href="classGridAccel.html#a0">GridAccel::GridAccel</a>(<span class="keyword">const</span> vector&lt;<a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> &gt; &amp;p,
00110                 <span class="keywordtype">bool</span> forRefined, <span class="keywordtype">bool</span> refineImmediately)
00111         : gridForRefined(forRefined) {
00112         <span class="comment">// Initialize _prims_ with primitives for grid</span>
00113         vector&lt;Reference&lt;Primitive&gt; &gt; prims;
00114         <span class="keywordflow">if</span> (refineImmediately)
00115                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; p.size(); ++i)
00116                         p[i]-&gt;FullyRefine(prims);
00117         <span class="keywordflow">else</span>
00118                 prims = p;
00119         <span class="comment">// Initialize mailboxes for grid</span>
00120         <a class="code" href="classGridAccel.html#r1">nMailboxes</a> = prims.size();
00121         <a class="code" href="classGridAccel.html#r2">mailboxes</a> = (<a class="code" href="structMailboxPrim.html">MailboxPrim</a> *)<a class="code" href="util_8cpp.html#a28">AllocAligned</a>(<a class="code" href="classGridAccel.html#r1">nMailboxes</a> *
00122                 <span class="keyword">sizeof</span>(<a class="code" href="structMailboxPrim.html">MailboxPrim</a>));
00123         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="classGridAccel.html#r1">nMailboxes</a>; ++i)
00124                 <span class="keyword">new</span> (&amp;<a class="code" href="classGridAccel.html#r2">mailboxes</a>[i]) MailboxPrim(prims[i]);
00125         <span class="comment">// Compute bounds and choose grid resolution</span>
00126         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; prims.size(); ++i)
00127                 <a class="code" href="classGridAccel.html#r4">bounds</a> = <a class="code" href="geometry_8cpp.html#a1">Union</a>(<a class="code" href="classGridAccel.html#r4">bounds</a>, prims[i]-&gt;<a class="code" href="classGridAccel.html#a1">WorldBound</a>());
00128         <a class="code" href="classVector.html">Vector</a> delta = <a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#o1">pMax</a> - <a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#o0">pMin</a>;
00129         <span class="comment">// Find _voxelsPerUnitDist_ for grid</span>
00130         <span class="keywordtype">int</span> maxAxis = <a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#a7">MaximumExtent</a>();
00131         <span class="keywordtype">float</span> invMaxWidth = 1.f / delta[maxAxis];
00132         <a class="code" href="pbrt_8h.html#a14">Assert</a>(invMaxWidth &gt; 0.f); <span class="comment">// NOBOOK</span>
00133         <span class="keywordtype">float</span> cubeRoot = 3.f * powf(<span class="keywordtype">float</span>(prims.size()), 1.f/3.f);
00134         <span class="keywordtype">float</span> voxelsPerUnitDist = cubeRoot * invMaxWidth;
00135         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> axis = 0; axis &lt; 3; ++axis) {
00136                 <a class="code" href="classGridAccel.html#r3">NVoxels</a>[axis] =
00137                      <a class="code" href="pbrt_8h.html#a104">Round2Int</a>(delta[axis] * voxelsPerUnitDist);
00138                 <a class="code" href="classGridAccel.html#r3">NVoxels</a>[axis] = <a class="code" href="pbrt_8h.html#a96">Clamp</a>(<a class="code" href="classGridAccel.html#r3">NVoxels</a>[axis], 1, 64);
00139         }
00140         <span class="comment">// Compute voxel widths and allocate voxels</span>
00141         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> axis = 0; axis &lt; 3; ++axis) {
00142                 <a class="code" href="classGridAccel.html#r5">Width</a>[axis] = delta[axis] / <a class="code" href="classGridAccel.html#r3">NVoxels</a>[axis];
00143                 <a class="code" href="classGridAccel.html#r6">InvWidth</a>[axis] =
00144                     (<a class="code" href="classGridAccel.html#r5">Width</a>[axis] == 0.f) ? 0.f : 1.f / Width[axis];
00145         }
00146         <span class="keywordtype">int</span> nVoxels = <a class="code" href="classGridAccel.html#r3">NVoxels</a>[0] * NVoxels[1] * NVoxels[2];
00147         <a class="code" href="classGridAccel.html#r7">voxels</a> = (<a class="code" href="structVoxel.html">Voxel</a> **)<a class="code" href="util_8cpp.html#a28">AllocAligned</a>(nVoxels * <span class="keyword">sizeof</span>(<a class="code" href="structVoxel.html">Voxel</a> *));
00148         memset(<a class="code" href="classGridAccel.html#r7">voxels</a>, 0, nVoxels * <span class="keyword">sizeof</span>(Voxel *));
00149         <span class="comment">// Add primitives to grid voxels</span>
00150         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; prims.size(); ++i) {
00151                 <span class="comment">// Find voxel extent of primitive</span>
00152                 <a class="code" href="classBBox.html">BBox</a> pb = prims[i]-&gt;WorldBound();
00153                 <span class="keywordtype">int</span> vmin[3], vmax[3];
00154                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> axis = 0; axis &lt; 3; ++axis) {
00155                         vmin[axis] = <a class="code" href="classGridAccel.html#d0">PosToVoxel</a>(pb.<a class="code" href="classBBox.html#o0">pMin</a>, axis);
00156                         vmax[axis] = PosToVoxel(pb.<a class="code" href="classBBox.html#o1">pMax</a>, axis);
00157                 }
00158                 <span class="comment">// Add primitive to overlapping voxels</span>
00159                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> z = vmin[2]; z &lt;= vmax[2]; ++z)
00160                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = vmin[1]; y &lt;= vmax[1]; ++y)
00161                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = vmin[0]; x &lt;= vmax[0]; ++x) {
00162                                         <span class="keywordtype">int</span> offset = <a class="code" href="classGridAccel.html#d3">Offset</a>(x, y, z);
00163                                         <span class="keywordflow">if</span> (!<a class="code" href="classGridAccel.html#r7">voxels</a>[offset]) {
00164                                                 <span class="comment">// Allocate new voxel and store primitive in it</span>
00165                                                 <a class="code" href="classGridAccel.html#r7">voxels</a>[offset] = <span class="keyword">new</span> (<a class="code" href="classGridAccel.html#r8">voxelArena</a>) Voxel(&amp;<a class="code" href="classGridAccel.html#r2">mailboxes</a>[i]);
00166                                         }
00167                                         <span class="keywordflow">else</span> {
00168                                                 <span class="comment">// Add primitive to already-allocated voxel</span>
00169                                                 <a class="code" href="classGridAccel.html#r7">voxels</a>[offset]-&gt;<a class="code" href="structVoxel.html#a1">AddPrimitive</a>(&amp;<a class="code" href="classGridAccel.html#r2">mailboxes</a>[i]);
00170                                         }
00171                                 }
00172                 <span class="keyword">static</span> <a class="code" href="classStatsRatio.html">StatsRatio</a> nPrimitiveVoxels(<span class="stringliteral">"Grid Accelerator"</span>, <span class="comment">// NOBOOK</span>
00173                         <span class="stringliteral">"Voxels covered vs # / primitives"</span>); <span class="comment">// NOBOOK</span>
00174                 nPrimitiveVoxels.<a class="code" href="classStatsRatio.html#a1">Add</a>((1 + vmax[0]-vmin[0]) * (1 + vmax[1]-vmin[1]) * <span class="comment">// NOBOOK</span>
00175                         (1 + vmax[2]-vmin[2]), 1); <span class="comment">// NOBOOK</span>
00176         }
00177         <span class="comment">// Update grid statistics</span>
00178         <span class="keyword">static</span> <a class="code" href="classStatsPercentage.html">StatsPercentage</a> nEmptyVoxels(<span class="stringliteral">"Grid Accelerator"</span>,
00179                                             <span class="stringliteral">"Empty voxels"</span>);
00180         <span class="keyword">static</span> <a class="code" href="classStatsRatio.html">StatsRatio</a> avgPrimsInVoxel(<span class="stringliteral">"Grid Accelerator"</span>,
00181                 <span class="stringliteral">"Average # of primitives in voxel"</span>);
00182         <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> maxPrimsInVoxel(<span class="stringliteral">"Grid Accelerator"</span>,
00183                 <span class="stringliteral">"Max # of primitives in a grid voxel"</span>);
00184         nEmptyVoxels.<a class="code" href="classStatsPercentage.html#a0">Add</a>(0, NVoxels[0] * NVoxels[1] * NVoxels[2]);
00185         avgPrimsInVoxel.<a class="code" href="classStatsRatio.html#a1">Add</a>(0,NVoxels[0] * NVoxels[1] * NVoxels[2]);
00186         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> z = 0; z &lt; NVoxels[2]; ++z)
00187                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; NVoxels[1]; ++y)
00188                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; NVoxels[0]; ++x) {
00189                                 <span class="keywordtype">int</span> offset = <a class="code" href="classGridAccel.html#d3">Offset</a>(x, y, z);
00190                                 <span class="keywordflow">if</span> (!<a class="code" href="classGridAccel.html#r7">voxels</a>[offset]) nEmptyVoxels.<a class="code" href="classStatsPercentage.html#a0">Add</a>(1, 0);
00191                                 <span class="keywordflow">else</span> {
00192                                     <span class="keywordtype">int</span> nPrims = <a class="code" href="classGridAccel.html#r7">voxels</a>[offset]-&gt;<a class="code" href="structVoxel.html#o3">nPrimitives</a>;
00193                                         maxPrimsInVoxel.<a class="code" href="classStatsCounter.html#a3">Max</a>(nPrims);
00194                                         avgPrimsInVoxel.<a class="code" href="classStatsRatio.html#a1">Add</a>(nPrims, 0);
00195                                 }
00196                         }
00197 }
<a name="l00198"></a><a class="code" href="classGridAccel.html#a1">00198</a> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classGridAccel.html#a1">GridAccel::WorldBound</a>()<span class="keyword"> const </span>{
00199         <span class="keywordflow">return</span> <a class="code" href="classGridAccel.html#r4">bounds</a>;
00200 }
<a name="l00201"></a><a class="code" href="classGridAccel.html#a3">00201</a> <a class="code" href="classGridAccel.html#a3">GridAccel::~GridAccel</a>() {
00202         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="classGridAccel.html#r1">nMailboxes</a>; ++i)
00203                 <a class="code" href="classGridAccel.html#r2">mailboxes</a>[i].~MailboxPrim();
00204         <a class="code" href="util_8cpp.html#a29">FreeAligned</a>(<a class="code" href="classGridAccel.html#r2">mailboxes</a>);
00205         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0;
00206              i &lt; <a class="code" href="classGridAccel.html#r3">NVoxels</a>[0]*NVoxels[1]*NVoxels[2];
00207                  ++i)
00208                 <span class="keywordflow">if</span> (<a class="code" href="classGridAccel.html#r7">voxels</a>[i]) <a class="code" href="classGridAccel.html#r7">voxels</a>[i]-&gt;<a class="code" href="structVoxel.html#a2">~Voxel</a>();
00209         <a class="code" href="util_8cpp.html#a29">FreeAligned</a>(<a class="code" href="classGridAccel.html#r7">voxels</a>);
00210 }
<a name="l00211"></a><a class="code" href="classGridAccel.html#a4">00211</a> <span class="keywordtype">bool</span> <a class="code" href="classGridAccel.html#a4">GridAccel::Intersect</a>(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray,
00212                           <a class="code" href="structIntersection.html">Intersection</a> *isect)<span class="keyword"> const </span>{
00213         <span class="keywordflow">if</span> (!<a class="code" href="classGridAccel.html#r0">gridForRefined</a>) { <span class="comment">// NOBOOK</span>
00214                 <a class="code" href="grid_8cpp.html#a0">rayTests</a>.<a class="code" href="classStatsRatio.html#a1">Add</a>(0, 1); <span class="comment">// NOBOOK</span>
00215                 <a class="code" href="grid_8cpp.html#a1">rayHits</a>.<a class="code" href="classStatsRatio.html#a1">Add</a>(0, 1); <span class="comment">// NOBOOK</span>
00216         } <span class="comment">// NOBOOK</span>
00217         <span class="comment">// Check ray against overall grid bounds</span>
00218         <span class="keywordtype">float</span> rayT;
00219         <span class="keywordflow">if</span> (<a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#a4">Inside</a>(ray(ray.<a class="code" href="classRay.html#o2">mint</a>)))
00220                 rayT = ray.<a class="code" href="classRay.html#o2">mint</a>;
00221         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#a9">IntersectP</a>(ray, &amp;rayT))
00222                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00223         <a class="code" href="classPoint.html">Point</a> gridIntersect = ray(rayT);
00224         <span class="comment">// Get ray mailbox id</span>
00225         <span class="keywordtype">int</span> rayId = ++<a class="code" href="classGridAccel.html#v0">curMailboxId</a>;
00226         <span class="comment">// Set up 3D DDA for ray</span>
00227         <span class="keywordtype">float</span> NextCrossingT[3], DeltaT[3];
00228         <span class="keywordtype">int</span> Step[3], Out[3], Pos[3];
00229         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> axis = 0; axis &lt; 3; ++axis) {
00230                 <span class="comment">// Compute current voxel for axis</span>
00231                 Pos[axis] = <a class="code" href="classGridAccel.html#d0">PosToVoxel</a>(gridIntersect, axis);
00232                 <span class="keywordflow">if</span> (ray.d[axis] &gt;= 0) {
00233                         <span class="comment">// Handle ray with positive direction for voxel stepping</span>
00234                         NextCrossingT[axis] = rayT +
00235                                 (<a class="code" href="classGridAccel.html#d1">VoxelToPos</a>(Pos[axis]+1, axis) - gridIntersect[axis]) /
00236                                         ray.d[axis];
00237                         DeltaT[axis] = <a class="code" href="classGridAccel.html#r5">Width</a>[axis] / ray.d[axis];
00238                         Step[axis] = 1;
00239                         Out[axis] = <a class="code" href="classGridAccel.html#r3">NVoxels</a>[axis];
00240                 }
00241                 <span class="keywordflow">else</span> {
00242                         <span class="comment">// Handle ray with negative direction for voxel stepping</span>
00243                         NextCrossingT[axis] = rayT +
00244                                 (<a class="code" href="classGridAccel.html#d1">VoxelToPos</a>(Pos[axis], axis) - gridIntersect[axis]) /
00245                                         ray.d[axis];
00246                         DeltaT[axis] = -<a class="code" href="classGridAccel.html#r5">Width</a>[axis] / ray.d[axis];
00247                         Step[axis] = -1;
00248                         Out[axis] = -1;
00249                 }
00250         }
00251         <span class="comment">// Walk ray through voxel grid</span>
00252         <span class="keywordtype">bool</span> hitSomething = <span class="keyword">false</span>;
00253         <span class="keywordflow">for</span> (;;) {
00254                 <a class="code" href="structVoxel.html">Voxel</a> *voxel =
00255                         <a class="code" href="classGridAccel.html#r7">voxels</a>[<a class="code" href="classGridAccel.html#d3">Offset</a>(Pos[0],   Pos[1], Pos[2])];
00256                 <span class="keywordflow">if</span> (voxel != NULL)
00257                         hitSomething |= voxel-&gt;<a class="code" href="structVoxel.html#a3">Intersect</a>(ray, isect, rayId);
00258                 <span class="comment">// Advance to next voxel</span>
00259                 <span class="comment">// Find _stepAxis_ for stepping to next voxel</span>
00260                 <span class="keywordtype">int</span> bits = ((NextCrossingT[0] &lt; NextCrossingT[1]) &lt;&lt; 2) +
00261                         ((NextCrossingT[0] &lt; NextCrossingT[2]) &lt;&lt; 1) +
00262                         ((NextCrossingT[1] &lt; NextCrossingT[2]));
00263                 <span class="keyword">const</span> <span class="keywordtype">int</span> cmpToAxis[8] = { 2, 1, 2, 1, 2, 2, 0, 0 };
00264                 <span class="keywordtype">int</span> stepAxis = cmpToAxis[bits];
00265                 <span class="keywordflow">if</span> (ray.maxt &lt; NextCrossingT[stepAxis])
00266                         <span class="keywordflow">break</span>;
00267                 Pos[stepAxis] += Step[stepAxis];
00268                 <span class="keywordflow">if</span> (Pos[stepAxis] == Out[stepAxis])
00269                         <span class="keywordflow">break</span>;
00270                 NextCrossingT[stepAxis] += DeltaT[stepAxis];
00271         }
00272         <span class="keywordflow">return</span> hitSomething;
00273 }
<a name="l00274"></a><a class="code" href="classGridAccel.html#v0">00274</a> <span class="keywordtype">int</span> <a class="code" href="classGridAccel.html#v0">GridAccel::curMailboxId</a> = 0;
<a name="l00275"></a><a class="code" href="structVoxel.html#a3">00275</a> <span class="keywordtype">bool</span> <a class="code" href="structVoxel.html#a3">Voxel::Intersect</a>(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray,
00276                       <a class="code" href="structIntersection.html">Intersection</a> *isect,
00277                                           <span class="keywordtype">int</span> rayId) {
00278         <span class="comment">// Refine primitives in voxel if needed</span>
00279         <span class="keywordflow">if</span> (!<a class="code" href="structVoxel.html#o2">allCanIntersect</a>) {
00280                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **mpp;
00281                 <span class="keywordflow">if</span> (<a class="code" href="structVoxel.html#o3">nPrimitives</a> == 1) mpp = &amp;<a class="code" href="structVoxel.html#o0">onePrimitive</a>;
00282                 <span class="keywordflow">else</span> mpp = <a class="code" href="structVoxel.html#o1">primitives</a>;
00283                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="structVoxel.html#o3">nPrimitives</a>; ++i) {
00284                         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *mp = mpp[i];
00285                         <span class="comment">// Refine primitive in _mp_ if it's not intersectable</span>
00286                         <span class="keywordflow">if</span> (!mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;CanIntersect()) {
00287                                 vector&lt;Reference&lt;Primitive&gt; &gt; p;
00288                                 mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;FullyRefine(p);
00289                                 <a class="code" href="pbrt_8h.html#a14">Assert</a>(p.size() &gt; 0); <span class="comment">// NOBOOK</span>
00290                                 <span class="keywordflow">if</span> (p.size() == 1)
00291                                         mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a> = p[0];
00292                                 <span class="keywordflow">else</span>
00293                                         mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a> = <span class="keyword">new</span> <a class="code" href="classGridAccel.html">GridAccel</a>(p, <span class="keyword">true</span>, <span class="keyword">false</span>);
00294                         }
00295                 }
00296                 <a class="code" href="structVoxel.html#o2">allCanIntersect</a> = <span class="keyword">true</span>;
00297         }
00298         <span class="comment">// Loop over primitives in voxel and find intersections</span>
00299         <span class="keywordtype">bool</span> hitSomething = <span class="keyword">false</span>;
00300         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **mpp;
00301         <span class="keywordflow">if</span> (<a class="code" href="structVoxel.html#o3">nPrimitives</a> == 1) mpp = &amp;<a class="code" href="structVoxel.html#o0">onePrimitive</a>;
00302         <span class="keywordflow">else</span> mpp = <a class="code" href="structVoxel.html#o1">primitives</a>;
00303         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="structVoxel.html#o3">nPrimitives</a>; ++i) {
00304                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *mp = mpp[i];
00305                 <span class="comment">// Do mailbox check between ray and primitive</span>
00306                 <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> == rayId)
00307                         <span class="keywordflow">continue</span>;
00308                 <span class="comment">// Check for ray--primitive intersection</span>
00309                 mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> = rayId;
00310                 <a class="code" href="grid_8cpp.html#a0">rayTests</a>.<a class="code" href="classStatsRatio.html#a1">Add</a>(1, 0); <span class="comment">// NOBOOK</span>
00311                 <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;Intersect(ray, isect)) {
00312                         <a class="code" href="grid_8cpp.html#a1">rayHits</a>.<a class="code" href="classStatsRatio.html#a1">Add</a>(1, 0); <span class="comment">// NOBOOK</span>
00313                         hitSomething = <span class="keyword">true</span>;
00314                 }
00315         }
00316         <span class="keywordflow">return</span> hitSomething;
00317 }
<a name="l00318"></a><a class="code" href="classGridAccel.html#a5">00318</a> <span class="keywordtype">bool</span> <a class="code" href="classGridAccel.html#a5">GridAccel::IntersectP</a>(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray)<span class="keyword"> const </span>{
00319         <span class="keywordflow">if</span> (!<a class="code" href="classGridAccel.html#r0">gridForRefined</a>) { <span class="comment">// NOBOOK</span>
00320                 <a class="code" href="grid_8cpp.html#a0">rayTests</a>.<a class="code" href="classStatsRatio.html#a1">Add</a>(0, 1); <span class="comment">// NOBOOK</span>
00321                 <a class="code" href="grid_8cpp.html#a1">rayHits</a>.<a class="code" href="classStatsRatio.html#a1">Add</a>(0, 1); <span class="comment">// NOBOOK</span>
00322         } <span class="comment">// NOBOOK</span>
00323         <span class="keywordtype">int</span> rayId = ++<a class="code" href="classGridAccel.html#v0">curMailboxId</a>;
00324         <span class="comment">// Check ray against overall grid bounds</span>
00325         <span class="keywordtype">float</span> rayT;
00326         <span class="keywordflow">if</span> (<a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#a4">Inside</a>(ray(ray.<a class="code" href="classRay.html#o2">mint</a>)))
00327                 rayT = ray.<a class="code" href="classRay.html#o2">mint</a>;
00328         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classGridAccel.html#r4">bounds</a>.<a class="code" href="classBBox.html#a9">IntersectP</a>(ray, &amp;rayT))
00329                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00330         <a class="code" href="classPoint.html">Point</a> gridIntersect = ray(rayT);
00331         <span class="comment">// Set up 3D DDA for ray</span>
00332         <span class="keywordtype">float</span> NextCrossingT[3], DeltaT[3];
00333         <span class="keywordtype">int</span> Step[3], Out[3], Pos[3];
00334         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> axis = 0; axis &lt; 3; ++axis) {
00335                 <span class="comment">// Compute current voxel for axis</span>
00336                 Pos[axis] = <a class="code" href="classGridAccel.html#d0">PosToVoxel</a>(gridIntersect, axis);
00337                 <span class="keywordflow">if</span> (ray.d[axis] &gt;= 0) {
00338                         <span class="comment">// Handle ray with positive direction for voxel stepping</span>
00339                         NextCrossingT[axis] = rayT +
00340                                 (<a class="code" href="classGridAccel.html#d1">VoxelToPos</a>(Pos[axis]+1, axis) - gridIntersect[axis]) /
00341                                         ray.d[axis];
00342                         DeltaT[axis] = <a class="code" href="classGridAccel.html#r5">Width</a>[axis] / ray.d[axis];
00343                         Step[axis] = 1;
00344                         Out[axis] = <a class="code" href="classGridAccel.html#r3">NVoxels</a>[axis];
00345                 }
00346                 <span class="keywordflow">else</span> {
00347                         <span class="comment">// Handle ray with negative direction for voxel stepping</span>
00348                         NextCrossingT[axis] = rayT +
00349                                 (<a class="code" href="classGridAccel.html#d1">VoxelToPos</a>(Pos[axis], axis) - gridIntersect[axis]) /
00350                                         ray.d[axis];
00351                         DeltaT[axis] = -<a class="code" href="classGridAccel.html#r5">Width</a>[axis] / ray.d[axis];
00352                         Step[axis] = -1;
00353                         Out[axis] = -1;
00354                 }
00355         }
00356         <span class="comment">// Walk grid for shadow ray</span>
00357         <span class="keywordflow">for</span> (;;) {
00358                 <span class="keywordtype">int</span> offset = <a class="code" href="classGridAccel.html#d3">Offset</a>(Pos[0], Pos[1], Pos[2]);
00359                 <a class="code" href="structVoxel.html">Voxel</a> *voxel = <a class="code" href="classGridAccel.html#r7">voxels</a>[offset];
00360                 <span class="keywordflow">if</span> (voxel &amp;&amp; voxel-&gt;<a class="code" href="structVoxel.html#a4">IntersectP</a>(ray, rayId))
00361                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00362                 <span class="comment">// Advance to next voxel</span>
00363                 <span class="comment">// Find _stepAxis_ for stepping to next voxel</span>
00364                 <span class="keywordtype">int</span> bits = ((NextCrossingT[0] &lt; NextCrossingT[1]) &lt;&lt; 2) +
00365                         ((NextCrossingT[0] &lt; NextCrossingT[2]) &lt;&lt; 1) +
00366                         ((NextCrossingT[1] &lt; NextCrossingT[2]));
00367                 <span class="keyword">const</span> <span class="keywordtype">int</span> cmpToAxis[8] = { 2, 1, 2, 1, 2, 2, 0, 0 };
00368                 <span class="keywordtype">int</span> stepAxis = cmpToAxis[bits];
00369                 <span class="keywordflow">if</span> (ray.maxt &lt; NextCrossingT[stepAxis])
00370                         <span class="keywordflow">break</span>;
00371                 Pos[stepAxis] += Step[stepAxis];
00372                 <span class="keywordflow">if</span> (Pos[stepAxis] == Out[stepAxis])
00373                         <span class="keywordflow">break</span>;
00374                 NextCrossingT[stepAxis] += DeltaT[stepAxis];
00375         }
00376         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00377 }
<a name="l00378"></a><a class="code" href="structVoxel.html#a4">00378</a> <span class="keywordtype">bool</span> <a class="code" href="structVoxel.html#a4">Voxel::IntersectP</a>(<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a> &amp;ray, <span class="keywordtype">int</span> rayId) {
00379         <span class="comment">// Refine primitives in voxel if needed</span>
00380         <span class="keywordflow">if</span> (!<a class="code" href="structVoxel.html#o2">allCanIntersect</a>) {
00381                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **mpp;
00382                 <span class="keywordflow">if</span> (<a class="code" href="structVoxel.html#o3">nPrimitives</a> == 1) mpp = &amp;<a class="code" href="structVoxel.html#o0">onePrimitive</a>;
00383                 <span class="keywordflow">else</span> mpp = <a class="code" href="structVoxel.html#o1">primitives</a>;
00384                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="structVoxel.html#o3">nPrimitives</a>; ++i) {
00385                         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *mp = mpp[i];
00386                         <span class="comment">// Refine primitive in _mp_ if it's not intersectable</span>
00387                         <span class="keywordflow">if</span> (!mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;CanIntersect()) {
00388                                 vector&lt;Reference&lt;Primitive&gt; &gt; p;
00389                                 mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;FullyRefine(p);
00390                                 <a class="code" href="pbrt_8h.html#a14">Assert</a>(p.size() &gt; 0); <span class="comment">// NOBOOK</span>
00391                                 <span class="keywordflow">if</span> (p.size() == 1)
00392                                         mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a> = p[0];
00393                                 <span class="keywordflow">else</span>
00394                                         mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a> = <span class="keyword">new</span> <a class="code" href="classGridAccel.html">GridAccel</a>(p, <span class="keyword">true</span>, <span class="keyword">false</span>);
00395                         }
00396                 }
00397                 <a class="code" href="structVoxel.html#o2">allCanIntersect</a> = <span class="keyword">true</span>;
00398         }
00399         <a class="code" href="structMailboxPrim.html">MailboxPrim</a> **mpp;
00400         <span class="keywordflow">if</span> (<a class="code" href="structVoxel.html#o3">nPrimitives</a> == 1) mpp = &amp;<a class="code" href="structVoxel.html#o0">onePrimitive</a>;
00401         <span class="keywordflow">else</span> mpp = <a class="code" href="structVoxel.html#o1">primitives</a>;
00402         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="structVoxel.html#o3">nPrimitives</a>; ++i) {
00403                 <a class="code" href="structMailboxPrim.html">MailboxPrim</a> *mp = mpp[i];
00404                 <span class="comment">// Do mailbox check between ray and primitive</span>
00405                 <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> == rayId)
00406                         <span class="keywordflow">continue</span>;
00407                 <span class="comment">// Check for ray--primitive intersection for shadow ray</span>
00408                 mp-&gt;<a class="code" href="structMailboxPrim.html#o1">lastMailboxId</a> = rayId;
00409                 <a class="code" href="grid_8cpp.html#a0">rayTests</a>.<a class="code" href="classStatsRatio.html#a1">Add</a>(1, 0);
00410                 <span class="keywordflow">if</span> (mp-&gt;<a class="code" href="structMailboxPrim.html#o0">primitive</a>-&gt;IntersectP(ray)) {
00411                         <a class="code" href="grid_8cpp.html#a1">rayHits</a>.<a class="code" href="classStatsRatio.html#a1">Add</a>(1, 0);
00412                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00413                 }
00414         }
00415         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00416 }
<a name="l00417"></a><a class="code" href="grid_8cpp.html#a2">00417</a> <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <a class="code" href="pbrt_8h.html#a2">DLLEXPORT</a> <a class="code" href="classPrimitive.html">Primitive</a> *<a class="code" href="kdtree_8cpp.html#a2">CreateAccelerator</a>(<span class="keyword">const</span> vector&lt;<a class="code" href="classReference.html">Reference&lt;Primitive&gt;</a> &gt; &amp;prims,
00418                 <span class="keyword">const</span> <a class="code" href="classParamSet.html">ParamSet</a> &amp;ps) {
00419         <span class="keywordtype">bool</span> refineImmediately = ps.<a class="code" href="classParamSet.html#a23">FindOneBool</a>(<span class="stringliteral">"refineimmediately"</span>, <span class="keyword">false</span>);
00420         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classGridAccel.html">GridAccel</a>(prims, <span class="keyword">false</span>, refineImmediately);
00421 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Mon Apr 25 19:00:21 2005 for pbrt by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
