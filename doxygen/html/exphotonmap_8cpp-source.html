<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pbrt: exphotonmap.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>exphotonmap.cpp</h1><a href="exphotonmap_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> * pbrt source code Copyright(c) 1998-2005 Matt Pharr and Greg Humphreys</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * All Rights Reserved.</span>
00006 <span class="comment"> * For educational use only; commercial use expressly forbidden.</span>
00007 <span class="comment"> * NO WARRANTY, express or implied, for this software.</span>
00008 <span class="comment"> * (See file License.txt for complete license)</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">// exphotonmap.cpp*</span>
00012 <span class="preprocessor">#include "<a class="code" href="pbrt_8h.html">pbrt.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="transport_8h.html">transport.h</a>"</span>
00014 <span class="preprocessor">#include "<a class="code" href="scene_8h.html">scene.h</a>"</span>
00015 <span class="preprocessor">#include "<a class="code" href="mc_8h.html">mc.h</a>"</span>
00016 <span class="preprocessor">#include "<a class="code" href="kdtree_8h.html">kdtree.h</a>"</span>
00017 <span class="preprocessor">#include "<a class="code" href="sampling_8h.html">sampling.h</a>"</span>
00018 
00019 <span class="keyword">struct </span><a class="code" href="structClosePhoton.html">ClosePhoton</a>;
00020 
00021 <span class="comment">// Local Declarations</span>
<a name="l00022"></a><a class="code" href="structPhoton.html">00022</a> <span class="keyword">struct </span><a class="code" href="structPhoton.html">Photon</a> {
<a name="l00023"></a><a class="code" href="structPhoton.html#a0">00023</a>         <a class="code" href="structPhoton.html#a1">Photon</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;pp, <span class="keyword">const</span> <a class="code" href="classSpectrum.html">Spectrum</a> &amp;wt, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;w)
00024                 : <a class="code" href="structPhoton.html#o0">p</a>(pp), <a class="code" href="structPhoton.html#o1">alpha</a>(wt), <a class="code" href="structPhoton.html#o2">wi</a>(w) {
00025         }
<a name="l00026"></a><a class="code" href="structPhoton.html#a1">00026</a>         <a class="code" href="structPhoton.html#a1">Photon</a>() { } <span class="comment">// NOBOOK</span>
00027         <a class="code" href="classPoint.html">Point</a> p;
00028         <a class="code" href="classSpectrum.html">Spectrum</a> alpha;
00029         <a class="code" href="classVector.html">Vector</a> wi;
00030 };
<a name="l00031"></a><a class="code" href="structRadiancePhoton.html">00031</a> <span class="keyword">struct </span><a class="code" href="structRadiancePhoton.html">RadiancePhoton</a> {
<a name="l00032"></a><a class="code" href="structRadiancePhoton.html#a0">00032</a>         <a class="code" href="structRadiancePhoton.html#a1">RadiancePhoton</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;pp, <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;nn)
00033                 : <a class="code" href="structRadiancePhoton.html#o0">p</a>(pp), <a class="code" href="structRadiancePhoton.html#o1">n</a>(nn), <a class="code" href="structRadiancePhoton.html#o2">Lo</a>(0.f) {
00034         }
<a name="l00035"></a><a class="code" href="structRadiancePhoton.html#a1">00035</a>         <a class="code" href="structRadiancePhoton.html#a1">RadiancePhoton</a>() { } <span class="comment">// NOBOOK</span>
<a name="l00036"></a><a class="code" href="structRadiancePhoton.html#o0">00036</a>         <a class="code" href="classPoint.html">Point</a> <a class="code" href="structRadiancePhoton.html#o0">p</a>;
<a name="l00037"></a><a class="code" href="structRadiancePhoton.html#o1">00037</a>         <a class="code" href="classNormal.html">Normal</a> <a class="code" href="structRadiancePhoton.html#o1">n</a>;
<a name="l00038"></a><a class="code" href="structRadiancePhoton.html#o2">00038</a>         <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="structRadiancePhoton.html#o2">Lo</a>;
00039 };
<a name="l00040"></a><a class="code" href="structRadiancePhotonProcess.html">00040</a> <span class="keyword">struct </span><a class="code" href="structRadiancePhotonProcess.html">RadiancePhotonProcess</a> {
00041         <span class="comment">// RadiancePhotonProcess Methods</span>
<a name="l00042"></a><a class="code" href="structRadiancePhotonProcess.html#a0">00042</a>         <a class="code" href="structRadiancePhotonProcess.html">RadiancePhotonProcess</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;pp, <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;nn)
00043                 : <a class="code" href="structRadiancePhotonProcess.html#o0">p</a>(pp), <a class="code" href="structRadiancePhotonProcess.html#o1">n</a>(nn) {
00044                 <a class="code" href="structRadiancePhotonProcess.html#o2">photon</a> = NULL;
00045         }
<a name="l00046"></a><a class="code" href="structRadiancePhotonProcess.html#a1">00046</a>         <span class="keywordtype">void</span> <a class="code" href="structRadiancePhotonProcess.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="structRadiancePhoton.html">RadiancePhoton</a> &amp;rp,
00047                         <span class="keywordtype">float</span> distSquared, <span class="keywordtype">float</span> &amp;maxDistSquared)<span class="keyword"> const </span>{
00048                 <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(rp.<a class="code" href="structRadiancePhoton.html#o1">n</a>, <a class="code" href="structRadiancePhotonProcess.html#o1">n</a>) &gt; 0) {
00049                         <a class="code" href="structRadiancePhotonProcess.html#o2">photon</a> = &amp;rp;
00050                         maxDistSquared = distSquared;
00051                 }
00052         }
<a name="l00053"></a><a class="code" href="structRadiancePhotonProcess.html#o0">00053</a>         <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;<a class="code" href="structRadiancePhotonProcess.html#o0">p</a>;
<a name="l00054"></a><a class="code" href="structRadiancePhotonProcess.html#o1">00054</a>         <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;<a class="code" href="structRadiancePhotonProcess.html#o1">n</a>;
<a name="l00055"></a><a class="code" href="structRadiancePhotonProcess.html#o2">00055</a>         <span class="keyword">mutable</span> <span class="keyword">const</span> <a class="code" href="structRadiancePhoton.html">RadiancePhoton</a> *<a class="code" href="structRadiancePhotonProcess.html#o2">photon</a>;
00056 };
<a name="l00057"></a><a class="code" href="exphotonmap_8cpp.html#a0">00057</a> <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="exphotonmap_8cpp.html#a0">kernel</a>(<span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> *photon, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p,
00058                 <span class="keywordtype">float</span> md2) {
00059 <span class="comment">//      return 1.f / (md2 * M_PI); // NOBOOK</span>
00060         <span class="keywordtype">float</span> s = (1.f - <a class="code" href="geometry_8h.html#a10">DistanceSquared</a>(photon-&gt;<a class="code" href="structPhoton.html#o0">p</a>, p) / md2);
00061         <span class="keywordflow">return</span> 3.f / (md2 * <a class="code" href="pbrt_8h.html#a6">M_PI</a>) * s * s;
00062 }
00063 
<a name="l00064"></a><a class="code" href="structPhotonProcess.html">00064</a> <span class="keyword">struct </span><a class="code" href="structPhotonProcess.html">PhotonProcess</a> {
00065         <span class="comment">// PhotonProcess Public Methods</span>
00066         <a class="code" href="structPhotonProcess.html">PhotonProcess</a>(<a class="code" href="pbrt_8h.html#a51">u_int</a> mp, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;<a class="code" href="structPhotonProcess.html#o0">p</a>);
00067         <span class="keywordtype">void</span> <a class="code" href="structPhotonProcess.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> &amp;photon, <span class="keywordtype">float</span> dist2, <span class="keywordtype">float</span> &amp;maxDistSquared) <span class="keyword">const</span>;
<a name="l00068"></a><a class="code" href="structPhotonProcess.html#o0">00068</a>         <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p;
<a name="l00069"></a><a class="code" href="structPhotonProcess.html#o1">00069</a>         <a class="code" href="structClosePhoton.html">ClosePhoton</a> *<a class="code" href="structPhotonProcess.html#o1">photons</a>;
00070         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structPhotonProcess.html#o2">nLookup</a>;
00071         <span class="keyword">mutable</span> <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structPhotonProcess.html#o3">foundPhotons</a>;
00072 };
<a name="l00073"></a><a class="code" href="structClosePhoton.html">00073</a> <span class="keyword">struct </span><a class="code" href="structClosePhoton.html">ClosePhoton</a> {
<a name="l00074"></a><a class="code" href="structClosePhoton.html#a0">00074</a>         <a class="code" href="structClosePhoton.html">ClosePhoton</a>(<span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> *p = NULL,
00075                     <span class="keywordtype">float</span> md2 = INFINITY) {
00076                 <a class="code" href="structClosePhoton.html#o0">photon</a> = p;
00077                 <a class="code" href="structClosePhoton.html#o1">distanceSquared</a> = md2;
00078         }
<a name="l00079"></a><a class="code" href="structClosePhoton.html#a1">00079</a>         <span class="keywordtype">bool</span> <a class="code" href="structClosePhoton.html#a1">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="structClosePhoton.html">ClosePhoton</a> &amp;p2)<span class="keyword"> const </span>{
00080                 <span class="keywordflow">return</span> <a class="code" href="structClosePhoton.html#o1">distanceSquared</a> == p2.<a class="code" href="structClosePhoton.html#o1">distanceSquared</a> ? (<a class="code" href="structClosePhoton.html#o0">photon</a> &lt; p2.<a class="code" href="structClosePhoton.html#o0">photon</a>) :
00081                         <a class="code" href="structClosePhoton.html#o1">distanceSquared</a> &lt; p2.<a class="code" href="structClosePhoton.html#o1">distanceSquared</a>;
00082         }
<a name="l00083"></a><a class="code" href="structClosePhoton.html#o0">00083</a>         <span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> *<a class="code" href="structClosePhoton.html#o0">photon</a>;
00084         <span class="keywordtype">float</span> <a class="code" href="structClosePhoton.html#o1">distanceSquared</a>;
00085 };
00086 
<a name="l00087"></a><a class="code" href="structPhotonProcess.html#a0">00087</a> <a class="code" href="structPhotonProcess.html#a0">PhotonProcess::PhotonProcess</a>(u_int mp, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;P)
00088         : p(P) {
00089         <a class="code" href="structPhotonProcess.html#o1">photons</a> = 0;
00090         <a class="code" href="structPhotonProcess.html#o2">nLookup</a> = mp;
00091         <a class="code" href="structPhotonProcess.html#o3">foundPhotons</a> = 0;
00092 }
00093 
<a name="l00094"></a><a class="code" href="classExPhotonIntegrator.html">00094</a> <span class="keyword">class </span><a class="code" href="classExPhotonIntegrator.html">ExPhotonIntegrator</a> : <span class="keyword">public</span> <a class="code" href="classSurfaceIntegrator.html">SurfaceIntegrator</a> {
00095 <span class="keyword">public</span>:
00096         <span class="comment">// ExPhotonIntegrator Public Methods</span>
00097         <a class="code" href="classExPhotonIntegrator.html">ExPhotonIntegrator</a>(<span class="keywordtype">int</span> ncaus, <span class="keywordtype">int</span> nindir, <span class="keywordtype">int</span> <a class="code" href="classExPhotonIntegrator.html#r4">nLookup</a>, <span class="keywordtype">int</span> mdepth,
00098                          <span class="keywordtype">float</span> maxdist, <span class="keywordtype">bool</span> <a class="code" href="classExPhotonIntegrator.html#r9">finalGather</a>, <span class="keywordtype">int</span> <a class="code" href="classExPhotonIntegrator.html#r11">gatherSamples</a>,
00099                          <span class="keywordtype">float</span> rrt, <span class="keywordtype">float</span> ga);
00100         <a class="code" href="classExPhotonIntegrator.html#a1">~ExPhotonIntegrator</a>();
00101         <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="classExPhotonIntegrator.html#a2">Li</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene, <span class="keyword">const</span> <a class="code" href="classRayDifferential.html">RayDifferential</a> &amp;ray,
00102                 <span class="keyword">const</span> <a class="code" href="structSample.html">Sample</a> *sample, <span class="keywordtype">float</span> *alpha) <span class="keyword">const</span>;
00103         <span class="keywordtype">void</span> <a class="code" href="classExPhotonIntegrator.html#a3">RequestSamples</a>(<a class="code" href="structSample.html">Sample</a> *sample, <span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene);
00104         <span class="keywordtype">void</span> <a class="code" href="classExPhotonIntegrator.html#a4">Preprocess</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *);
00105 <span class="keyword">private</span>:
<a name="l00106"></a><a class="code" href="classExPhotonIntegrator.html#h0">00106</a>         <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classExPhotonIntegrator.html#h0">unsuccessful</a>(<span class="keywordtype">int</span> needed, <span class="keywordtype">int</span> found, <span class="keywordtype">int</span> shot) {
00107                 <span class="keywordflow">return</span> (found &lt; needed &amp;&amp;
00108                         (found == 0 || found &lt; shot / 1024));
00109         }
00110         <span class="keyword">static</span> <a class="code" href="classSpectrum.html">Spectrum</a> LPhoton(<a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *map,
00111                 <span class="keywordtype">int</span> nPaths, <span class="keywordtype">int</span> nLookup, <a class="code" href="classBSDF.html">BSDF</a> *bsdf, <span class="keyword">const</span> <a class="code" href="structIntersection.html">Intersection</a> &amp;isect,
00112                 <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;w, <span class="keywordtype">float</span> maxDistSquared);
00113 
00114         <a class="code" href="classSpectrum.html">Spectrum</a> estimateE(<a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *map, <span class="keywordtype">int</span> count,
00115                 <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p, <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;n) <span class="keyword">const</span>;
00116 
00117         <span class="comment">// ExPhotonIntegrator Private Data</span>
<a name="l00118"></a><a class="code" href="classExPhotonIntegrator.html#r0">00118</a>         <span class="keywordtype">int</span> <a class="code" href="classExPhotonIntegrator.html#r0">gatherSampleOffset</a>[2], <a class="code" href="classExPhotonIntegrator.html#r1">gatherComponentOffset</a>[2];
<a name="l00119"></a><a class="code" href="classExPhotonIntegrator.html#r3">00119</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="classExPhotonIntegrator.html#r2">nCausticPhotons</a>, <a class="code" href="classExPhotonIntegrator.html#r3">nIndirectPhotons</a>;
<a name="l00120"></a><a class="code" href="classExPhotonIntegrator.html#r4">00120</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> nLookup;
<a name="l00121"></a><a class="code" href="classExPhotonIntegrator.html#r5">00121</a>         <span class="keyword">mutable</span> <span class="keywordtype">int</span> <a class="code" href="classExPhotonIntegrator.html#r5">specularDepth</a>;
<a name="l00122"></a><a class="code" href="classExPhotonIntegrator.html#r6">00122</a>         <span class="keywordtype">int</span> <a class="code" href="classExPhotonIntegrator.html#r6">maxSpecularDepth</a>;
<a name="l00123"></a><a class="code" href="classExPhotonIntegrator.html#r8">00123</a>         <span class="keywordtype">float</span> <a class="code" href="classExPhotonIntegrator.html#r7">maxDistSquared</a>, <a class="code" href="classExPhotonIntegrator.html#r8">rrTreshold</a>;
<a name="l00124"></a><a class="code" href="classExPhotonIntegrator.html#r9">00124</a>         <span class="keywordtype">bool</span> finalGather;
<a name="l00125"></a><a class="code" href="classExPhotonIntegrator.html#r10">00125</a>         <span class="keywordtype">float</span> <a class="code" href="classExPhotonIntegrator.html#r10">cosGatherAngle</a>;
<a name="l00126"></a><a class="code" href="classExPhotonIntegrator.html#r11">00126</a>         <span class="keywordtype">int</span> gatherSamples;
00127         <span class="comment">// Declare sample parameters for light source sampling</span>
<a name="l00128"></a><a class="code" href="classExPhotonIntegrator.html#r12">00128</a>         <span class="keywordtype">int</span> *<a class="code" href="classExPhotonIntegrator.html#r12">lightSampleOffset</a>, <a class="code" href="classExPhotonIntegrator.html#r13">lightNumOffset</a>;
<a name="l00129"></a><a class="code" href="classExPhotonIntegrator.html#r14">00129</a>         <span class="keywordtype">int</span> *<a class="code" href="classExPhotonIntegrator.html#r14">bsdfSampleOffset</a>, *<a class="code" href="classExPhotonIntegrator.html#r15">bsdfComponentOffset</a>;
<a name="l00130"></a><a class="code" href="classExPhotonIntegrator.html#r17">00130</a>         <span class="keywordtype">int</span> <a class="code" href="classExPhotonIntegrator.html#r16">nCausticPaths</a>, <a class="code" href="classExPhotonIntegrator.html#r17">nIndirectPaths</a>;
<a name="l00131"></a><a class="code" href="classExPhotonIntegrator.html#r18">00131</a>         <span class="keyword">mutable</span> <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *<a class="code" href="classExPhotonIntegrator.html#r18">causticMap</a>;
<a name="l00132"></a><a class="code" href="classExPhotonIntegrator.html#r19">00132</a>         <span class="keyword">mutable</span> <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *<a class="code" href="classExPhotonIntegrator.html#r19">indirectMap</a>;
<a name="l00133"></a><a class="code" href="classExPhotonIntegrator.html#r20">00133</a>         <span class="keyword">mutable</span> <a class="code" href="classKdTree.html">KdTree&lt;RadiancePhoton, RadiancePhotonProcess&gt;</a> *<a class="code" href="classExPhotonIntegrator.html#r20">radianceMap</a>;
00134 };
00135 
00136 <span class="comment">// ExPhotonIntegrator Method Definitions</span>
<a name="l00137"></a><a class="code" href="classExPhotonIntegrator.html#d0">00137</a> <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="classExPhotonIntegrator.html#d0">ExPhotonIntegrator::estimateE</a>(
00138         <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *map, <span class="keywordtype">int</span> count,
00139         <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p, <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;n)<span class="keyword"> const </span>{
00140         <span class="keywordflow">if</span> (!map) <span class="keywordflow">return</span> 0.f;
00141         <span class="comment">// Lookup nearby photons at irradiance computation point</span>
00142         <a class="code" href="structPhotonProcess.html">PhotonProcess</a> proc(<a class="code" href="classExPhotonIntegrator.html#r4">nLookup</a>, p);
00143         proc.<a class="code" href="structPhotonProcess.html#o1">photons</a> = (<a class="code" href="structClosePhoton.html">ClosePhoton</a> *)alloca(<a class="code" href="classExPhotonIntegrator.html#r4">nLookup</a> *
00144                 <span class="keyword">sizeof</span>(<a class="code" href="structClosePhoton.html">ClosePhoton</a>));
00145         <span class="keywordtype">float</span> md2 = <a class="code" href="classExPhotonIntegrator.html#r7">maxDistSquared</a>;
00146         map-&gt;<a class="code" href="classKdTree.html#a3">Lookup</a>(p, proc, md2);
00147         <span class="comment">// Accumulate irradiance value from nearby photons</span>
00148         ClosePhoton *photons = proc.<a class="code" href="structPhotonProcess.html#o1">photons</a>;
00149         <a class="code" href="classSpectrum.html">Spectrum</a> E(0.);
00150         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; proc.<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a>; ++i)
00151                 <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(n, photons[i].photon-&gt;wi) &gt; 0.)
00152                         E += photons[i].<a class="code" href="structClosePhoton.html#o0">photon</a>-&gt;<a class="code" href="structPhoton.html#o1">alpha</a>;
00153         <span class="keywordflow">return</span> E / (float(count) * md2 * <a class="code" href="pbrt_8h.html#a6">M_PI</a>);
00154 }
<a name="l00155"></a><a class="code" href="structPhotonProcess.html#a1">00155</a> <span class="keywordtype">void</span> <a class="code" href="structPhotonProcess.html#a1">PhotonProcess::operator()</a>(<span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> &amp;photon,
00156                 <span class="keywordtype">float</span> distSquared, <span class="keywordtype">float</span> &amp;maxDistSquared)<span class="keyword"> const </span>{
00157         <span class="comment">// Do usual photon heap management</span>
00158         <span class="keyword">static</span> <a class="code" href="classStatsPercentage.html">StatsPercentage</a> discarded(<span class="stringliteral">"Photon Map"</span>, <span class="stringliteral">"Discarded photons"</span>); <span class="comment">// NOBOOK</span>
00159         discarded.<a class="code" href="classStatsPercentage.html#a0">Add</a>(0, 1); <span class="comment">// NOBOOK</span>
00160         <span class="keywordflow">if</span> (<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a> &lt; <a class="code" href="structPhotonProcess.html#o2">nLookup</a>) {
00161                 <span class="comment">// Add photon to unordered array of photons</span>
00162                 <a class="code" href="structPhotonProcess.html#o1">photons</a>[<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a>++] = <a class="code" href="structClosePhoton.html">ClosePhoton</a>(&amp;photon, distSquared);
00163                 <span class="keywordflow">if</span> (<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a> == <a class="code" href="structPhotonProcess.html#o2">nLookup</a>) {
00164                         std::make_heap(&amp;<a class="code" href="structPhotonProcess.html#o1">photons</a>[0], &amp;<a class="code" href="structPhotonProcess.html#o1">photons</a>[<a class="code" href="structPhotonProcess.html#o2">nLookup</a>]);
00165                         maxDistSquared = <a class="code" href="structPhotonProcess.html#o1">photons</a>[0].<a class="code" href="structClosePhoton.html#o1">distanceSquared</a>;
00166                 }
00167         }
00168         <span class="keywordflow">else</span> {
00169                 <span class="comment">// Remove most distant photon from heap and add new photon</span>
00170                 discarded.<a class="code" href="classStatsPercentage.html#a0">Add</a>(1, 0); <span class="comment">// NOBOOK</span>
00171                 std::pop_heap(&amp;<a class="code" href="structPhotonProcess.html#o1">photons</a>[0], &amp;<a class="code" href="structPhotonProcess.html#o1">photons</a>[<a class="code" href="structPhotonProcess.html#o2">nLookup</a>]);
00172                 <a class="code" href="structPhotonProcess.html#o1">photons</a>[nLookup-1] = <a class="code" href="structClosePhoton.html">ClosePhoton</a>(&amp;photon, distSquared);
00173                 std::push_heap(&amp;<a class="code" href="structPhotonProcess.html#o1">photons</a>[0], &amp;<a class="code" href="structPhotonProcess.html#o1">photons</a>[nLookup]);
00174                 maxDistSquared = <a class="code" href="structPhotonProcess.html#o1">photons</a>[0].<a class="code" href="structClosePhoton.html#o1">distanceSquared</a>;
00175         }
00176 }
<a name="l00177"></a><a class="code" href="classExPhotonIntegrator.html#h1">00177</a> <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="classExPhotonIntegrator.html#h1">ExPhotonIntegrator::LPhoton</a>(
00178                 <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *map,
00179                 <span class="keywordtype">int</span> nPaths, <span class="keywordtype">int</span> nLookup, <a class="code" href="classBSDF.html">BSDF</a> *bsdf,
00180                 <span class="keyword">const</span> <a class="code" href="structIntersection.html">Intersection</a> &amp;isect, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;wo,
00181                 <span class="keywordtype">float</span> maxDistSquared) {
00182         <a class="code" href="classSpectrum.html">Spectrum</a> L(0.);
00183         <span class="keywordflow">if</span> (!map) <span class="keywordflow">return</span> L;
00184         <a class="code" href="reflection_8h.html#a17">BxDFType</a> nonSpecular = <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a2">BSDF_REFLECTION</a> |
00185                 <a class="code" href="reflection_8h.html#a17a3">BSDF_TRANSMISSION</a> | <a class="code" href="reflection_8h.html#a17a4">BSDF_DIFFUSE</a> | <a class="code" href="reflection_8h.html#a17a5">BSDF_GLOSSY</a>);
00186         <span class="keywordflow">if</span> (bsdf-&gt;<a class="code" href="classBSDF.html#a5">NumComponents</a>(nonSpecular) == 0)
00187                 <span class="keywordflow">return</span> L;
00188         <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> lookups(<span class="stringliteral">"Photon Map"</span>, <span class="stringliteral">"Total lookups"</span>); <span class="comment">// NOBOOK</span>
00189         <span class="comment">// Initialize _PhotonProcess_ object, _proc_, for photon map lookups</span>
00190         <a class="code" href="structPhotonProcess.html">PhotonProcess</a> proc(nLookup, isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>);
00191         proc.<a class="code" href="structPhotonProcess.html#o1">photons</a> =
00192                 (<a class="code" href="structClosePhoton.html">ClosePhoton</a> *)alloca(nLookup * <span class="keyword">sizeof</span>(<a class="code" href="structClosePhoton.html">ClosePhoton</a>));
00193         <span class="comment">// Do photon map lookup</span>
00194         ++lookups;  <span class="comment">// NOBOOK</span>
00195         map-&gt;<a class="code" href="classKdTree.html#a3">Lookup</a>(isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, proc, maxDistSquared);
00196         <span class="comment">// Accumulate light from nearby photons</span>
00197         <span class="keyword">static</span> <a class="code" href="classStatsRatio.html">StatsRatio</a> foundRate(<span class="stringliteral">"Photon Map"</span>, <span class="stringliteral">"Photons found per lookup"</span>); <span class="comment">// NOBOOK</span>
00198         foundRate.<a class="code" href="classStatsRatio.html#a1">Add</a>(proc.<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a>, 1); <span class="comment">// NOBOOK</span>
00199         <span class="comment">// Estimate reflected light from photons</span>
00200         ClosePhoton *photons = proc.<a class="code" href="structPhotonProcess.html#o1">photons</a>;
00201         <span class="keywordtype">int</span> nFound = proc.<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a>;
00202         <a class="code" href="classNormal.html">Normal</a> Nf = <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>) &lt; 0 ? -bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a> :
00203                 bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>;
00204 
00205         <span class="keywordflow">if</span> (bsdf-&gt;<a class="code" href="classBSDF.html#a5">NumComponents</a>(<a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a2">BSDF_REFLECTION</a> |
00206                         <a class="code" href="reflection_8h.html#a17a3">BSDF_TRANSMISSION</a> | <a class="code" href="reflection_8h.html#a17a5">BSDF_GLOSSY</a>)) &gt; 0) {
00207                 <span class="comment">// Compute exitant radiance from photons for glossy surface</span>
00208                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nFound; ++i) {
00209                         <span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> *p = photons[i].<a class="code" href="structClosePhoton.html#o0">photon</a>;
00210                         <a class="code" href="reflection_8h.html#a17">BxDFType</a> flag = <a class="code" href="geometry_8h.html#a17">Dot</a>(Nf, p-&gt;<a class="code" href="structPhoton.html#o2">wi</a>) &gt; 0.f ?
00211                                 <a class="code" href="reflection_8h.html#a17a8">BSDF_ALL_REFLECTION</a> : <a class="code" href="reflection_8h.html#a17a9">BSDF_ALL_TRANSMISSION</a>;
00212                         <span class="keywordtype">float</span> k = <a class="code" href="exphotonmap_8cpp.html#a0">kernel</a>(p, isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, maxDistSquared);
00213                         L += (k / nPaths) * bsdf-&gt;<a class="code" href="classBSDF.html#a10">f</a>(wo, p-&gt;<a class="code" href="structPhoton.html#o2">wi</a>, flag) * p-&gt;<a class="code" href="structPhoton.html#o1">alpha</a>;
00214                 }
00215         }
00216         <span class="keywordflow">else</span> {
00217                 <span class="comment">// Compute exitant radiance from photons for diffuse surface</span>
00218                 <a class="code" href="classSpectrum.html">Spectrum</a> Lr(0.), Lt(0.);
00219                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nFound; ++i) {
00220                         <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(Nf, photons[i].photon-&gt;wi) &gt; 0.f) {
00221                                 <span class="keywordtype">float</span> k = <a class="code" href="exphotonmap_8cpp.html#a0">kernel</a>(photons[i].photon, isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>,
00222                                         maxDistSquared);
00223                                 Lr += (k / nPaths) * photons[i].<a class="code" href="structClosePhoton.html#o0">photon</a>-&gt;<a class="code" href="structPhoton.html#o1">alpha</a>;
00224                         }
00225                         <span class="keywordflow">else</span> {
00226                                 <span class="keywordtype">float</span> k = <a class="code" href="exphotonmap_8cpp.html#a0">kernel</a>(photons[i].photon, isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>,
00227                                         maxDistSquared);
00228                                 Lt += (k / nPaths) * photons[i].<a class="code" href="structClosePhoton.html#o0">photon</a>-&gt;<a class="code" href="structPhoton.html#o1">alpha</a>;
00229                         }
00230                 }
00231                 L += Lr * bsdf-&gt;<a class="code" href="classBSDF.html#a11">rho</a>(wo, <a class="code" href="reflection_8h.html#a17a8">BSDF_ALL_REFLECTION</a>) * <a class="code" href="pbrt_8h.html#a7">INV_PI</a> +
00232                         Lt * bsdf-&gt;<a class="code" href="classBSDF.html#a11">rho</a>(wo, <a class="code" href="reflection_8h.html#a17a9">BSDF_ALL_TRANSMISSION</a>) * <a class="code" href="pbrt_8h.html#a7">INV_PI</a>;
00233         }
00234         <span class="keywordflow">return</span> L;
00235 }
00236 
<a name="l00237"></a><a class="code" href="classExPhotonIntegrator.html#a0">00237</a> <a class="code" href="classExPhotonIntegrator.html#a0">ExPhotonIntegrator::ExPhotonIntegrator</a>(<span class="keywordtype">int</span> ncaus, <span class="keywordtype">int</span> nind,
00238                 <span class="keywordtype">int</span> nl, <span class="keywordtype">int</span> mdepth, <span class="keywordtype">float</span> mdist, <span class="keywordtype">bool</span> fg,
00239                 <span class="keywordtype">int</span> gs, <span class="keywordtype">float</span> rrt, <span class="keywordtype">float</span> ga) {
00240         <a class="code" href="classExPhotonIntegrator.html#r2">nCausticPhotons</a> = ncaus;
00241         <a class="code" href="classExPhotonIntegrator.html#r3">nIndirectPhotons</a> = nind;
00242         <a class="code" href="classExPhotonIntegrator.html#r4">nLookup</a> = nl;
00243         <a class="code" href="classExPhotonIntegrator.html#r7">maxDistSquared</a> = mdist * mdist;
00244         <a class="code" href="classExPhotonIntegrator.html#r6">maxSpecularDepth</a> = mdepth;
00245         <a class="code" href="classExPhotonIntegrator.html#r18">causticMap</a> = <a class="code" href="classExPhotonIntegrator.html#r19">indirectMap</a> = NULL;
00246         <a class="code" href="classExPhotonIntegrator.html#r20">radianceMap</a> = NULL;
00247         <a class="code" href="classExPhotonIntegrator.html#r5">specularDepth</a> = 0;
00248         <a class="code" href="classExPhotonIntegrator.html#r9">finalGather</a> = fg;
00249         <a class="code" href="classExPhotonIntegrator.html#r11">gatherSamples</a> = gs;
00250         <a class="code" href="classExPhotonIntegrator.html#r8">rrTreshold</a> = rrt;
00251         <a class="code" href="classExPhotonIntegrator.html#r10">cosGatherAngle</a> = cos(<a class="code" href="pbrt_8h.html#a98">Radians</a>(ga));
00252 }
<a name="l00253"></a><a class="code" href="classExPhotonIntegrator.html#a1">00253</a> <a class="code" href="classExPhotonIntegrator.html#a1">ExPhotonIntegrator::~ExPhotonIntegrator</a>() {
00254         <span class="keyword">delete</span> <a class="code" href="classExPhotonIntegrator.html#r18">causticMap</a>;
00255         <span class="keyword">delete</span> <a class="code" href="classExPhotonIntegrator.html#r19">indirectMap</a>;
00256         <span class="keyword">delete</span> <a class="code" href="classExPhotonIntegrator.html#r20">radianceMap</a>;
00257 }
<a name="l00258"></a><a class="code" href="classExPhotonIntegrator.html#a3">00258</a> <span class="keywordtype">void</span> <a class="code" href="classExPhotonIntegrator.html#a3">ExPhotonIntegrator::RequestSamples</a>(<a class="code" href="structSample.html">Sample</a> *sample,
00259                 <span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene) {
00260         <span class="comment">// Allocate and request samples for sampling all lights</span>
00261         <a class="code" href="pbrt_8h.html#a51">u_int</a> nLights = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size();
00262         <a class="code" href="classExPhotonIntegrator.html#r12">lightSampleOffset</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>[nLights];
00263         <a class="code" href="classExPhotonIntegrator.html#r14">bsdfSampleOffset</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>[nLights];
00264         <a class="code" href="classExPhotonIntegrator.html#r15">bsdfComponentOffset</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>[nLights];
00265         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; nLights; ++i) {
00266                 <span class="keyword">const</span> <a class="code" href="classLight.html">Light</a> *light = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[i];
00267                 <span class="keywordtype">int</span> lightSamples =
00268                         scene-&gt;<a class="code" href="classScene.html#o6">sampler</a>-&gt;<a class="code" href="classSampler.html#a4">RoundSize</a>(light-&gt;<a class="code" href="classLight.html#o0">nSamples</a>);
00269                 <a class="code" href="classExPhotonIntegrator.html#r12">lightSampleOffset</a>[i] = sample-&gt;<a class="code" href="structSample.html#a2">Add2D</a>(lightSamples);
00270                 <a class="code" href="classExPhotonIntegrator.html#r14">bsdfSampleOffset</a>[i] = sample-&gt;<a class="code" href="structSample.html#a2">Add2D</a>(lightSamples);
00271                 <a class="code" href="classExPhotonIntegrator.html#r15">bsdfComponentOffset</a>[i] = sample-&gt;<a class="code" href="structSample.html#a1">Add1D</a>(lightSamples);
00272         }
00273         <a class="code" href="classExPhotonIntegrator.html#r13">lightNumOffset</a> = -1;
00274         <span class="comment">// Request samples for final gathering</span>
00275         <span class="keywordflow">if</span> (<a class="code" href="classExPhotonIntegrator.html#r9">finalGather</a>) {
00276                 <a class="code" href="classExPhotonIntegrator.html#r11">gatherSamples</a> = scene-&gt;<a class="code" href="classScene.html#o6">sampler</a>-&gt;<a class="code" href="classSampler.html#a4">RoundSize</a>(max(1,
00277                         <a class="code" href="classExPhotonIntegrator.html#r11">gatherSamples</a>/2));
00278                 <a class="code" href="classExPhotonIntegrator.html#r0">gatherSampleOffset</a>[0] = sample-&gt;<a class="code" href="structSample.html#a2">Add2D</a>(<a class="code" href="classExPhotonIntegrator.html#r11">gatherSamples</a>);
00279                 <a class="code" href="classExPhotonIntegrator.html#r0">gatherSampleOffset</a>[1] = sample-&gt;<a class="code" href="structSample.html#a2">Add2D</a>(<a class="code" href="classExPhotonIntegrator.html#r11">gatherSamples</a>);
00280                 <a class="code" href="classExPhotonIntegrator.html#r1">gatherComponentOffset</a>[0] = sample-&gt;<a class="code" href="structSample.html#a1">Add1D</a>(<a class="code" href="classExPhotonIntegrator.html#r11">gatherSamples</a>);
00281                 <a class="code" href="classExPhotonIntegrator.html#r1">gatherComponentOffset</a>[1] = sample-&gt;<a class="code" href="structSample.html#a1">Add1D</a>(<a class="code" href="classExPhotonIntegrator.html#r11">gatherSamples</a>);
00282         }
00283 }
00284 
<a name="l00285"></a><a class="code" href="classExPhotonIntegrator.html#a4">00285</a> <span class="keywordtype">void</span> <a class="code" href="classExPhotonIntegrator.html#a4">ExPhotonIntegrator::Preprocess</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene) {
00286         <span class="keywordflow">if</span> (scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size() == 0) <span class="keywordflow">return</span>;
00287         <a class="code" href="structProgressReporter.html">ProgressReporter</a> progress(<a class="code" href="classExPhotonIntegrator.html#r2">nCausticPhotons</a>+ <span class="comment">// NOBOOK</span>
00288                 <a class="code" href="classExPhotonIntegrator.html#r3">nIndirectPhotons</a>, <span class="stringliteral">"Shooting photons"</span>); <span class="comment">// NOBOOK</span>
00289         vector&lt;Photon&gt; causticPhotons;
00290         vector&lt;Photon&gt; indirectPhotons;
00291         vector&lt;Photon&gt; directPhotons;
00292         vector&lt;RadiancePhoton&gt; radiancePhotons;
00293         causticPhotons.reserve(<a class="code" href="classExPhotonIntegrator.html#r2">nCausticPhotons</a>); <span class="comment">// NOBOOK</span>
00294         indirectPhotons.reserve(nIndirectPhotons); <span class="comment">// NOBOOK</span>
00295         <span class="comment">// Initialize photon shooting statistics</span>
00296         <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> nshot(<span class="stringliteral">"Photon Map"</span>,
00297                 <span class="stringliteral">"Number of photons shot from lights"</span>);
00298         <span class="keywordtype">bool</span> causticDone = (<a class="code" href="classExPhotonIntegrator.html#r2">nCausticPhotons</a> == 0);
00299         <span class="keywordtype">bool</span> indirectDone = (nIndirectPhotons == 0);
00300 
00301         <span class="comment">// Compute light power CDF for photon shooting</span>
00302         <span class="keywordtype">int</span> nLights = int(scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size());
00303         <span class="keywordtype">float</span> *lightPower = (<span class="keywordtype">float</span> *)alloca(nLights * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00304         <span class="keywordtype">float</span> *lightCDF = (<span class="keywordtype">float</span> *)alloca((nLights+1) * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00305         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nLights; ++i)
00306                 lightPower[i] = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[i]-&gt;Power(scene).y();
00307         <span class="keywordtype">float</span> totalPower;
00308         <a class="code" href="pbrt_8h.html#a89">ComputeStep1dCDF</a>(lightPower, nLights, &amp;totalPower, lightCDF);
00309         <span class="comment">// Declare radiance photon reflectance arrays</span>
00310         vector&lt;Spectrum&gt; rpReflectances, rpTransmittances;
00311 
00312         <span class="keywordflow">while</span> (!causticDone || !indirectDone) {
00313                 ++nshot;
00314                 <span class="comment">// Give up if we're not storing enough photons</span>
00315                 <span class="keywordflow">if</span> (nshot &gt; 500000 &amp;&amp;
00316                         (<a class="code" href="classExPhotonIntegrator.html#h0">unsuccessful</a>(nCausticPhotons,
00317                                       causticPhotons.size(),
00318                                                   nshot) ||
00319                          unsuccessful(nIndirectPhotons,
00320                                       indirectPhotons.size(),
00321                                                   nshot))) {
00322                         <a class="code" href="util_8cpp.html#a16">Error</a>(<span class="stringliteral">"Unable to store enough photons.  Giving up.\n"</span>);
00323                         <span class="keywordflow">return</span>;
00324                 }
00325                 <span class="comment">// Trace a photon path and store contribution</span>
00326                 <span class="comment">// Choose 4D sample values for photon</span>
00327                 <span class="keywordtype">float</span> u[4];
00328                 u[0] = <a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 2);
00329                 u[1] = <a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 3);
00330                 u[2] = <a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 5);
00331                 u[3] = <a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 7);
00332 
00333                 <span class="comment">// Choose light to shoot photon from</span>
00334                 <span class="keywordtype">float</span> lightPdf;
00335                 <span class="keywordtype">float</span> uln = <a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 11);
00336                 <span class="keywordtype">int</span> lightNum = <a class="code" href="pbrt_8h.html#a106">Floor2Int</a>(<a class="code" href="pbrt_8h.html#a90">SampleStep1d</a>(lightPower, lightCDF,
00337                                 totalPower, nLights, uln, &amp;lightPdf) * nLights);
00338                 lightNum = min(lightNum, nLights-1);
00339                 <span class="keyword">const</span> <a class="code" href="classLight.html">Light</a> *light = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[lightNum];
00340                 <span class="comment">// Generate _photonRay_ from light source and initialize _alpha_</span>
00341                 <a class="code" href="classRayDifferential.html">RayDifferential</a> photonRay;
00342                 <span class="keywordtype">float</span> pdf;
00343                 <a class="code" href="classSpectrum.html">Spectrum</a> alpha = light-&gt;<a class="code" href="classLight.html#a2">Sample_L</a>(scene, u[0], u[1], u[2], u[3],
00344                         &amp;photonRay, &amp;pdf);
00345                 <span class="keywordflow">if</span> (pdf == 0.f || alpha.<a class="code" href="classSpectrum.html#a15">Black</a>()) <span class="keywordflow">continue</span>;
00346                 alpha /= pdf * lightPdf;
00347 
00348                 <span class="keywordflow">if</span> (!alpha.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00349                         <span class="comment">// Follow photon path through scene and record intersections</span>
00350                         <span class="keywordtype">bool</span> specularPath = <span class="keyword">false</span>;
00351                         <a class="code" href="structIntersection.html">Intersection</a> photonIsect;
00352                         <span class="keywordtype">int</span> nIntersections = 0;
00353                         <span class="keywordflow">while</span> (scene-&gt;<a class="code" href="classScene.html#a3">Intersect</a>(photonRay, &amp;photonIsect)) {
00354                                 ++nIntersections;
00355                                 <span class="comment">// Handle photon/surface intersection</span>
00356                                 alpha *= scene-&gt;<a class="code" href="classScene.html#a7">Transmittance</a>(photonRay);
00357                                 <a class="code" href="classVector.html">Vector</a> wo = -photonRay.<a class="code" href="classRay.html#o1">d</a>;
00358                                 <a class="code" href="classBSDF.html">BSDF</a> *photonBSDF = photonIsect.<a class="code" href="structIntersection.html#a1">GetBSDF</a>(photonRay);
00359                                 <a class="code" href="reflection_8h.html#a17">BxDFType</a> specularType = <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a2">BSDF_REFLECTION</a> |
00360                                         <a class="code" href="reflection_8h.html#a17a3">BSDF_TRANSMISSION</a> | <a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>);
00361                                 <span class="keywordtype">bool</span> hasNonSpecular = (photonBSDF-&gt;<a class="code" href="classBSDF.html#a5">NumComponents</a>() &gt;
00362                                         photonBSDF-&gt;<a class="code" href="classBSDF.html#a5">NumComponents</a>(specularType));
00363                                 <span class="keywordflow">if</span> (hasNonSpecular) {
00364                                         <span class="comment">// Deposit photon at surface</span>
00365                                         <a class="code" href="structPhoton.html">Photon</a> photon(photonIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, alpha, wo);
00366                                         <span class="keywordflow">if</span> (nIntersections == 1) {
00367                                                 <span class="comment">// Deposit direct photon</span>
00368                                                 directPhotons.push_back(photon);
00369                                         }
00370                                         <span class="keywordflow">else</span> {
00371                                                 <span class="comment">// Deposit either caustic or indirect photon</span>
00372                                                 <span class="keywordflow">if</span> (specularPath) {
00373                                                         <span class="comment">// Process caustic photon intersection</span>
00374                                                         <span class="keywordflow">if</span> (!causticDone) {
00375                                                                 causticPhotons.push_back(photon);
00376                                                                 <span class="keywordflow">if</span> (causticPhotons.size() == nCausticPhotons) {
00377                                                                         causticDone = <span class="keyword">true</span>;
00378                                                                         <a class="code" href="classExPhotonIntegrator.html#r16">nCausticPaths</a> = (<span class="keywordtype">int</span>)nshot;
00379                                                                         <a class="code" href="classExPhotonIntegrator.html#r18">causticMap</a> = <span class="keyword">new</span> <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a>(causticPhotons);
00380                                                                 }
00381                                                                 progress.<a class="code" href="structProgressReporter.html#a2">Update</a>();
00382                                                         }
00383                                                 }
00384                                                 <span class="keywordflow">else</span> {
00385                                                         <span class="comment">// Process indirect lighting photon intersection</span>
00386                                                         <span class="keywordflow">if</span> (!indirectDone) {
00387                                                                 indirectPhotons.push_back(photon);
00388                                                                 <span class="keywordflow">if</span> (indirectPhotons.size() == nIndirectPhotons) {
00389                                                                         indirectDone = <span class="keyword">true</span>;
00390                                                                         <a class="code" href="classExPhotonIntegrator.html#r17">nIndirectPaths</a> = (<span class="keywordtype">int</span>)nshot;
00391                                                                         <a class="code" href="classExPhotonIntegrator.html#r19">indirectMap</a> = <span class="keyword">new</span> <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a>(indirectPhotons);
00392                                                                 }
00393                                                                 progress.<a class="code" href="structProgressReporter.html#a2">Update</a>();
00394                                                         }
00395                                                 }
00396                                         }
00397                                         <span class="keywordflow">if</span> (<a class="code" href="classExPhotonIntegrator.html#r9">finalGather</a> &amp;&amp; <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>() &lt; .125f) {
00398                                                 <span class="comment">// Store data for radiance photon</span>
00399                                                 <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> rp(<span class="stringliteral">"Photon Map"</span>, <span class="stringliteral">"Radiance photons created"</span>); <span class="comment">// NOBOOK</span>
00400                                                 ++rp; <span class="comment">// NOBOOK</span>
00401                                                 <a class="code" href="classNormal.html">Normal</a> n = photonIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>;
00402                                                 <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(n, photonRay.<a class="code" href="classRay.html#o1">d</a>) &gt; 0.f) n = -n;
00403                                                 radiancePhotons.push_back(<a class="code" href="structRadiancePhoton.html">RadiancePhoton</a>(photonIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, n));
00404                                                 <a class="code" href="classSpectrum.html">Spectrum</a> rho_r = photonBSDF-&gt;<a class="code" href="classBSDF.html#a11">rho</a>(<a class="code" href="reflection_8h.html#a17a8">BSDF_ALL_REFLECTION</a>);
00405                                                 rpReflectances.push_back(rho_r);
00406                                                 <a class="code" href="classSpectrum.html">Spectrum</a> rho_t = photonBSDF-&gt;<a class="code" href="classBSDF.html#a11">rho</a>(<a class="code" href="reflection_8h.html#a17a9">BSDF_ALL_TRANSMISSION</a>);
00407                                                 rpTransmittances.push_back(rho_t);
00408                                         }
00409                                 }
00410                                 <span class="comment">// Sample new photon ray direction</span>
00411                                 <a class="code" href="classVector.html">Vector</a> wi;
00412                                 <span class="keywordtype">float</span> pdf;
00413                                 <a class="code" href="reflection_8h.html#a17">BxDFType</a> flags;
00414                                 <span class="comment">// Get random numbers for sampling outgoing photon direction</span>
00415                                 <span class="keywordtype">float</span> u1, u2, u3;
00416                                 <span class="keywordflow">if</span> (nIntersections == 1) {
00417                                         u1 = <a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 13);
00418                                         u2 = <a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 17);
00419                                         u3 = <a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 19);
00420                                 }
00421                                 <span class="keywordflow">else</span> {
00422                                         u1 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00423                                         u2 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00424                                         u3 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00425                                 }
00426 
00427                                 <span class="comment">// Compute new photon weight and possibly terminate with RR</span>
00428                                 <a class="code" href="classSpectrum.html">Spectrum</a> fr = photonBSDF-&gt;<a class="code" href="classBSDF.html#a0">Sample_f</a>(wo, &amp;wi, u1, u2, u3,
00429                                                                    &amp;pdf, <a class="code" href="reflection_8h.html#a17a10">BSDF_ALL</a>, &amp;flags);
00430                                 <span class="keywordflow">if</span> (fr.<a class="code" href="classSpectrum.html#a15">Black</a>() || pdf == 0.f)
00431                                         <span class="keywordflow">break</span>;
00432                                 <a class="code" href="classSpectrum.html">Spectrum</a> anew = alpha * fr *
00433                                         <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, photonBSDF-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>) / pdf;
00434                                 <span class="keywordtype">float</span> continueProb = min(1.f, anew.<a class="code" href="classSpectrum.html#a23">y</a>() / alpha.<a class="code" href="classSpectrum.html#a23">y</a>());
00435                                 <span class="keywordflow">if</span> (<a class="code" href="pbrt_8h.html#a108">RandomFloat</a>() &gt; continueProb || nIntersections &gt; 10)
00436                                         <span class="keywordflow">break</span>;
00437                                 alpha = anew / continueProb;
00438                                 specularPath = (nIntersections == 1 || specularPath) &amp;&amp;
00439                                         ((flags &amp; <a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>) != 0);
00440                                 photonRay = <a class="code" href="classRayDifferential.html">RayDifferential</a>(photonIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, wi);
00441                         }
00442                 }
00443                 <a class="code" href="classBSDF.html#e1">BSDF::FreeAll</a>();
00444         }
00445 
00446         progress.<a class="code" href="structProgressReporter.html#a3">Done</a>(); <span class="comment">// NOBOOK</span>
00447 
00448         <span class="comment">// Precompute radiance at a subset of the photons</span>
00449         <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> directMap(directPhotons);
00450         <span class="keywordtype">int</span> nDirectPaths = nshot;
00451         <span class="keywordflow">if</span> (<a class="code" href="classExPhotonIntegrator.html#r9">finalGather</a>) {
00452                 <a class="code" href="structProgressReporter.html">ProgressReporter</a> p2(radiancePhotons.size(), <span class="stringliteral">"Computing photon radiances"</span>); <span class="comment">// NOBOOK</span>
00453                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; radiancePhotons.size(); ++i) {
00454                         <span class="comment">// Compute radiance for radiance photon _i_</span>
00455                         <a class="code" href="structRadiancePhoton.html">RadiancePhoton</a> &amp;rp = radiancePhotons[i];
00456                         <span class="keyword">const</span> <a class="code" href="classSpectrum.html">Spectrum</a> &amp;rho_r = rpReflectances[i];
00457                         <span class="keyword">const</span> <a class="code" href="classSpectrum.html">Spectrum</a> &amp;rho_t = rpTransmittances[i];
00458                         <a class="code" href="classSpectrum.html">Spectrum</a> E;
00459                         <a class="code" href="classPoint.html">Point</a> p = rp.<a class="code" href="structRadiancePhoton.html#o0">p</a>;
00460                         <a class="code" href="classNormal.html">Normal</a> n = rp.<a class="code" href="structRadiancePhoton.html#o1">n</a>;
00461                         <span class="keywordflow">if</span> (!rho_r.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00462                                 E = <a class="code" href="classExPhotonIntegrator.html#d0">estimateE</a>(&amp;directMap,  nDirectPaths,   p, n) +
00463                                         estimateE(<a class="code" href="classExPhotonIntegrator.html#r19">indirectMap</a>, <a class="code" href="classExPhotonIntegrator.html#r17">nIndirectPaths</a>, p, n) +
00464                                         estimateE(<a class="code" href="classExPhotonIntegrator.html#r18">causticMap</a>,  <a class="code" href="classExPhotonIntegrator.html#r16">nCausticPaths</a>,  p, n);
00465                                 rp.<a class="code" href="structRadiancePhoton.html#o2">Lo</a> += E * <a class="code" href="pbrt_8h.html#a7">INV_PI</a> * rho_r;
00466                         }
00467                         <span class="keywordflow">if</span> (!rho_t.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00468                                 E = <a class="code" href="classExPhotonIntegrator.html#d0">estimateE</a>(&amp;directMap,  nDirectPaths,   p, -n) +
00469                                         estimateE(<a class="code" href="classExPhotonIntegrator.html#r19">indirectMap</a>, <a class="code" href="classExPhotonIntegrator.html#r17">nIndirectPaths</a>, p, -n) +
00470                                         estimateE(<a class="code" href="classExPhotonIntegrator.html#r18">causticMap</a>,  <a class="code" href="classExPhotonIntegrator.html#r16">nCausticPaths</a>,  p, -n);
00471                                 rp.<a class="code" href="structRadiancePhoton.html#o2">Lo</a> += E * <a class="code" href="pbrt_8h.html#a7">INV_PI</a> * rho_t;
00472                         }
00473                         p2.<a class="code" href="structProgressReporter.html#a2">Update</a>(); <span class="comment">// NOBOOK</span>
00474                 }
00475                 <a class="code" href="classExPhotonIntegrator.html#r20">radianceMap</a> = <span class="keyword">new</span> <a class="code" href="classKdTree.html">KdTree</a>&lt;<a class="code" href="structRadiancePhoton.html">RadiancePhoton</a>,
00476                         <a class="code" href="structRadiancePhotonProcess.html">RadiancePhotonProcess</a>&gt;(radiancePhotons);
00477                 p2.<a class="code" href="structProgressReporter.html#a3">Done</a>(); <span class="comment">// NOBOOK</span>
00478         }
00479 }
00480 
<a name="l00481"></a><a class="code" href="classExPhotonIntegrator.html#a2">00481</a> <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="classExPhotonIntegrator.html#a2">ExPhotonIntegrator::Li</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene,
00482                 <span class="keyword">const</span> <a class="code" href="classRayDifferential.html">RayDifferential</a> &amp;ray, <span class="keyword">const</span> <a class="code" href="structSample.html">Sample</a> *sample,
00483                 <span class="keywordtype">float</span> *alpha)<span class="keyword"> const </span>{
00484         <span class="comment">// Compute reflected radiance with photon map</span>
00485         <a class="code" href="classSpectrum.html">Spectrum</a> L(0.);
00486         <a class="code" href="structIntersection.html">Intersection</a> isect;
00487         <span class="keywordflow">if</span> (scene-&gt;<a class="code" href="classScene.html#a3">Intersect</a>(ray, &amp;isect)) {
00488                 <span class="keywordflow">if</span> (alpha) *alpha = 1.;
00489                 <a class="code" href="classVector.html">Vector</a> wo = -ray.<a class="code" href="classRay.html#o1">d</a>;
00490                 <span class="comment">// Compute emitted light if ray hit an area light source</span>
00491                 L += isect.<a class="code" href="structIntersection.html#a2">Le</a>(wo);
00492                 <span class="comment">// Evaluate BSDF at hit point</span>
00493                 <a class="code" href="classBSDF.html">BSDF</a> *bsdf = isect.<a class="code" href="structIntersection.html#a1">GetBSDF</a>(ray);
00494                 <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>;
00495                 <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;n = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>;
00496                 L += <a class="code" href="transport_8h.html#a0">UniformSampleAllLights</a>(scene, p, n,
00497                         wo, bsdf, sample,
00498                         <a class="code" href="classExPhotonIntegrator.html#r12">lightSampleOffset</a>, <a class="code" href="classExPhotonIntegrator.html#r14">bsdfSampleOffset</a>,
00499                         <a class="code" href="classExPhotonIntegrator.html#r15">bsdfComponentOffset</a>);
00500 
00501                 <span class="comment">// Compute indirect lighting for photon map integrator</span>
00502                 L += <a class="code" href="classExPhotonIntegrator.html#h1">LPhoton</a>(<a class="code" href="classExPhotonIntegrator.html#r18">causticMap</a>, <a class="code" href="classExPhotonIntegrator.html#r16">nCausticPaths</a>, <a class="code" href="classExPhotonIntegrator.html#r4">nLookup</a>, bsdf,
00503                         isect, wo, <a class="code" href="classExPhotonIntegrator.html#r7">maxDistSquared</a>);
00504                 <span class="keywordflow">if</span> (<a class="code" href="classExPhotonIntegrator.html#r9">finalGather</a>) {
00505 <span class="preprocessor">#if 1</span>
00506 <span class="preprocessor"></span>                        <span class="comment">// Do one-bounce final gather for photon map</span>
00507                         <a class="code" href="reflection_8h.html#a17">BxDFType</a> nonSpecular = <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a2">BSDF_REFLECTION</a> |
00508                                 <a class="code" href="reflection_8h.html#a17a3">BSDF_TRANSMISSION</a> | <a class="code" href="reflection_8h.html#a17a4">BSDF_DIFFUSE</a> | <a class="code" href="reflection_8h.html#a17a5">BSDF_GLOSSY</a>);
00509                         <span class="keywordflow">if</span> (bsdf-&gt;<a class="code" href="classBSDF.html#a5">NumComponents</a>(nonSpecular) &gt; 0) {
00510                                 <span class="comment">// Find indirect photons around point for importance sampling</span>
00511                                 <a class="code" href="pbrt_8h.html#a51">u_int</a> nIndirSamplePhotons = 50;
00512                                 <a class="code" href="structPhotonProcess.html">PhotonProcess</a> proc(nIndirSamplePhotons, p);
00513                                 proc.<a class="code" href="structPhotonProcess.html#o1">photons</a> = (<a class="code" href="structClosePhoton.html">ClosePhoton</a> *)alloca(nIndirSamplePhotons *
00514                                         <span class="keyword">sizeof</span>(<a class="code" href="structClosePhoton.html">ClosePhoton</a>));
00515                                 <span class="keywordtype">float</span> searchDist2 = <a class="code" href="classExPhotonIntegrator.html#r7">maxDistSquared</a>;
00516                                 <span class="keywordflow">while</span> (proc.<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a> &lt; nIndirSamplePhotons) {
00517                                         <span class="keywordtype">float</span> md2 = searchDist2;
00518                                         proc.<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a> = 0;
00519                                         <a class="code" href="classExPhotonIntegrator.html#r19">indirectMap</a>-&gt;<a class="code" href="classKdTree.html#a3">Lookup</a>(p, proc, md2);
00520                                         searchDist2 *= 2.f;
00521                                 }
00522                                 <span class="comment">// Copy photon directions to local array</span>
00523                                 <a class="code" href="classVector.html">Vector</a> *photonDirs = (<a class="code" href="classVector.html">Vector</a> *)alloca(nIndirSamplePhotons *
00524                                         <span class="keyword">sizeof</span>(<a class="code" href="classVector.html">Vector</a>));
00525                                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; nIndirSamplePhotons; ++i)
00526                                         photonDirs[i] = proc.<a class="code" href="structPhotonProcess.html#o1">photons</a>[i].<a class="code" href="structClosePhoton.html#o0">photon</a>-&gt;<a class="code" href="structPhoton.html#o2">wi</a>;
00527                                 <span class="comment">// Use BSDF to do final gathering</span>
00528                                 <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="classExPhotonIntegrator.html#a2">Li</a> = 0.;
00529                                 <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> gatherRays(<span class="stringliteral">"Photon Map"</span>, <span class="comment">// NOBOOK</span>
00530                                         <span class="stringliteral">"Final gather rays traced"</span>); <span class="comment">// NOBOOK</span>
00531                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classExPhotonIntegrator.html#r11">gatherSamples</a>; ++i) {
00532                                         <span class="comment">// Sample random direction from BSDF for final gather ray</span>
00533                                         Vector wi;
00534                                         <span class="keywordtype">float</span> u1 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[<a class="code" href="classExPhotonIntegrator.html#r0">gatherSampleOffset</a>[0]][2*i];
00535                                         <span class="keywordtype">float</span> u2 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[<a class="code" href="classExPhotonIntegrator.html#r0">gatherSampleOffset</a>[0]][2*i+1];
00536                                         <span class="keywordtype">float</span> u3 = sample-&gt;<a class="code" href="structSample.html#o7">oneD</a>[<a class="code" href="classExPhotonIntegrator.html#r1">gatherComponentOffset</a>[0]][i];
00537                                         <span class="keywordtype">float</span> pdf;
00538                                         <a class="code" href="classSpectrum.html">Spectrum</a> fr = bsdf-&gt;<a class="code" href="classBSDF.html#a0">Sample_f</a>(wo, &amp;wi, u1, u2, u3,
00539                                                 &amp;pdf, <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a10">BSDF_ALL</a> &amp; (~<a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>)));
00540                                         <span class="keywordflow">if</span> (fr.<a class="code" href="classSpectrum.html#a15">Black</a>() || pdf == 0.f) <span class="keywordflow">continue</span>;
00541                                         <span class="comment">// Trace BSDF final gather ray and accumulate radiance</span>
00542                                         <a class="code" href="classRayDifferential.html">RayDifferential</a> bounceRay(p, wi);
00543                                         ++gatherRays; <span class="comment">// NOBOOK</span>
00544                                         <a class="code" href="structIntersection.html">Intersection</a> gatherIsect;
00545                                         <span class="keywordflow">if</span> (scene-&gt;<a class="code" href="classScene.html#a3">Intersect</a>(bounceRay, &amp;gatherIsect)) {
00546                                                 <span class="comment">// Compute exitant radiance using precomputed irradiance</span>
00547                                                 <a class="code" href="classSpectrum.html">Spectrum</a> Lindir = 0.f;
00548                                                 <a class="code" href="classNormal.html">Normal</a> n = gatherIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>;
00549                                                 <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(n, bounceRay.<a class="code" href="classRay.html#o1">d</a>) &gt; 0) n = -n;
00550                                                 <a class="code" href="structRadiancePhotonProcess.html">RadiancePhotonProcess</a> proc(gatherIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, n);
00551                                                 <span class="keywordtype">float</span> md2 = <a class="code" href="pbrt_8h.html#a9">INFINITY</a>;
00552                                                 <a class="code" href="classExPhotonIntegrator.html#r20">radianceMap</a>-&gt;<a class="code" href="classKdTree.html#a3">Lookup</a>(gatherIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, proc, md2);
00553                                                 <span class="keywordflow">if</span> (proc.<a class="code" href="structRadiancePhotonProcess.html#o2">photon</a>)
00554                                                         Lindir = proc.<a class="code" href="structRadiancePhotonProcess.html#o2">photon</a>-&gt;<a class="code" href="structRadiancePhoton.html#o2">Lo</a>;
00555                                                 Lindir *= scene-&gt;<a class="code" href="classScene.html#a7">Transmittance</a>(bounceRay);
00556                                                 <span class="comment">// Compute MIS weight for BSDF-sampled gather ray</span>
00557                                                 <span class="comment">// Compute PDF for photon-sampling of direction _wi_</span>
00558                                                 <span class="keywordtype">float</span> photonPdf = 0.f;
00559                                                 <span class="keywordtype">float</span> conePdf = <a class="code" href="mc_8h.html#a7">UniformConePdf</a>(<a class="code" href="classExPhotonIntegrator.html#r10">cosGatherAngle</a>);
00560                                                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> j = 0; j &lt; nIndirSamplePhotons; ++j)
00561                                                         <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(photonDirs[j], wi) &gt; .999f * <a class="code" href="classExPhotonIntegrator.html#r10">cosGatherAngle</a>)
00562                                                                 photonPdf += conePdf;
00563                                                 photonPdf /= nIndirSamplePhotons;
00564                                                 <span class="keywordtype">float</span> wt = <a class="code" href="mc_8h.html#a14">PowerHeuristic</a>(gatherSamples, pdf,
00565                                                         gatherSamples, photonPdf);
00566                                                 Li += fr * Lindir * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n) * wt / pdf;
00567                                         }
00568                                 }
00569                                 L += Li / gatherSamples;
00570                                 <span class="comment">// Use nearby photons to do final gathering</span>
00571                                 Li = 0.;
00572                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gatherSamples; ++i) {
00573                                         <span class="comment">// Sample random direction using photons for final gather ray</span>
00574                                         <span class="keywordtype">float</span> u1 = sample-&gt;<a class="code" href="structSample.html#o7">oneD</a>[<a class="code" href="classExPhotonIntegrator.html#r1">gatherComponentOffset</a>[1]][i];
00575                                         <span class="keywordtype">float</span> u2 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[<a class="code" href="classExPhotonIntegrator.html#r0">gatherSampleOffset</a>[1]][2*i];
00576                                         <span class="keywordtype">float</span> u3 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[<a class="code" href="classExPhotonIntegrator.html#r0">gatherSampleOffset</a>[1]][2*i+1];
00577                                         <span class="keywordtype">int</span> photonNum = min((<span class="keywordtype">int</span>)nIndirSamplePhotons - 1,
00578                                                 <a class="code" href="pbrt_8h.html#a106">Floor2Int</a>(u1 * nIndirSamplePhotons));
00579                                         <span class="comment">// Sample gather ray direction from _photonNum_</span>
00580                                         Vector vx, vy;
00581                                         <a class="code" href="geometry_8h.html#a8">CoordinateSystem</a>(photonDirs[photonNum], &amp;vx, &amp;vy);
00582                                         Vector wi = <a class="code" href="mc_8h.html#a6">UniformSampleCone</a>(u2, u3, <a class="code" href="classExPhotonIntegrator.html#r10">cosGatherAngle</a>, vx, vy,
00583                                                 photonDirs[photonNum]);
00584                                         <span class="comment">// Trace photon-sampled final gather ray and accumulate radiance</span>
00585                                         <a class="code" href="classSpectrum.html">Spectrum</a> fr = bsdf-&gt;<a class="code" href="classBSDF.html#a10">f</a>(wo, wi);
00586                                         <span class="keywordflow">if</span> (fr.<a class="code" href="classSpectrum.html#a15">Black</a>()) <span class="keywordflow">continue</span>;
00587                                         <span class="comment">// Compute PDF for photon-sampling of direction _wi_</span>
00588                                         <span class="keywordtype">float</span> photonPdf = 0.f;
00589                                         <span class="keywordtype">float</span> conePdf = <a class="code" href="mc_8h.html#a7">UniformConePdf</a>(<a class="code" href="classExPhotonIntegrator.html#r10">cosGatherAngle</a>);
00590                                         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> j = 0; j &lt; nIndirSamplePhotons; ++j)
00591                                                 <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(photonDirs[j], wi) &gt; .999f * <a class="code" href="classExPhotonIntegrator.html#r10">cosGatherAngle</a>)
00592                                                         photonPdf += conePdf;
00593                                         photonPdf /= nIndirSamplePhotons;
00594                                         <a class="code" href="classRayDifferential.html">RayDifferential</a> bounceRay(p, wi);
00595                                         ++gatherRays; <span class="comment">// NOBOOK</span>
00596                                         <a class="code" href="structIntersection.html">Intersection</a> gatherIsect;
00597                                         <span class="keywordflow">if</span> (scene-&gt;<a class="code" href="classScene.html#a3">Intersect</a>(bounceRay, &amp;gatherIsect)) {
00598                                                 <span class="comment">// Compute exitant radiance using precomputed irradiance</span>
00599                                                 <a class="code" href="classSpectrum.html">Spectrum</a> Lindir = 0.f;
00600                                                 <a class="code" href="classNormal.html">Normal</a> n = gatherIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>;
00601                                                 <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(n, bounceRay.<a class="code" href="classRay.html#o1">d</a>) &gt; 0) n = -n;
00602                                                 <a class="code" href="structRadiancePhotonProcess.html">RadiancePhotonProcess</a> proc(gatherIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, n);
00603                                                 <span class="keywordtype">float</span> md2 = <a class="code" href="pbrt_8h.html#a9">INFINITY</a>;
00604                                                 <a class="code" href="classExPhotonIntegrator.html#r20">radianceMap</a>-&gt;<a class="code" href="classKdTree.html#a3">Lookup</a>(gatherIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, proc, md2);
00605                                                 <span class="keywordflow">if</span> (proc.<a class="code" href="structRadiancePhotonProcess.html#o2">photon</a>)
00606                                                         Lindir = proc.<a class="code" href="structRadiancePhotonProcess.html#o2">photon</a>-&gt;<a class="code" href="structRadiancePhoton.html#o2">Lo</a>;
00607                                                 Lindir *= scene-&gt;<a class="code" href="classScene.html#a7">Transmittance</a>(bounceRay);
00608                                                 <span class="comment">// Compute MIS weight for photon-sampled gather ray</span>
00609                                                 <span class="keywordtype">float</span> bsdfPdf = bsdf-&gt;<a class="code" href="classBSDF.html#a2">Pdf</a>(wo, wi);
00610                                                 <span class="keywordtype">float</span> wt = <a class="code" href="mc_8h.html#a14">PowerHeuristic</a>(gatherSamples, photonPdf,
00611                                                                 gatherSamples, bsdfPdf);
00612                                                 Li += fr * Lindir * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n) * wt / photonPdf;
00613                                         }
00614                                 }
00615                                 L += Li / gatherSamples;
00616                         }
00617 <span class="preprocessor">#else</span>
00618 <span class="preprocessor"></span><span class="comment">// look at radiance map directly..</span>
00619 <a class="code" href="classNormal.html">Normal</a> nn = n;
00620 <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(nn, ray.<a class="code" href="classRay.html#o1">d</a>) &gt; 0.) nn = -n;
00621 <a class="code" href="structRadiancePhotonProcess.html">RadiancePhotonProcess</a> proc(p, nn);
00622 <span class="keywordtype">float</span> md2 = <a class="code" href="pbrt_8h.html#a9">INFINITY</a>;
00623 <a class="code" href="classExPhotonIntegrator.html#r20">radianceMap</a>-&gt;<a class="code" href="classKdTree.html#a3">Lookup</a>(p, proc, md2);
00624 <span class="keywordflow">if</span> (proc.<a class="code" href="structRadiancePhotonProcess.html#o2">photon</a>)
00625         L += proc.<a class="code" href="structRadiancePhotonProcess.html#o2">photon</a>-&gt;<a class="code" href="structRadiancePhoton.html#o2">Lo</a>;
00626 <span class="preprocessor">#endif</span>
00627 <span class="preprocessor"></span>
00628                 }
00629                 <span class="keywordflow">else</span> {
00630                     L += LPhoton(<a class="code" href="classExPhotonIntegrator.html#r19">indirectMap</a>, <a class="code" href="classExPhotonIntegrator.html#r17">nIndirectPaths</a>, <a class="code" href="classExPhotonIntegrator.html#r4">nLookup</a>,
00631                                  bsdf, isect, wo, <a class="code" href="classExPhotonIntegrator.html#r7">maxDistSquared</a>);
00632                 }
00633                 <span class="keywordflow">if</span> (<a class="code" href="classExPhotonIntegrator.html#r5">specularDepth</a>++ &lt; <a class="code" href="classExPhotonIntegrator.html#r6">maxSpecularDepth</a>) {
00634                         <a class="code" href="classVector.html">Vector</a> wi;
00635                         <span class="comment">// Trace rays for specular reflection and refraction</span>
00636                         <a class="code" href="classSpectrum.html">Spectrum</a> f = bsdf-&gt;<a class="code" href="classBSDF.html#a0">Sample_f</a>(wo, &amp;wi,
00637                                 <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a2">BSDF_REFLECTION</a> | <a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>));
00638                         <span class="keywordflow">if</span> (!f.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00639                                 <span class="comment">// Compute ray differential _rd_ for specular reflection</span>
00640                                 <a class="code" href="classRayDifferential.html">RayDifferential</a> rd(p, wi);
00641                                 rd.<a class="code" href="classRayDifferential.html#o0">hasDifferentials</a> = <span class="keyword">true</span>;
00642                                 rd.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o0">o</a> = p + isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o9">dpdx</a>;
00643                                 rd.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o0">o</a> = p + isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o10">dpdy</a>;
00644                                 <span class="comment">// Compute differential reflected directions</span>
00645                                 <a class="code" href="classNormal.html">Normal</a> dndx = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o7">dndu</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o11">dudx</a> +
00646                                         bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o8">dndv</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o12">dvdx</a>;
00647                                 <a class="code" href="classNormal.html">Normal</a> dndy = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o7">dndu</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o13">dudy</a> +
00648                                         bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o8">dndv</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o14">dvdy</a>;
00649                                 <a class="code" href="classVector.html">Vector</a> dwodx = -ray.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o1">d</a> - wo, dwody = -ray.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o1">d</a> - wo;
00650                                 <span class="keywordtype">float</span> dDNdx = <a class="code" href="geometry_8h.html#a17">Dot</a>(dwodx, n) + <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, dndx);
00651                                 <span class="keywordtype">float</span> dDNdy = <a class="code" href="geometry_8h.html#a17">Dot</a>(dwody, n) + <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, dndy);
00652                                 rd.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o1">d</a> = wi -
00653                                           dwodx + 2 * <a class="code" href="classVector.html">Vector</a>(<a class="code" href="geometry_8h.html#a17">Dot</a>(wo, n) * dndx +
00654                                                   dDNdx * n);
00655                                 rd.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o1">d</a> = wi -
00656                                           dwody + 2 * Vector(<a class="code" href="geometry_8h.html#a17">Dot</a>(wo, n) * dndy +
00657                                                   dDNdy * n);
00658                                 L += scene-&gt;<a class="code" href="classScene.html#a6">Li</a>(rd, sample) * f * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n);
00659                         }
00660                         f = bsdf-&gt;<a class="code" href="classBSDF.html#a0">Sample_f</a>(wo, &amp;wi,
00661                                 <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a3">BSDF_TRANSMISSION</a> | <a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>));
00662                         <span class="keywordflow">if</span> (!f.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00663                                 <span class="comment">// Compute ray differential _rd_ for specular transmission</span>
00664                                 <a class="code" href="classRayDifferential.html">RayDifferential</a> rd(p, wi);
00665                                 rd.<a class="code" href="classRayDifferential.html#o0">hasDifferentials</a> = <span class="keyword">true</span>;
00666                                 rd.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o0">o</a> = p + isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o9">dpdx</a>;
00667                                 rd.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o0">o</a> = p + isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o10">dpdy</a>;
00668 
00669                                 <span class="keywordtype">float</span> eta = bsdf-&gt;<a class="code" href="classBSDF.html#o1">eta</a>;
00670                                 <a class="code" href="classVector.html">Vector</a> w = -wo;
00671                                 <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(wo, n) &lt; 0) eta = 1.f / eta;
00672 
00673                                 <a class="code" href="classNormal.html">Normal</a> dndx = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o7">dndu</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o11">dudx</a> + bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o8">dndv</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o12">dvdx</a>;
00674                                 <a class="code" href="classNormal.html">Normal</a> dndy = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o7">dndu</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o13">dudy</a> + bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o8">dndv</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o14">dvdy</a>;
00675 
00676                                 <a class="code" href="classVector.html">Vector</a> dwodx = -ray.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o1">d</a> - wo, dwody = -ray.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o1">d</a> - wo;
00677                                 <span class="keywordtype">float</span> dDNdx = <a class="code" href="geometry_8h.html#a17">Dot</a>(dwodx, n) + <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, dndx);
00678                                 <span class="keywordtype">float</span> dDNdy = <a class="code" href="geometry_8h.html#a17">Dot</a>(dwody, n) + <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, dndy);
00679 
00680                                 <span class="keywordtype">float</span> mu = eta * <a class="code" href="geometry_8h.html#a17">Dot</a>(w, n) - <a class="code" href="geometry_8h.html#a17">Dot</a>(wi, n);
00681                                 <span class="keywordtype">float</span> dmudx = (eta - (eta*eta*<a class="code" href="geometry_8h.html#a17">Dot</a>(w,n))/<a class="code" href="geometry_8h.html#a17">Dot</a>(wi, n)) * dDNdx;
00682                                 <span class="keywordtype">float</span> dmudy = (eta - (eta*eta*<a class="code" href="geometry_8h.html#a17">Dot</a>(w,n))/<a class="code" href="geometry_8h.html#a17">Dot</a>(wi, n)) * dDNdy;
00683 
00684                                 rd.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o1">d</a> = wi + eta * dwodx - <a class="code" href="classVector.html">Vector</a>(mu * dndx + dmudx * n);
00685                                 rd.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o1">d</a> = wi + eta * dwody - Vector(mu * dndy + dmudy * n);
00686                                 L += scene-&gt;<a class="code" href="classScene.html#a6">Li</a>(rd, sample) * f * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n);
00687                         }
00688                 }
00689                 --<a class="code" href="classExPhotonIntegrator.html#r5">specularDepth</a>;
00690         }
00691         <span class="keywordflow">else</span> {
00692                 <span class="comment">// Handle ray with no intersection</span>
00693                 <span class="keywordflow">if</span> (alpha) *alpha = 0.;
00694                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size(); ++i)
00695                         L += scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[i]-&gt;Le(ray);
00696                 <span class="keywordflow">if</span> (alpha &amp;&amp; !L.<a class="code" href="classSpectrum.html#a15">Black</a>()) *alpha = 1.;
00697                 <span class="keywordflow">return</span> L;
00698         }
00699         <span class="keywordflow">return</span> L;
00700 }
<a name="l00701"></a><a class="code" href="exphotonmap_8cpp.html#a1">00701</a> <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <a class="code" href="pbrt_8h.html#a2">DLLEXPORT</a> <a class="code" href="classSurfaceIntegrator.html">SurfaceIntegrator</a> *<a class="code" href="whitted_8cpp.html#a0">CreateSurfaceIntegrator</a>(<span class="keyword">const</span> <a class="code" href="classParamSet.html">ParamSet</a> &amp;params) {
00702         <span class="keywordtype">int</span> nCaustic = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"causticphotons"</span>, 20000);
00703         <span class="keywordtype">int</span> nIndirect = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"indirectphotons"</span>, 100000);
00704         <span class="keywordtype">int</span> nUsed = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"nused"</span>, 50);
00705         <span class="keywordtype">int</span> maxDepth = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"maxdepth"</span>, 5);
00706         <span class="keywordtype">bool</span> finalGather = params.<a class="code" href="classParamSet.html#a23">FindOneBool</a>(<span class="stringliteral">"finalgather"</span>, <span class="keyword">true</span>);
00707         <span class="keywordtype">int</span> gatherSamples = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"finalgathersamples"</span>, 32);
00708         <span class="keywordtype">float</span> maxDist = params.<a class="code" href="classParamSet.html#a21">FindOneFloat</a>(<span class="stringliteral">"maxdist"</span>, .1f);
00709         <span class="keywordtype">float</span> rrTreshold = params.<a class="code" href="classParamSet.html#a21">FindOneFloat</a>(<span class="stringliteral">"rrthreshold"</span>, .05f);
00710         <span class="keywordtype">float</span> gatherAngle = params.<a class="code" href="classParamSet.html#a21">FindOneFloat</a>(<span class="stringliteral">"gatherangle"</span>, 10.f);
00711         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classExPhotonIntegrator.html">ExPhotonIntegrator</a>(nCaustic, nIndirect,
00712                 nUsed, maxDepth, maxDist, finalGather, gatherSamples,
00713                 rrTreshold, gatherAngle);
00714 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Mon Apr 25 19:00:20 2005 for pbrt by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
