<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pbrt: nurbs.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>nurbs.cpp</h1><a href="nurbs_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> * pbrt source code Copyright(c) 1998-2005 Matt Pharr and Greg Humphreys</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * All Rights Reserved.</span>
00006 <span class="comment"> * For educational use only; commercial use expressly forbidden.</span>
00007 <span class="comment"> * NO WARRANTY, express or implied, for this software.</span>
00008 <span class="comment"> * (See file License.txt for complete license)</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">// nurbs.cpp*</span>
00012 <span class="preprocessor">#include "<a class="code" href="pbrt_8h.html">pbrt.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="shape_8h.html">shape.h</a>"</span>
00014 <span class="preprocessor">#include "<a class="code" href="geometry_8h.html">geometry.h</a>"</span>
00015 <span class="preprocessor">#include "<a class="code" href="dynload_8h.html">dynload.h</a>"</span>
00016 <span class="preprocessor">#include "<a class="code" href="texture_8h.html">texture.h</a>"</span>
00017 <span class="comment">// NURBS Declarations</span>
<a name="l00018"></a><a class="code" href="classNURBS.html">00018</a> <span class="keyword">class </span><a class="code" href="classNURBS.html">NURBS</a> : <span class="keyword">public</span> <a class="code" href="classShape.html">Shape</a> {
00019 <span class="keyword">public</span>:
00020         <span class="comment">// NURBS Methods</span>
00021         <a class="code" href="classNURBS.html">NURBS</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a> &amp;o2w, <span class="keywordtype">bool</span> reverseOrientation, <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#r0">nu</a>, <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#r1">uorder</a>,
00022                 <span class="keyword">const</span> <span class="keywordtype">float</span> *<a class="code" href="classNURBS.html#r8">uknot</a>, <span class="keywordtype">float</span> <a class="code" href="classNURBS.html#r4">umin</a>, <span class="keywordtype">float</span> <a class="code" href="classNURBS.html#r5">umax</a>,
00023                 <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#r2">nv</a>, <span class="keywordtype">int</span> <a class="code" href="classNURBS.html#r3">vorder</a>, <span class="keyword">const</span> <span class="keywordtype">float</span> *<a class="code" href="classNURBS.html#r9">vknot</a>, <span class="keywordtype">float</span> <a class="code" href="classNURBS.html#r6">vmin</a>, <span class="keywordtype">float</span> <a class="code" href="classNURBS.html#r7">vmax</a>,
00024                 <span class="keyword">const</span> <span class="keywordtype">float</span> *<a class="code" href="classNURBS.html#r11">P</a>, <span class="keywordtype">bool</span> <a class="code" href="classNURBS.html#r10">isHomogeneous</a>);
00025         <a class="code" href="classNURBS.html#a1">~NURBS</a>();
00026         <span class="keyword">virtual</span> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classNURBS.html#a2">ObjectBound</a>() <span class="keyword">const</span>;
00027         <span class="keyword">virtual</span> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classNURBS.html#a3">WorldBound</a>() <span class="keyword">const</span>;
<a name="l00028"></a><a class="code" href="classNURBS.html#a4">00028</a>         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classNURBS.html#a4">CanIntersect</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }
00029         <span class="keyword">virtual</span> <span class="keywordtype">void</span> Refine(vector&lt;<a class="code" href="classReference.html">Reference&lt;Shape&gt;</a> &gt; &amp;refined) <span class="keyword">const</span>;
00030 <span class="keyword">private</span>:
00031         <span class="comment">// NURBS Data</span>
<a name="l00032"></a><a class="code" href="classNURBS.html#r3">00032</a>         <span class="keywordtype">int</span> nu, uorder, nv, vorder;
<a name="l00033"></a><a class="code" href="classNURBS.html#r6">00033</a>         <span class="keywordtype">float</span> umin, umax, vmin, vmax;
<a name="l00034"></a><a class="code" href="classNURBS.html#r9">00034</a>         <span class="keywordtype">float</span> *uknot, *vknot;
<a name="l00035"></a><a class="code" href="classNURBS.html#r10">00035</a>         <span class="keywordtype">bool</span> isHomogeneous;
<a name="l00036"></a><a class="code" href="classNURBS.html#r11">00036</a>         <span class="keywordtype">float</span> *P;
00037 };
00038 <span class="comment">// NURBS Evaluation Functions</span>
<a name="l00039"></a><a class="code" href="nurbs_8cpp.html#a1">00039</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="nurbs_8cpp.html#a1">KnotOffset</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *knot, <span class="keywordtype">int</span> order, <span class="keywordtype">int</span> np, <span class="keywordtype">float</span> t) {
00040     <span class="keywordtype">int</span> firstKnot = order - 1;
00041     <span class="keywordtype">int</span> lastKnot = np;
00042 
00043     <span class="keywordtype">int</span> knotOffset = firstKnot;
00044     <span class="keywordflow">while</span> (t &gt; knot[knotOffset+1])
00045         ++knotOffset;
00046     assert(knotOffset &lt; lastKnot);
00047     assert(t &gt;= knot[knotOffset] &amp;&amp; t &lt;= knot[knotOffset + 1]);
00048     <span class="keywordflow">return</span> knotOffset;
00049 }
00050 
00051 <span class="comment">// doesn't handle flat out discontinuities in the curve...</span>
00052 
<a name="l00053"></a><a class="code" href="structHomogeneous3.html">00053</a> <span class="keyword">struct </span><a class="code" href="structHomogeneous3.html">Homogeneous3</a> {
<a name="l00054"></a><a class="code" href="structHomogeneous3.html#a0">00054</a> <a class="code" href="structHomogeneous3.html#a0">Homogeneous3</a>() { <a class="code" href="structHomogeneous3.html#o0">x</a> = <a class="code" href="structHomogeneous3.html#o1">y</a> = <a class="code" href="structHomogeneous3.html#o2">z</a> = <a class="code" href="structHomogeneous3.html#o3">w</a> = 0.; }
<a name="l00055"></a><a class="code" href="structHomogeneous3.html#a1">00055</a> <a class="code" href="structHomogeneous3.html#a0">Homogeneous3</a>(<span class="keywordtype">float</span> xx, <span class="keywordtype">float</span> yy, <span class="keywordtype">float</span> zz, <span class="keywordtype">float</span> ww) {
00056     <a class="code" href="structHomogeneous3.html#o0">x</a> = xx; <a class="code" href="structHomogeneous3.html#o1">y</a> = yy; <a class="code" href="structHomogeneous3.html#o2">z</a> = zz; <a class="code" href="structHomogeneous3.html#o3">w</a> = ww;
00057 }
<a name="l00058"></a><a class="code" href="structHomogeneous3.html#o2">00058</a> <span class="keywordtype">float</span> <a class="code" href="structHomogeneous3.html#o0">x</a>, <a class="code" href="structHomogeneous3.html#o1">y</a>, <a class="code" href="structHomogeneous3.html#o2">z</a>, <a class="code" href="structHomogeneous3.html#o3">w</a>;
00059 };
00060 <span class="keyword">static</span> <a class="code" href="structHomogeneous3.html">Homogeneous3</a>
<a name="l00061"></a><a class="code" href="nurbs_8cpp.html#a2">00061</a> <a class="code" href="nurbs_8cpp.html#a2">NURBSEvaluate</a>(<span class="keywordtype">int</span> order, <span class="keyword">const</span> <span class="keywordtype">float</span> *knot, <span class="keyword">const</span> <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *cp, <span class="keywordtype">int</span> np,
00062               <span class="keywordtype">int</span> cpStride, <span class="keywordtype">float</span> t, <a class="code" href="classVector.html">Vector</a> *deriv = NULL) {
00063 <span class="comment">//    int nKnots = np + order;</span>
00064     <span class="keywordtype">float</span> alpha;
00065 
00066     <span class="keywordtype">int</span> knotOffset = <a class="code" href="nurbs_8cpp.html#a1">KnotOffset</a>(knot, order, np, t);
00067     knot += knotOffset;
00068 
00069     <span class="keywordtype">int</span> cpOffset = knotOffset - order + 1;
00070     assert(cpOffset &gt;= 0 &amp;&amp; cpOffset &lt; np);
00071 
00072     <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *cpWork =
00073         (<a class="code" href="structHomogeneous3.html">Homogeneous3</a> *)alloca(order * <span class="keyword">sizeof</span>(<a class="code" href="structHomogeneous3.html">Homogeneous3</a>));
00074     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; order; ++i)
00075         cpWork[i] = cp[(cpOffset+i) * cpStride];
00076 
00077     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; order - 2; ++i)
00078         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; order - 1 - i; ++j) {
00079             alpha = (knot[1 + j] - t) /
00080                 (knot[1 + j] - knot[j + 2 - order + i]);
00081             assert(alpha &gt;= 0. &amp;&amp; alpha &lt;= 1.);
00082 
00083             cpWork[j].<a class="code" href="structHomogeneous3.html#o0">x</a> = cpWork[j].<a class="code" href="structHomogeneous3.html#o0">x</a> * alpha + cpWork[j+1].<a class="code" href="structHomogeneous3.html#o0">x</a> * (1 - alpha);
00084             cpWork[j].y = cpWork[j].y * alpha + cpWork[j+1].y * (1 - alpha);
00085             cpWork[j].z = cpWork[j].z * alpha + cpWork[j+1].z * (1 - alpha);
00086             cpWork[j].w = cpWork[j].w * alpha + cpWork[j+1].w * (1 - alpha);
00087         }
00088 
00089     alpha = (knot[1] - t) / (knot[1] - knot[0]);
00090     assert(alpha &gt;= 0. &amp;&amp; alpha &lt;= 1.);
00091 
00092     Homogeneous3 val(cpWork[0].x * alpha + cpWork[1].x * (1 - alpha),
00093                      cpWork[0].y * alpha + cpWork[1].y * (1 - alpha),
00094                      cpWork[0].z * alpha + cpWork[1].z * (1 - alpha),
00095                      cpWork[0].w * alpha + cpWork[1].w * (1 - alpha));
00096 
00097     <span class="keywordflow">if</span> (deriv) {
00098                 <span class="keywordtype">float</span> factor = (order - 1) / (knot[1] - knot[0]);
00099                 Homogeneous3 delta((cpWork[1].x - cpWork[0].x) * factor,
00100                            (cpWork[1].y - cpWork[0].y) * factor,
00101                            (cpWork[1].z - cpWork[0].z) * factor,
00102                            (cpWork[1].w - cpWork[0].w) * factor);
00103 
00104                 deriv-&gt;x = delta.<a class="code" href="structHomogeneous3.html#o0">x</a> / val.<a class="code" href="structHomogeneous3.html#o3">w</a> - (val.<a class="code" href="structHomogeneous3.html#o0">x</a> * delta.<a class="code" href="structHomogeneous3.html#o3">w</a> / (val.<a class="code" href="structHomogeneous3.html#o3">w</a> * val.<a class="code" href="structHomogeneous3.html#o3">w</a>));
00105                 deriv-&gt;y = delta.<a class="code" href="structHomogeneous3.html#o1">y</a> / val.<a class="code" href="structHomogeneous3.html#o3">w</a> - (val.<a class="code" href="structHomogeneous3.html#o1">y</a> * delta.<a class="code" href="structHomogeneous3.html#o3">w</a> / (val.<a class="code" href="structHomogeneous3.html#o3">w</a> * val.<a class="code" href="structHomogeneous3.html#o3">w</a>));
00106                 deriv-&gt;z = delta.<a class="code" href="structHomogeneous3.html#o2">z</a> / val.<a class="code" href="structHomogeneous3.html#o3">w</a> - (val.<a class="code" href="structHomogeneous3.html#o2">z</a> * delta.<a class="code" href="structHomogeneous3.html#o3">w</a> / (val.<a class="code" href="structHomogeneous3.html#o3">w</a> * val.<a class="code" href="structHomogeneous3.html#o3">w</a>));
00107     }
00108 
00109     <span class="keywordflow">return</span> val;
00110 }
00111 <span class="keyword">static</span> <a class="code" href="classPoint.html">Point</a>
<a name="l00112"></a><a class="code" href="nurbs_8cpp.html#a3">00112</a> <a class="code" href="nurbs_8cpp.html#a3">NURBSEvaluateSurface</a>(<span class="keywordtype">int</span> uOrder, <span class="keyword">const</span> <span class="keywordtype">float</span> *uKnot, <span class="keywordtype">int</span> ucp, <span class="keywordtype">float</span> u,
00113                      <span class="keywordtype">int</span> vOrder, <span class="keyword">const</span> <span class="keywordtype">float</span> *vKnot, <span class="keywordtype">int</span> vcp, <span class="keywordtype">float</span> v,
00114                      <span class="keyword">const</span> <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *cp, <a class="code" href="classVector.html">Vector</a> *dPdu, <a class="code" href="classVector.html">Vector</a> *dPdv) {
00115     <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *iso = (<a class="code" href="structHomogeneous3.html">Homogeneous3</a> *)alloca(max(uOrder, vOrder) *
00116                                                <span class="keyword">sizeof</span>(<a class="code" href="structHomogeneous3.html">Homogeneous3</a>));
00117 
00118     <span class="keywordtype">int</span> uOffset = <a class="code" href="nurbs_8cpp.html#a1">KnotOffset</a>(uKnot, uOrder, ucp, u);
00119     <span class="keywordtype">int</span> uFirstCp = uOffset - uOrder + 1;
00120     assert(uFirstCp &gt;= 0 &amp;&amp; uFirstCp + uOrder - 1 &lt; ucp);
00121 
00122     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; uOrder; ++i)
00123                 iso[i] = <a class="code" href="nurbs_8cpp.html#a2">NURBSEvaluate</a>(vOrder, vKnot, &amp;cp[uFirstCp + i], vcp,
00124                                ucp, v);
00125 
00126     <span class="keywordtype">int</span> vOffset = <a class="code" href="nurbs_8cpp.html#a1">KnotOffset</a>(vKnot, vOrder, vcp, v);
00127     <span class="keywordtype">int</span> vFirstCp = vOffset - vOrder + 1;
00128     assert(vFirstCp &gt;= 0 &amp;&amp; vFirstCp + vOrder - 1 &lt; vcp);
00129 
00130     Homogeneous3 P = <a class="code" href="nurbs_8cpp.html#a2">NURBSEvaluate</a>(uOrder, uKnot, iso - uFirstCp, ucp,
00131                                    1, u, dPdu);
00132 
00133     <span class="keywordflow">if</span> (dPdv) {
00134                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vOrder; ++i)
00135                     iso[i] = <a class="code" href="nurbs_8cpp.html#a2">NURBSEvaluate</a>(uOrder, uKnot, &amp;cp[(vFirstCp+i)*ucp], ucp,
00136                                    1, u);
00137                 (<span class="keywordtype">void</span>)<a class="code" href="nurbs_8cpp.html#a2">NURBSEvaluate</a>(vOrder, vKnot, iso - vFirstCp, vcp, 1, v, dPdv);
00138     }
00139     <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point</a>(P.<a class="code" href="structHomogeneous3.html#o0">x</a>/P.<a class="code" href="structHomogeneous3.html#o3">w</a>, P.<a class="code" href="structHomogeneous3.html#o1">y</a>/P.<a class="code" href="structHomogeneous3.html#o3">w</a>, P.<a class="code" href="structHomogeneous3.html#o2">z</a>/P.<a class="code" href="structHomogeneous3.html#o3">w</a>);;
00140 }
00141 <span class="comment">// NURBS Definitions</span>
<a name="l00142"></a><a class="code" href="classNURBS.html#a0">00142</a> <a class="code" href="classNURBS.html#a0">NURBS::NURBS</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a> &amp;o2w, <span class="keywordtype">bool</span> ro, <span class="keywordtype">int</span> numu, <span class="keywordtype">int</span> uo, <span class="keyword">const</span> <span class="keywordtype">float</span> *uk,
00143                 <span class="keywordtype">float</span> u0, <span class="keywordtype">float</span> u1, <span class="keywordtype">int</span> numv, <span class="keywordtype">int</span> vo, <span class="keyword">const</span> <span class="keywordtype">float</span> *vk,
00144                 <span class="keywordtype">float</span> v0, <span class="keywordtype">float</span> v1, <span class="keyword">const</span> <span class="keywordtype">float</span> *p, <span class="keywordtype">bool</span> homogeneous)
00145         : <a class="code" href="classShape.html">Shape</a>(o2w, ro) {
00146         <a class="code" href="classNURBS.html#r0">nu</a> = numu;    <a class="code" href="classNURBS.html#r1">uorder</a> = uo;
00147         <a class="code" href="classNURBS.html#r4">umin</a> = u0;    <a class="code" href="classNURBS.html#r5">umax</a> = u1;
00148         <a class="code" href="classNURBS.html#r2">nv</a> = numv;    <a class="code" href="classNURBS.html#r3">vorder</a> = vo;
00149         <a class="code" href="classNURBS.html#r6">vmin</a> = v0;    <a class="code" href="classNURBS.html#r7">vmax</a> = v1;
00150         <a class="code" href="classNURBS.html#r10">isHomogeneous</a> = homogeneous;
00151         <span class="keywordflow">if</span> (<a class="code" href="classNURBS.html#r10">isHomogeneous</a>) {
00152                 <a class="code" href="classNURBS.html#r11">P</a> = <span class="keyword">new</span> <span class="keywordtype">float</span>[4*<a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>];
00153                 <a class="code" href="pbrtparse_8y.html#a40">memcpy</a>(<a class="code" href="classNURBS.html#r11">P</a>, p, 4*<a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00154         } <span class="keywordflow">else</span> {
00155                 <a class="code" href="classNURBS.html#r11">P</a> = <span class="keyword">new</span> <span class="keywordtype">float</span>[3*<a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>];
00156                 <a class="code" href="pbrtparse_8y.html#a40">memcpy</a>(<a class="code" href="classNURBS.html#r11">P</a>, p, 3*<a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00157         }
00158         <a class="code" href="classNURBS.html#r8">uknot</a> = <span class="keyword">new</span> <span class="keywordtype">float</span>[<a class="code" href="classNURBS.html#r0">nu</a> + <a class="code" href="classNURBS.html#r1">uorder</a>];
00159         <a class="code" href="pbrtparse_8y.html#a40">memcpy</a>(<a class="code" href="classNURBS.html#r8">uknot</a>, uk, (<a class="code" href="classNURBS.html#r0">nu</a> + <a class="code" href="classNURBS.html#r1">uorder</a>) * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00160         <a class="code" href="classNURBS.html#r9">vknot</a> = <span class="keyword">new</span> <span class="keywordtype">float</span>[<a class="code" href="classNURBS.html#r2">nv</a> + <a class="code" href="classNURBS.html#r3">vorder</a>];
00161         <a class="code" href="pbrtparse_8y.html#a40">memcpy</a>(<a class="code" href="classNURBS.html#r9">vknot</a>, vk, (<a class="code" href="classNURBS.html#r2">nv</a> + <a class="code" href="classNURBS.html#r3">vorder</a>) * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00162 }
<a name="l00163"></a><a class="code" href="classNURBS.html#a1">00163</a> <a class="code" href="classNURBS.html#a1">NURBS::~NURBS</a>() {
00164         <span class="keyword">delete</span>[] <a class="code" href="classNURBS.html#r11">P</a>;
00165         <span class="keyword">delete</span>[] <a class="code" href="classNURBS.html#r8">uknot</a>;
00166         <span class="keyword">delete</span>[] <a class="code" href="classNURBS.html#r9">vknot</a>;
00167 }
<a name="l00168"></a><a class="code" href="classNURBS.html#a2">00168</a> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classNURBS.html#a2">NURBS::ObjectBound</a>()<span class="keyword"> const </span>{
00169         <span class="keywordflow">if</span> (!<a class="code" href="classNURBS.html#r10">isHomogeneous</a>) {
00170                 <span class="comment">// Compute object-space bound of non-homogeneous NURBS</span>
00171                 <span class="keywordtype">float</span> *pp = <a class="code" href="classNURBS.html#r11">P</a>;
00172                 <a class="code" href="classBBox.html">BBox</a> bound = <a class="code" href="classPoint.html">Point</a>(pp[0], pp[1], pp[2]);
00173                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>; ++i, pp += 3)
00174                         bound = <a class="code" href="geometry_8cpp.html#a1">Union</a>(bound, Point(pp[0], pp[1], pp[2]));
00175                 <span class="keywordflow">return</span> bound;
00176         } <span class="keywordflow">else</span> {
00177                 <span class="comment">// Compute object-space bound of homogeneous NURBS</span>
00178                 <span class="keywordtype">float</span> *pp = <a class="code" href="classNURBS.html#r11">P</a>;
00179                 <a class="code" href="classBBox.html">BBox</a> bound = <a class="code" href="classPoint.html">Point</a>(pp[0] / pp[3], pp[1] / pp[3], pp[2] / pp[3]);
00180                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>; ++i, pp += 4)
00181                         bound = <a class="code" href="geometry_8cpp.html#a1">Union</a>(bound, Point(pp[0] / pp[3], pp[1] / pp[3], pp[2] / pp[3]));
00182                 <span class="keywordflow">return</span> bound;
00183         }
00184 }
<a name="l00185"></a><a class="code" href="classNURBS.html#a3">00185</a> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classNURBS.html#a3">NURBS::WorldBound</a>()<span class="keyword"> const </span>{
00186         <span class="keywordflow">if</span> (!<a class="code" href="classNURBS.html#r10">isHomogeneous</a>) {
00187                 <span class="comment">// Compute world-space bound of non-homogeneous NURBS</span>
00188                 <span class="keywordtype">float</span> *pp = <a class="code" href="classNURBS.html#r11">P</a>;
00189                 <a class="code" href="classPoint.html">Point</a> pt = ObjectToWorld(<a class="code" href="classPoint.html">Point</a>(pp[0], pp[1], pp[2]));
00190                 <a class="code" href="classBBox.html">BBox</a> bound = pt;
00191                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>; ++i, pp += 3) {
00192                         pt = ObjectToWorld(<a class="code" href="classPoint.html">Point</a>(pp[0], pp[1], pp[2]));
00193                         bound = <a class="code" href="geometry_8cpp.html#a1">Union</a>(bound, pt);
00194                 }
00195                 <span class="keywordflow">return</span> bound;
00196         } <span class="keywordflow">else</span> {
00197                 <span class="comment">// Compute world-space bound of homogeneous NURBS</span>
00198                 <span class="keywordtype">float</span> *pp = <a class="code" href="classNURBS.html#r11">P</a>;
00199                 <a class="code" href="classPoint.html">Point</a> pt = ObjectToWorld(<a class="code" href="classPoint.html">Point</a>(pp[0]/pp[3],
00200                         pp[1]/pp[3], pp[2]/pp[3]));
00201                 <a class="code" href="classBBox.html">BBox</a> bound = pt;
00202                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>; ++i, pp += 4) {
00203                         pt = ObjectToWorld(<a class="code" href="classPoint.html">Point</a>(pp[0]/pp[3],
00204                                 pp[1]/pp[3], pp[2]/pp[3]));
00205                         bound = <a class="code" href="geometry_8cpp.html#a1">Union</a>(bound, pt);
00206                 }
00207                 <span class="keywordflow">return</span> bound;
00208         }
00209 }
00210 
<a name="l00211"></a><a class="code" href="classNURBS.html#a5">00211</a> <span class="keywordtype">void</span> <a class="code" href="classNURBS.html#a5">NURBS::Refine</a>(vector&lt;<a class="code" href="classReference.html">Reference&lt;Shape&gt;</a> &gt; &amp;refined)<span class="keyword"> const </span>{
00212         <span class="comment">// Compute NURBS dicing rates</span>
00213         <span class="keywordtype">int</span> diceu = 30, dicev = 30;
00214         <span class="keywordtype">float</span> *ueval = <span class="keyword">new</span> <span class="keywordtype">float</span>[diceu];
00215         <span class="keywordtype">float</span> *veval = <span class="keyword">new</span> <span class="keywordtype">float</span>[dicev];
00216         <a class="code" href="classPoint.html">Point</a> *evalPs = <span class="keyword">new</span> <a class="code" href="classPoint.html">Point</a>[diceu*dicev];
00217         <a class="code" href="classNormal.html">Normal</a> *evalNs = <span class="keyword">new</span> <a class="code" href="classNormal.html">Normal</a>[diceu*dicev];
00218         <span class="keywordtype">int</span> i;
00219         <span class="keywordflow">for</span> (i = 0; i &lt; diceu; ++i)
00220                 ueval[i] = <a class="code" href="pbrt_8h.html#a94">Lerp</a>((<span class="keywordtype">float</span>)i / (<span class="keywordtype">float</span>)(diceu-1), <a class="code" href="classNURBS.html#r4">umin</a>, <a class="code" href="classNURBS.html#r5">umax</a>);
00221         <span class="keywordflow">for</span> (i = 0; i &lt; dicev; ++i)
00222                 veval[i] = <a class="code" href="pbrt_8h.html#a94">Lerp</a>((<span class="keywordtype">float</span>)i / (<span class="keywordtype">float</span>)(dicev-1), <a class="code" href="classNURBS.html#r6">vmin</a>, <a class="code" href="classNURBS.html#r7">vmax</a>);
00223         <span class="comment">// Evaluate NURBS over grid of points</span>
00224         memset(evalPs, 0, diceu*dicev*<span class="keyword">sizeof</span>(Point));
00225         memset(evalNs, 0, diceu*dicev*<span class="keyword">sizeof</span>(Point));
00226         <span class="keywordtype">float</span> *uvs = <span class="keyword">new</span> <span class="keywordtype">float</span>[2*diceu*dicev];
00227         <span class="comment">// Turn NURBS into triangles</span>
00228         <a class="code" href="structHomogeneous3.html">Homogeneous3</a> *Pw = (<a class="code" href="structHomogeneous3.html">Homogeneous3</a> *)<a class="code" href="classNURBS.html#r11">P</a>;
00229         <span class="keywordflow">if</span> (!<a class="code" href="classNURBS.html#r10">isHomogeneous</a>) {
00230                 Pw = (<a class="code" href="structHomogeneous3.html">Homogeneous3</a> *)alloca(<a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>*<span class="keyword">sizeof</span>(<a class="code" href="structHomogeneous3.html">Homogeneous3</a>));
00231                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classNURBS.html#r0">nu</a>*<a class="code" href="classNURBS.html#r2">nv</a>; ++i) {
00232                         Pw[i].<a class="code" href="structHomogeneous3.html#o0">x</a> = <a class="code" href="classNURBS.html#r11">P</a>[3*i];
00233                         Pw[i].<a class="code" href="structHomogeneous3.html#o1">y</a> = <a class="code" href="classNURBS.html#r11">P</a>[3*i+1];
00234                         Pw[i].<a class="code" href="structHomogeneous3.html#o2">z</a> = <a class="code" href="classNURBS.html#r11">P</a>[3*i+2];
00235                         Pw[i].<a class="code" href="structHomogeneous3.html#o3">w</a> = 1.;
00236                 }
00237         }
00238         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v = 0; v &lt; dicev; ++v) {
00239                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> u = 0; u &lt; diceu; ++u) {
00240                         uvs[2*(v*diceu+u)]   = ueval[u];
00241                         uvs[2*(v*diceu+u)+1] = veval[v];
00242         
00243                         <a class="code" href="classVector.html">Vector</a> dPdu, dPdv;
00244                         Point pt = <a class="code" href="nurbs_8cpp.html#a3">NURBSEvaluateSurface</a>(<a class="code" href="classNURBS.html#r1">uorder</a>, <a class="code" href="classNURBS.html#r8">uknot</a>, <a class="code" href="classNURBS.html#r0">nu</a>, ueval[u],
00245                                 <a class="code" href="classNURBS.html#r3">vorder</a>, <a class="code" href="classNURBS.html#r9">vknot</a>, <a class="code" href="classNURBS.html#r2">nv</a>, veval[v], Pw, &amp;dPdu, &amp;dPdv);
00246                         evalPs[v*diceu + u].<a class="code" href="classPoint.html#o0">x</a> = pt.<a class="code" href="classPoint.html#o0">x</a>;
00247                         evalPs[v*diceu + u].<a class="code" href="classPoint.html#o1">y</a> = pt.<a class="code" href="classPoint.html#o1">y</a>;
00248                         evalPs[v*diceu + u].<a class="code" href="classPoint.html#o2">z</a> = pt.<a class="code" href="classPoint.html#o2">z</a>;
00249                         evalNs[v*diceu + u] = Normal(<a class="code" href="geometry_8h.html#a14">Normalize</a>(<a class="code" href="geometry_8h.html#a6">Cross</a>(dPdu, dPdv)));
00250                 }
00251         }
00252         <span class="comment">// Generate points-polygons mesh</span>
00253         <span class="keywordtype">int</span> nTris = 2*(diceu-1)*(dicev-1);
00254         <span class="keywordtype">int</span> *vertices = <span class="keyword">new</span> <span class="keywordtype">int</span>[3 * nTris];
00255         <span class="keywordtype">int</span> *vertp = vertices;
00256         <span class="comment">// Compute the vertex offset numbers for the triangles</span>
00257         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v = 0; v &lt; dicev-1; ++v) {
00258                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> u = 0; u &lt; diceu-1; ++u) {
00259 <span class="preprocessor">        #define VN(u,v) ((v)*diceu+(u))</span>
00260 <span class="preprocessor"></span>                        *vertp++ = <a class="code" href="nurbs_8cpp.html#a0">VN</a>(u,   v);
00261                         *vertp++ = <a class="code" href="nurbs_8cpp.html#a0">VN</a>(u+1, v);
00262                         *vertp++ = <a class="code" href="nurbs_8cpp.html#a0">VN</a>(u+1, v+1);
00263         
00264                         *vertp++ = <a class="code" href="nurbs_8cpp.html#a0">VN</a>(u,   v);
00265                         *vertp++ = <a class="code" href="nurbs_8cpp.html#a0">VN</a>(u+1, v+1);
00266                         *vertp++ = <a class="code" href="nurbs_8cpp.html#a0">VN</a>(u,   v+1);
00267 <span class="preprocessor">        #undef VN</span>
00268 <span class="preprocessor"></span>                }
00269         }
00270         <span class="keywordtype">int</span> nVerts = diceu*dicev;
00271         <a class="code" href="classParamSet.html">ParamSet</a> paramSet;
00272         paramSet.<a class="code" href="classParamSet.html#a4">AddInt</a>(<span class="stringliteral">"indices"</span>, vertices, 3*nTris);
00273         paramSet.<a class="code" href="classParamSet.html#a6">AddPoint</a>(<span class="stringliteral">"P"</span>, evalPs, nVerts);
00274         paramSet.<a class="code" href="classParamSet.html#a3">AddFloat</a>(<span class="stringliteral">"uv"</span>, uvs, 2 * nVerts);
00275         paramSet.<a class="code" href="classParamSet.html#a8">AddNormal</a>(<span class="stringliteral">"N"</span>, evalNs, nVerts);
00276         refined.push_back(<a class="code" href="dynload_8h.html#a1">MakeShape</a>(<span class="stringliteral">"trianglemesh"</span>, ObjectToWorld,
00277                         reverseOrientation, paramSet));
00278         <span class="comment">// Cleanup from NURBS refinement</span>
00279         <span class="keyword">delete</span>[] uvs;
00280         <span class="keyword">delete</span>[] ueval;
00281         <span class="keyword">delete</span>[] veval;
00282         <span class="keyword">delete</span>[] evalPs;
00283         <span class="keyword">delete</span>[] evalNs;
00284         <span class="keyword">delete</span>[] vertices;
00285 }
<a name="l00286"></a><a class="code" href="nurbs_8cpp.html#a4">00286</a> <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <a class="code" href="pbrt_8h.html#a2">DLLEXPORT</a> <a class="code" href="classShape.html">Shape</a> *<a class="code" href="trianglemesh_8cpp.html#a0">CreateShape</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a> &amp;o2w,
00287                 <span class="keywordtype">bool</span> reverseOrientation, <span class="keyword">const</span> <a class="code" href="classParamSet.html">ParamSet</a> &amp;params) {
00288         <span class="keywordtype">int</span> nu = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"nu"</span>, -1);
00289         <span class="keywordtype">int</span> uorder = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"uorder"</span>, -1);
00290         <span class="keywordtype">int</span> nuknots, nvknots;
00291         <span class="keyword">const</span> <span class="keywordtype">float</span> *uknots = params.<a class="code" href="classParamSet.html#a30">FindFloat</a>(<span class="stringliteral">"uknots"</span>, &amp;nuknots);
00292         <a class="code" href="pbrt_8h.html#a14">Assert</a>(nu != -1 &amp;&amp; uorder != -1 &amp;&amp; uknots != NULL);
00293         <a class="code" href="pbrt_8h.html#a14">Assert</a>(nuknots == nu + uorder);
00294         <span class="keywordtype">float</span> u0 = params.<a class="code" href="classParamSet.html#a21">FindOneFloat</a>(<span class="stringliteral">"u0"</span>, uknots[uorder-1]);
00295         <span class="keywordtype">float</span> u1 = params.<a class="code" href="classParamSet.html#a21">FindOneFloat</a>(<span class="stringliteral">"u1"</span>, uknots[nu]);
00296 
00297         <span class="keywordtype">int</span> nv = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"nv"</span>, -1);
00298         <span class="keywordtype">int</span> vorder = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"vorder"</span>, -1);
00299         <span class="keyword">const</span> <span class="keywordtype">float</span> *vknots = params.<a class="code" href="classParamSet.html#a30">FindFloat</a>(<span class="stringliteral">"vknots"</span>, &amp;nvknots);
00300         <a class="code" href="pbrt_8h.html#a14">Assert</a>(nv != -1 &amp;&amp; vorder != -1 &amp;&amp; vknots != NULL);
00301         <a class="code" href="pbrt_8h.html#a14">Assert</a>(nvknots == nv + vorder);
00302         <span class="keywordtype">float</span> v0 = params.<a class="code" href="classParamSet.html#a21">FindOneFloat</a>(<span class="stringliteral">"v0"</span>, vknots[vorder-1]);
00303         <span class="keywordtype">float</span> v1 = params.<a class="code" href="classParamSet.html#a21">FindOneFloat</a>(<span class="stringliteral">"v1"</span>, vknots[nv]);
00304 
00305         <span class="keywordtype">bool</span> isHomogeneous = <span class="keyword">false</span>;
00306         <span class="keywordtype">int</span> npts;
00307         <span class="keyword">const</span> <span class="keywordtype">float</span> *P = (<span class="keyword">const</span> <span class="keywordtype">float</span> *)params.<a class="code" href="classParamSet.html#a33">FindPoint</a>(<span class="stringliteral">"P"</span>, &amp;npts);
00308         <span class="keywordflow">if</span> (!P) {
00309                 P = params.<a class="code" href="classParamSet.html#a30">FindFloat</a>(<span class="stringliteral">"Pw"</span>, &amp;npts);
00310                 <span class="keywordflow">if</span> (!P) <span class="keywordflow">return</span> NULL;
00311                 isHomogeneous = <span class="keyword">true</span>;
00312         }
00313         <a class="code" href="pbrt_8h.html#a14">Assert</a>(P);
00314         <a class="code" href="pbrt_8h.html#a14">Assert</a>(npts == nu*nv);
00315         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classNURBS.html">NURBS</a>(o2w, reverseOrientation, nu, uorder, uknots, u0, u1,
00316                          nv, vorder, vknots, v0, v1, (<span class="keywordtype">float</span> *)P,
00317                          isHomogeneous);
00318 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Mon Apr 25 19:00:22 2005 for pbrt by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
