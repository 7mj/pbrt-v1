<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pbrt: photonmap.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>photonmap.cpp</h1><a href="photonmap_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> * pbrt source code Copyright(c) 1998-2005 Matt Pharr and Greg Humphreys</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * All Rights Reserved.</span>
00006 <span class="comment"> * For educational use only; commercial use expressly forbidden.</span>
00007 <span class="comment"> * NO WARRANTY, express or implied, for this software.</span>
00008 <span class="comment"> * (See file License.txt for complete license)</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">// photonmap.cpp*</span>
00012 <span class="preprocessor">#include "<a class="code" href="pbrt_8h.html">pbrt.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="transport_8h.html">transport.h</a>"</span>
00014 <span class="preprocessor">#include "<a class="code" href="scene_8h.html">scene.h</a>"</span>
00015 <span class="preprocessor">#include "<a class="code" href="mc_8h.html">mc.h</a>"</span>
00016 <span class="preprocessor">#include "<a class="code" href="kdtree_8h.html">kdtree.h</a>"</span>
00017 <span class="preprocessor">#include "<a class="code" href="sampling_8h.html">sampling.h</a>"</span>
00018 <span class="comment">// Photonmap Local Declarations</span>
00019 <span class="keyword">struct </span><a class="code" href="structPhoton.html">Photon</a>;
00020 <span class="keyword">struct </span><a class="code" href="structClosePhoton.html">ClosePhoton</a>;
00021 <span class="keyword">struct </span><a class="code" href="structPhotonProcess.html">PhotonProcess</a>;
<a name="l00022"></a><a class="code" href="classPhotonIntegrator.html">00022</a> <span class="keyword">class </span><a class="code" href="classPhotonIntegrator.html">PhotonIntegrator</a> : <span class="keyword">public</span> <a class="code" href="classSurfaceIntegrator.html">SurfaceIntegrator</a> {
00023 <span class="keyword">public</span>:
00024         <span class="comment">// PhotonIntegrator Public Methods</span>
00025         <a class="code" href="classPhotonIntegrator.html">PhotonIntegrator</a>(<span class="keywordtype">int</span> ncaus, <span class="keywordtype">int</span> ndir, <span class="keywordtype">int</span> nindir, <span class="keywordtype">int</span> <a class="code" href="classPhotonIntegrator.html#r3">nLookup</a>, <span class="keywordtype">int</span> mdepth,
00026                 <span class="keywordtype">float</span> maxdist, <span class="keywordtype">bool</span> <a class="code" href="classPhotonIntegrator.html#r8">finalGather</a>, <span class="keywordtype">int</span> <a class="code" href="classPhotonIntegrator.html#r9">gatherSamples</a>,
00027                 <span class="keywordtype">bool</span> <a class="code" href="classPhotonIntegrator.html#r7">directWithPhotons</a>);
00028         <a class="code" href="classPhotonIntegrator.html#a1">~PhotonIntegrator</a>();
00029         <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="classPhotonIntegrator.html#a2">Li</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene, <span class="keyword">const</span> <a class="code" href="classRayDifferential.html">RayDifferential</a> &amp;ray,
00030                 <span class="keyword">const</span> <a class="code" href="structSample.html">Sample</a> *sample, <span class="keywordtype">float</span> *alpha) <span class="keyword">const</span>;
00031         <span class="keywordtype">void</span> <a class="code" href="classPhotonIntegrator.html#a3">RequestSamples</a>(<a class="code" href="structSample.html">Sample</a> *sample, <span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene);
00032         <span class="keywordtype">void</span> <a class="code" href="classPhotonIntegrator.html#a4">Preprocess</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *);
00033 <span class="keyword">private</span>:
00034         <span class="comment">// PhotonIntegrator Private Methods</span>
<a name="l00035"></a><a class="code" href="classPhotonIntegrator.html#h0">00035</a>         <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classPhotonIntegrator.html#h0">unsuccessful</a>(<span class="keywordtype">int</span> needed, <span class="keywordtype">int</span> found, <span class="keywordtype">int</span> shot) {
00036                 <span class="keywordflow">return</span> (found &lt; needed &amp;&amp;
00037                         (found == 0 || found &lt; shot / 1024));
00038         }
00039         <span class="keyword">static</span> <a class="code" href="classSpectrum.html">Spectrum</a> LPhoton(<a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *map,
00040                 <span class="keywordtype">int</span> nPaths, <span class="keywordtype">int</span> nLookup, <a class="code" href="classBSDF.html">BSDF</a> *bsdf, <span class="keyword">const</span> <a class="code" href="structIntersection.html">Intersection</a> &amp;isect,
00041                 <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;w, <span class="keywordtype">float</span> maxDistSquared);
00042         <span class="comment">// PhotonIntegrator Private Data</span>
<a name="l00043"></a><a class="code" href="classPhotonIntegrator.html#r1">00043</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="classPhotonIntegrator.html#r0">nCausticPhotons</a>, <a class="code" href="classPhotonIntegrator.html#r1">nIndirectPhotons</a>, <a class="code" href="classPhotonIntegrator.html#r2">nDirectPhotons</a>;
<a name="l00044"></a><a class="code" href="classPhotonIntegrator.html#r3">00044</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> nLookup;
<a name="l00045"></a><a class="code" href="classPhotonIntegrator.html#r4">00045</a>         <span class="keyword">mutable</span> <span class="keywordtype">int</span> <a class="code" href="classPhotonIntegrator.html#r4">specularDepth</a>;
<a name="l00046"></a><a class="code" href="classPhotonIntegrator.html#r5">00046</a>         <span class="keywordtype">int</span> <a class="code" href="classPhotonIntegrator.html#r5">maxSpecularDepth</a>;
<a name="l00047"></a><a class="code" href="classPhotonIntegrator.html#r6">00047</a>         <span class="keywordtype">float</span> <a class="code" href="classPhotonIntegrator.html#r6">maxDistSquared</a>;
<a name="l00048"></a><a class="code" href="classPhotonIntegrator.html#r8">00048</a>         <span class="keywordtype">bool</span> directWithPhotons, finalGather;
<a name="l00049"></a><a class="code" href="classPhotonIntegrator.html#r9">00049</a>         <span class="keywordtype">int</span> gatherSamples;
00050         <span class="comment">// Declare sample parameters for light source sampling</span>
<a name="l00051"></a><a class="code" href="classPhotonIntegrator.html#r10">00051</a>         <span class="keywordtype">int</span> *<a class="code" href="classPhotonIntegrator.html#r10">lightSampleOffset</a>, <a class="code" href="classPhotonIntegrator.html#r11">lightNumOffset</a>;
<a name="l00052"></a><a class="code" href="classPhotonIntegrator.html#r12">00052</a>         <span class="keywordtype">int</span> *<a class="code" href="classPhotonIntegrator.html#r12">bsdfSampleOffset</a>, *<a class="code" href="classPhotonIntegrator.html#r13">bsdfComponentOffset</a>;
<a name="l00053"></a><a class="code" href="classPhotonIntegrator.html#r14">00053</a>         <span class="keywordtype">int</span> <a class="code" href="classPhotonIntegrator.html#r14">gatherSampleOffset</a>, <a class="code" href="classPhotonIntegrator.html#r15">gatherComponentOffset</a>;
<a name="l00054"></a><a class="code" href="classPhotonIntegrator.html#r18">00054</a>         <span class="keywordtype">int</span> <a class="code" href="classPhotonIntegrator.html#r16">nCausticPaths</a>, <a class="code" href="classPhotonIntegrator.html#r17">nDirectPaths</a>, <a class="code" href="classPhotonIntegrator.html#r18">nIndirectPaths</a>;
<a name="l00055"></a><a class="code" href="classPhotonIntegrator.html#r19">00055</a>         <span class="keyword">mutable</span> <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *<a class="code" href="classPhotonIntegrator.html#r19">causticMap</a>;
<a name="l00056"></a><a class="code" href="classPhotonIntegrator.html#r20">00056</a>         <span class="keyword">mutable</span> <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *<a class="code" href="classPhotonIntegrator.html#r20">directMap</a>;
<a name="l00057"></a><a class="code" href="classPhotonIntegrator.html#r21">00057</a>         <span class="keyword">mutable</span> <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *<a class="code" href="classPhotonIntegrator.html#r21">indirectMap</a>;
00058 };
00059 <span class="keyword">struct </span><a class="code" href="structPhoton.html">Photon</a> {
00060         <span class="comment">// Photon Constructor</span>
<a name="l00061"></a><a class="code" href="structPhoton.html#a2">00061</a>         <a class="code" href="structPhoton.html#a1">Photon</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;pp, <span class="keyword">const</span> <a class="code" href="classSpectrum.html">Spectrum</a> &amp;wt, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;w)
00062                 : <a class="code" href="structPhoton.html#o0">p</a>(pp), <a class="code" href="structPhoton.html#o1">alpha</a>(wt), <a class="code" href="structPhoton.html#o2">wi</a>(w) {
00063         }
<a name="l00064"></a><a class="code" href="structPhoton.html#a3">00064</a>         <a class="code" href="structPhoton.html#a1">Photon</a>() { }
<a name="l00065"></a><a class="code" href="structPhoton.html#o0">00065</a>         <a class="code" href="classPoint.html">Point</a> <a class="code" href="structPhoton.html#o0">p</a>;
<a name="l00066"></a><a class="code" href="structPhoton.html#o1">00066</a>         <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="structPhoton.html#o1">alpha</a>;
<a name="l00067"></a><a class="code" href="structPhoton.html#o2">00067</a>         <a class="code" href="classVector.html">Vector</a> <a class="code" href="structPhoton.html#o2">wi</a>;
00068 };
00069 <span class="keyword">struct </span><a class="code" href="structPhotonProcess.html">PhotonProcess</a> {
00070         <span class="comment">// PhotonProcess Public Methods</span>
00071         <a class="code" href="structPhotonProcess.html">PhotonProcess</a>(<a class="code" href="pbrt_8h.html#a51">u_int</a> mp, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p);
00072         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> &amp;photon, <span class="keywordtype">float</span> dist2, <span class="keywordtype">float</span> &amp;maxDistSquared) <span class="keyword">const</span>;
<a name="l00073"></a><a class="code" href="structPhotonProcess.html#o4">00073</a>         <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p;
<a name="l00074"></a><a class="code" href="structPhotonProcess.html#o5">00074</a>         <a class="code" href="structClosePhoton.html">ClosePhoton</a> *<a class="code" href="structPhotonProcess.html#o1">photons</a>;
<a name="l00075"></a><a class="code" href="structPhotonProcess.html#o2">00075</a>         <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structPhotonProcess.html#o2">nLookup</a>;
<a name="l00076"></a><a class="code" href="structPhotonProcess.html#o3">00076</a>         <span class="keyword">mutable</span> <a class="code" href="pbrt_8h.html#a51">u_int</a> <a class="code" href="structPhotonProcess.html#o3">foundPhotons</a>;
00077 };
00078 <span class="keyword">struct </span><a class="code" href="structClosePhoton.html">ClosePhoton</a> {
<a name="l00079"></a><a class="code" href="structClosePhoton.html#a2">00079</a>         <a class="code" href="structClosePhoton.html">ClosePhoton</a>(<span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> *p = NULL,
00080                     <span class="keywordtype">float</span> md2 = INFINITY) {
00081                 <a class="code" href="structClosePhoton.html#o0">photon</a> = p;
00082                 <a class="code" href="structClosePhoton.html#o1">distanceSquared</a> = md2;
00083         }
<a name="l00084"></a><a class="code" href="structClosePhoton.html#a3">00084</a>         <span class="keywordtype">bool</span> <a class="code" href="structClosePhoton.html#a1">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="structClosePhoton.html">ClosePhoton</a> &amp;p2)<span class="keyword"> const </span>{
00085                 <span class="keywordflow">return</span> <a class="code" href="structClosePhoton.html#o1">distanceSquared</a> == p2.<a class="code" href="structClosePhoton.html#o1">distanceSquared</a> ? (<a class="code" href="structClosePhoton.html#o0">photon</a> &lt; p2.<a class="code" href="structClosePhoton.html#o0">photon</a>) :
00086                         <a class="code" href="structClosePhoton.html#o1">distanceSquared</a> &lt; p2.<a class="code" href="structClosePhoton.html#o1">distanceSquared</a>;
00087         }
<a name="l00088"></a><a class="code" href="structClosePhoton.html#o2">00088</a>         <span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> *<a class="code" href="structClosePhoton.html#o0">photon</a>;
<a name="l00089"></a><a class="code" href="structClosePhoton.html#o1">00089</a>         <span class="keywordtype">float</span> <a class="code" href="structClosePhoton.html#o1">distanceSquared</a>;
00090 };
00091 <span class="comment">// Photonmap Method Definitions</span>
<a name="l00092"></a><a class="code" href="classPhotonIntegrator.html#a0">00092</a> <a class="code" href="classPhotonIntegrator.html#a0">PhotonIntegrator::PhotonIntegrator</a>(<span class="keywordtype">int</span> ncaus, <span class="keywordtype">int</span> ndir, <span class="keywordtype">int</span> nind,
00093                 <span class="keywordtype">int</span> nl, <span class="keywordtype">int</span> mdepth, <span class="keywordtype">float</span> mdist, <span class="keywordtype">bool</span> fg,
00094                 <span class="keywordtype">int</span> gs, <span class="keywordtype">bool</span> dp) {
00095         <a class="code" href="classPhotonIntegrator.html#r0">nCausticPhotons</a> = ncaus;
00096         <a class="code" href="classPhotonIntegrator.html#r1">nIndirectPhotons</a> = nind;
00097         <a class="code" href="classPhotonIntegrator.html#r2">nDirectPhotons</a> = ndir;
00098         <a class="code" href="classPhotonIntegrator.html#r3">nLookup</a> = nl;
00099         <a class="code" href="classPhotonIntegrator.html#r6">maxDistSquared</a> = mdist * mdist;
00100         <a class="code" href="classPhotonIntegrator.html#r5">maxSpecularDepth</a> = mdepth;
00101         <a class="code" href="classPhotonIntegrator.html#r19">causticMap</a> = <a class="code" href="classPhotonIntegrator.html#r20">directMap</a> = <a class="code" href="classPhotonIntegrator.html#r21">indirectMap</a> = NULL;
00102         <a class="code" href="classPhotonIntegrator.html#r4">specularDepth</a> = 0;
00103         <a class="code" href="classPhotonIntegrator.html#r8">finalGather</a> = fg;
00104         <a class="code" href="classPhotonIntegrator.html#r9">gatherSamples</a> = gs;
00105         <a class="code" href="classPhotonIntegrator.html#r7">directWithPhotons</a> = dp;
00106 }
<a name="l00107"></a><a class="code" href="classPhotonIntegrator.html#a1">00107</a> <a class="code" href="classPhotonIntegrator.html#a1">PhotonIntegrator::~PhotonIntegrator</a>() {
00108         <span class="keyword">delete</span> <a class="code" href="classPhotonIntegrator.html#r19">causticMap</a>;
00109         <span class="keyword">delete</span> <a class="code" href="classPhotonIntegrator.html#r20">directMap</a>;
00110         <span class="keyword">delete</span> <a class="code" href="classPhotonIntegrator.html#r21">indirectMap</a>;
00111 }
<a name="l00112"></a><a class="code" href="classPhotonIntegrator.html#a3">00112</a> <span class="keywordtype">void</span> <a class="code" href="classPhotonIntegrator.html#a3">PhotonIntegrator::RequestSamples</a>(<a class="code" href="structSample.html">Sample</a> *sample,
00113                 <span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene) {
00114         <span class="comment">// Allocate and request samples for sampling all lights</span>
00115         <a class="code" href="pbrt_8h.html#a51">u_int</a> nLights = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size();
00116         <a class="code" href="classPhotonIntegrator.html#r10">lightSampleOffset</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>[nLights];
00117         <a class="code" href="classPhotonIntegrator.html#r12">bsdfSampleOffset</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>[nLights];
00118         <a class="code" href="classPhotonIntegrator.html#r13">bsdfComponentOffset</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>[nLights];
00119         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; nLights; ++i) {
00120                 <span class="keyword">const</span> <a class="code" href="classLight.html">Light</a> *light = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[i];
00121                 <span class="keywordtype">int</span> lightSamples =
00122                         scene-&gt;<a class="code" href="classScene.html#o6">sampler</a>-&gt;<a class="code" href="classSampler.html#a4">RoundSize</a>(light-&gt;<a class="code" href="classLight.html#o0">nSamples</a>);
00123                 <a class="code" href="classPhotonIntegrator.html#r10">lightSampleOffset</a>[i] = sample-&gt;<a class="code" href="structSample.html#a2">Add2D</a>(lightSamples);
00124                 <a class="code" href="classPhotonIntegrator.html#r12">bsdfSampleOffset</a>[i] = sample-&gt;<a class="code" href="structSample.html#a2">Add2D</a>(lightSamples);
00125                 <a class="code" href="classPhotonIntegrator.html#r13">bsdfComponentOffset</a>[i] = sample-&gt;<a class="code" href="structSample.html#a1">Add1D</a>(lightSamples);
00126         }
00127         <a class="code" href="classPhotonIntegrator.html#r11">lightNumOffset</a> = -1;
00128         <span class="keywordflow">if</span> (<a class="code" href="classPhotonIntegrator.html#r8">finalGather</a>) {
00129                 <a class="code" href="classPhotonIntegrator.html#r9">gatherSamples</a> = scene-&gt;<a class="code" href="classScene.html#o6">sampler</a>-&gt;<a class="code" href="classSampler.html#a4">RoundSize</a>(<a class="code" href="classPhotonIntegrator.html#r9">gatherSamples</a>);
00130                 <a class="code" href="classPhotonIntegrator.html#r14">gatherSampleOffset</a> = sample-&gt;<a class="code" href="structSample.html#a2">Add2D</a>(<a class="code" href="classPhotonIntegrator.html#r9">gatherSamples</a>);
00131                 <a class="code" href="classPhotonIntegrator.html#r15">gatherComponentOffset</a> = sample-&gt;<a class="code" href="structSample.html#a1">Add1D</a>(<a class="code" href="classPhotonIntegrator.html#r9">gatherSamples</a>);
00132         }
00133 }
<a name="l00134"></a><a class="code" href="classPhotonIntegrator.html#a4">00134</a> <span class="keywordtype">void</span> <a class="code" href="classPhotonIntegrator.html#a4">PhotonIntegrator::Preprocess</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene) {
00135         <span class="keywordflow">if</span> (scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size() == 0) <span class="keywordflow">return</span>;
00136         <a class="code" href="structProgressReporter.html">ProgressReporter</a> progress(<a class="code" href="classPhotonIntegrator.html#r0">nCausticPhotons</a>+<a class="code" href="classPhotonIntegrator.html#r2">nDirectPhotons</a>+ <span class="comment">// NOBOOK</span>
00137                 <a class="code" href="classPhotonIntegrator.html#r1">nIndirectPhotons</a>, <span class="stringliteral">"Shooting photons"</span>); <span class="comment">// NOBOOK</span>
00138         vector&lt;Photon&gt; causticPhotons;
00139         vector&lt;Photon&gt; directPhotons;
00140         vector&lt;Photon&gt; indirectPhotons;
00141         causticPhotons.reserve(<a class="code" href="classPhotonIntegrator.html#r0">nCausticPhotons</a>); <span class="comment">// NOBOOK</span>
00142         directPhotons.reserve(<a class="code" href="classPhotonIntegrator.html#r2">nDirectPhotons</a>); <span class="comment">// NOBOOK</span>
00143         indirectPhotons.reserve(nIndirectPhotons); <span class="comment">// NOBOOK</span>
00144         <span class="comment">// Initialize photon shooting statistics</span>
00145         <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> nshot(<span class="stringliteral">"Photon Map"</span>,
00146                 <span class="stringliteral">"Number of photons shot from lights"</span>);
00147         <span class="keywordtype">bool</span> causticDone = (<a class="code" href="classPhotonIntegrator.html#r0">nCausticPhotons</a> == 0);
00148         <span class="keywordtype">bool</span> directDone = (<a class="code" href="classPhotonIntegrator.html#r2">nDirectPhotons</a> == 0);
00149         <span class="keywordtype">bool</span> indirectDone = (nIndirectPhotons == 0);
00150         <span class="keywordflow">while</span> (!causticDone || !directDone || !indirectDone) {
00151                 ++nshot;
00152                 <span class="comment">// Give up if we're not storing enough photons</span>
00153                 <span class="keywordflow">if</span> (nshot &gt; 500000 &amp;&amp;
00154                         (<a class="code" href="classPhotonIntegrator.html#h0">unsuccessful</a>(nCausticPhotons,
00155                                       causticPhotons.size(),
00156                                                   nshot) ||
00157                          unsuccessful(nDirectPhotons,
00158                                       directPhotons.size(),
00159                                                   nshot) ||
00160                          unsuccessful(nIndirectPhotons,
00161                                       indirectPhotons.size(),
00162                                                   nshot))) {
00163                         <a class="code" href="util_8cpp.html#a16">Error</a>(<span class="stringliteral">"Unable to store enough photons.  Giving up.\n"</span>);
00164                         <span class="keywordflow">return</span>;
00165                 }
00166                 <span class="comment">// Trace a photon path and store contribution</span>
00167                 <span class="comment">// Choose 4D sample values for photon</span>
00168                 <span class="keywordtype">float</span> u[4];
00169                 u[0] = (<span class="keywordtype">float</span>)<a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 2);
00170                 u[1] = (<span class="keywordtype">float</span>)<a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 3);
00171                 u[2] = (<span class="keywordtype">float</span>)<a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 5);
00172                 u[3] = (<span class="keywordtype">float</span>)<a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 7);
00173                 <span class="comment">// Choose light to shoot photon from</span>
00174                 <span class="keywordtype">int</span> nLights = int(scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size());
00175                 <span class="keywordtype">int</span> lightNum =
00176                         min(<a class="code" href="pbrt_8h.html#a106">Floor2Int</a>(nLights * (<span class="keywordtype">float</span>)<a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 11)),
00177                         nLights-1);
00178                 <a class="code" href="classLight.html">Light</a> *light = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[lightNum];
00179                 <span class="keywordtype">float</span> lightPdf = 1.f / nLights;
00180                 <span class="comment">// Generate _photonRay_ from light source and initialize _alpha_</span>
00181                 <a class="code" href="classRayDifferential.html">RayDifferential</a> photonRay;
00182                 <span class="keywordtype">float</span> pdf;
00183                 <a class="code" href="classSpectrum.html">Spectrum</a> alpha =
00184                         light-&gt;<a class="code" href="classLight.html#a2">Sample_L</a>(scene, u[0], u[1], u[2], u[3],
00185                                 &amp;photonRay, &amp;pdf);
00186                 <span class="keywordflow">if</span> (pdf == 0.f || alpha.<a class="code" href="classSpectrum.html#a15">Black</a>()) <span class="keywordflow">continue</span>;
00187                 alpha /= pdf * lightPdf;
00188                 <span class="keywordflow">if</span> (!alpha.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00189                         <span class="comment">// Follow photon path through scene and record intersections</span>
00190                         <span class="keywordtype">bool</span> specularPath = <span class="keyword">false</span>;
00191                         <a class="code" href="structIntersection.html">Intersection</a> photonIsect;
00192                         <span class="keywordtype">int</span> nIntersections = 0;
00193                         <span class="keywordflow">while</span> (scene-&gt;<a class="code" href="classScene.html#a3">Intersect</a>(photonRay, &amp;photonIsect)) {
00194                                 ++nIntersections;
00195                                 <span class="comment">// Handle photon/surface intersection</span>
00196                                 alpha *= scene-&gt;<a class="code" href="classScene.html#a7">Transmittance</a>(photonRay);
00197                                 <a class="code" href="classVector.html">Vector</a> wo = -photonRay.<a class="code" href="classRay.html#o1">d</a>;
00198                                 <a class="code" href="classBSDF.html">BSDF</a> *photonBSDF = photonIsect.<a class="code" href="structIntersection.html#a1">GetBSDF</a>(photonRay);
00199                                 <a class="code" href="reflection_8h.html#a17">BxDFType</a> specularType = <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a2">BSDF_REFLECTION</a> |
00200                                         <a class="code" href="reflection_8h.html#a17a3">BSDF_TRANSMISSION</a> | <a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>);
00201                                 <span class="keywordtype">bool</span> hasNonSpecular = (photonBSDF-&gt;<a class="code" href="classBSDF.html#a5">NumComponents</a>() &gt;
00202                                         photonBSDF-&gt;<a class="code" href="classBSDF.html#a5">NumComponents</a>(specularType));
00203                                 <span class="keywordflow">if</span> (hasNonSpecular) {
00204                                         <span class="comment">// Deposit photon at surface</span>
00205                                         <a class="code" href="structPhoton.html">Photon</a> photon(photonIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, alpha, wo);
00206                                         <span class="keywordflow">if</span> (nIntersections == 1) {
00207                                                 <span class="comment">// Process direct lighting photon intersection</span>
00208                                                 <span class="keywordflow">if</span> (!directDone) {
00209                                                         directPhotons.push_back(photon);
00210                                                         <span class="keywordflow">if</span> (directPhotons.size() == nDirectPhotons) {
00211                                                                 directDone = <span class="keyword">true</span>;
00212                                                                 <a class="code" href="classPhotonIntegrator.html#r17">nDirectPaths</a> = (<span class="keywordtype">int</span>)nshot;
00213                                                                 <a class="code" href="classPhotonIntegrator.html#r20">directMap</a> =
00214                                                                         <span class="keyword">new</span> <a class="code" href="classKdTree.html">KdTree</a>&lt;<a class="code" href="structPhoton.html">Photon</a>,
00215                                                                                            <a class="code" href="structPhotonProcess.html">PhotonProcess</a>&gt;(directPhotons);
00216                                                         }
00217                                                         progress.<a class="code" href="structProgressReporter.html#a2">Update</a>(); <span class="comment">// NOBOOK</span>
00218                                                 }
00219                                         }
00220                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (specularPath) {
00221                                                 <span class="comment">// Process caustic photon intersection</span>
00222                                                 <span class="keywordflow">if</span> (!causticDone) {
00223                                                         causticPhotons.push_back(photon);
00224                                                         <span class="keywordflow">if</span> (causticPhotons.size() == nCausticPhotons) {
00225                                                                 causticDone = <span class="keyword">true</span>;
00226                                                                 <a class="code" href="classPhotonIntegrator.html#r16">nCausticPaths</a> = (<span class="keywordtype">int</span>)nshot;
00227                                                                 <a class="code" href="classPhotonIntegrator.html#r19">causticMap</a> =
00228                                                                         <span class="keyword">new</span> <a class="code" href="classKdTree.html">KdTree</a>&lt;<a class="code" href="structPhoton.html">Photon</a>,
00229                                                                                        <a class="code" href="structPhotonProcess.html">PhotonProcess</a>&gt;(causticPhotons);
00230                                                         }
00231                                                         progress.<a class="code" href="structProgressReporter.html#a2">Update</a>();
00232                                                 }
00233                                         }
00234                                         <span class="keywordflow">else</span> {
00235                                                 <span class="comment">// Process indirect lighting photon intersection</span>
00236                                                 <span class="keywordflow">if</span> (!indirectDone) {
00237                                                         indirectPhotons.push_back(photon);
00238                                                         <span class="keywordflow">if</span> (indirectPhotons.size() == nIndirectPhotons) {
00239                                                                 indirectDone = <span class="keyword">true</span>;
00240                                                                 <a class="code" href="classPhotonIntegrator.html#r18">nIndirectPaths</a> = (<span class="keywordtype">int</span>)nshot;
00241                                                                 <a class="code" href="classPhotonIntegrator.html#r21">indirectMap</a> =
00242                                                                         <span class="keyword">new</span> <a class="code" href="classKdTree.html">KdTree</a>&lt;<a class="code" href="structPhoton.html">Photon</a>,
00243                                                                                            <a class="code" href="structPhotonProcess.html">PhotonProcess</a>&gt;(indirectPhotons);
00244                                                         }
00245                                                         progress.<a class="code" href="structProgressReporter.html#a2">Update</a>();
00246                                                 }
00247                                         }
00248                                 }
00249                                 <span class="comment">// Sample new photon ray direction</span>
00250                                 <a class="code" href="classVector.html">Vector</a> wi;
00251                                 <span class="keywordtype">float</span> pdf;
00252                                 <a class="code" href="reflection_8h.html#a17">BxDFType</a> flags;
00253                                 <span class="comment">// Get random numbers for sampling outgoing photon direction</span>
00254                                 <span class="keywordtype">float</span> u1, u2, u3;
00255                                 <span class="keywordflow">if</span> (nIntersections == 1) {
00256                                         u1 = (<span class="keywordtype">float</span>)<a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 13);
00257                                         u2 = (<span class="keywordtype">float</span>)<a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 17);
00258                                         u3 = (<span class="keywordtype">float</span>)<a class="code" href="sampling_8h.html#a4">RadicalInverse</a>((<span class="keywordtype">int</span>)nshot+1, 19);
00259                                 }
00260                                 <span class="keywordflow">else</span> {
00261                                         u1 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00262                                         u2 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00263                                         u3 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00264                                 }
00265                                 <a class="code" href="classSpectrum.html">Spectrum</a> fr = photonBSDF-&gt;<a class="code" href="classBSDF.html#a0">Sample_f</a>(wo, &amp;wi, u1, u2, u3,
00266                                         &amp;pdf, <a class="code" href="reflection_8h.html#a17a10">BSDF_ALL</a>, &amp;flags);
00267                                 <span class="keywordflow">if</span> (fr.<a class="code" href="classSpectrum.html#a15">Black</a>() || pdf == 0.f)
00268                                         <span class="keywordflow">break</span>;
00269                                 specularPath = (nIntersections == 1 || specularPath) &amp;&amp;
00270                                         ((flags &amp; <a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>) != 0);
00271                                 alpha *= fr * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, photonBSDF-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>) / pdf;
00272                                 photonRay = <a class="code" href="classRayDifferential.html">RayDifferential</a>(photonIsect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, wi);
00273                                 <span class="comment">// Possibly terminate photon path</span>
00274                                 <span class="keywordflow">if</span> (nIntersections &gt; 3) {
00275                                         <span class="keywordtype">float</span> continueProbability = .5f;
00276                                         <span class="keywordflow">if</span> (<a class="code" href="pbrt_8h.html#a108">RandomFloat</a>() &gt; continueProbability)
00277                                                 <span class="keywordflow">break</span>;
00278                                         alpha /= continueProbability;
00279                                 }
00280                         }
00281                 }
00282                 <a class="code" href="classBSDF.html#e1">BSDF::FreeAll</a>();
00283         }
00284         progress.<a class="code" href="structProgressReporter.html#a3">Done</a>(); <span class="comment">// NOBOOK</span>
00285 }
<a name="l00286"></a><a class="code" href="classPhotonIntegrator.html#a2">00286</a> <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="classPhotonIntegrator.html#a2">PhotonIntegrator::Li</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene,
00287                 <span class="keyword">const</span> <a class="code" href="classRayDifferential.html">RayDifferential</a> &amp;ray, <span class="keyword">const</span> <a class="code" href="structSample.html">Sample</a> *sample,
00288                 <span class="keywordtype">float</span> *alpha)<span class="keyword"> const </span>{
00289         <span class="comment">// Compute reflected radiance with photon map</span>
00290         <a class="code" href="classSpectrum.html">Spectrum</a> L(0.);
00291         <a class="code" href="structIntersection.html">Intersection</a> isect;
00292         <span class="keywordflow">if</span> (scene-&gt;<a class="code" href="classScene.html#a3">Intersect</a>(ray, &amp;isect)) {
00293                 <span class="keywordflow">if</span> (alpha) *alpha = 1.;
00294                 <a class="code" href="classVector.html">Vector</a> wo = -ray.<a class="code" href="classRay.html#o1">d</a>;
00295                 <span class="comment">// Compute emitted light if ray hit an area light source</span>
00296                 L += isect.<a class="code" href="structIntersection.html#a2">Le</a>(wo);
00297                 <span class="comment">// Evaluate BSDF at hit point</span>
00298                 <a class="code" href="classBSDF.html">BSDF</a> *bsdf = isect.<a class="code" href="structIntersection.html#a1">GetBSDF</a>(ray);
00299                 <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>;
00300                 <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;n = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>;
00301                 <span class="comment">// Compute direct lighting for photon map integrator</span>
00302                 <span class="keywordflow">if</span> (<a class="code" href="classPhotonIntegrator.html#r7">directWithPhotons</a>)
00303                         L += <a class="code" href="classPhotonIntegrator.html#h1">LPhoton</a>(<a class="code" href="classPhotonIntegrator.html#r20">directMap</a>, <a class="code" href="classPhotonIntegrator.html#r17">nDirectPaths</a>, <a class="code" href="classPhotonIntegrator.html#r3">nLookup</a>,
00304                                 bsdf, isect, wo, <a class="code" href="classPhotonIntegrator.html#r6">maxDistSquared</a>);
00305                 <span class="keywordflow">else</span>
00306                         L += <a class="code" href="transport_8h.html#a0">UniformSampleAllLights</a>(scene, p, n,
00307                                 wo, bsdf, sample,
00308                                 <a class="code" href="classPhotonIntegrator.html#r10">lightSampleOffset</a>, <a class="code" href="classPhotonIntegrator.html#r12">bsdfSampleOffset</a>,
00309                                 <a class="code" href="classPhotonIntegrator.html#r13">bsdfComponentOffset</a>);
00310                 
00311                 <span class="comment">// Compute indirect lighting for photon map integrator</span>
00312                 L += LPhoton(<a class="code" href="classPhotonIntegrator.html#r19">causticMap</a>, <a class="code" href="classPhotonIntegrator.html#r16">nCausticPaths</a>, <a class="code" href="classPhotonIntegrator.html#r3">nLookup</a>, bsdf,
00313                         isect, wo, <a class="code" href="classPhotonIntegrator.html#r6">maxDistSquared</a>);
00314                 <span class="keywordflow">if</span> (<a class="code" href="classPhotonIntegrator.html#r8">finalGather</a>) {
00315                         <span class="comment">// Do one-bounce final gather for photon map</span>
00316                         <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="classPhotonIntegrator.html#a2">Li</a>(0.);
00317                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classPhotonIntegrator.html#r9">gatherSamples</a>; ++i) {
00318                                 <span class="comment">// Sample random direction for final gather ray</span>
00319                                 <a class="code" href="classVector.html">Vector</a> wi;
00320                                 <span class="keywordtype">float</span> u1 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[<a class="code" href="classPhotonIntegrator.html#r14">gatherSampleOffset</a>][2*i];
00321                                 <span class="keywordtype">float</span> u2 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[<a class="code" href="classPhotonIntegrator.html#r14">gatherSampleOffset</a>][2*i+1];
00322                                 <span class="keywordtype">float</span> u3 = sample-&gt;<a class="code" href="structSample.html#o7">oneD</a>[<a class="code" href="classPhotonIntegrator.html#r15">gatherComponentOffset</a>][i];
00323                                 <span class="keywordtype">float</span> pdf;
00324                                 <a class="code" href="classSpectrum.html">Spectrum</a> fr = bsdf-&gt;<a class="code" href="classBSDF.html#a0">Sample_f</a>(wo, &amp;wi, u1, u2, u3,
00325                                         &amp;pdf, <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a10">BSDF_ALL</a> &amp; (~<a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>)));
00326                                 <span class="keywordflow">if</span> (fr.<a class="code" href="classSpectrum.html#a15">Black</a>() || pdf == 0.f) <span class="keywordflow">continue</span>;
00327                                 <a class="code" href="classRayDifferential.html">RayDifferential</a> bounceRay(p, wi);
00328                                 <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> gatherRays(<span class="stringliteral">"Photon Map"</span>, <span class="comment">// NOBOOK</span>
00329                                         <span class="stringliteral">"Final gather rays traced"</span>); <span class="comment">// NOBOOK</span>
00330                                 ++gatherRays; <span class="comment">// NOBOOK</span>
00331                                 <a class="code" href="structIntersection.html">Intersection</a> gatherIsect;
00332                                 <span class="keywordflow">if</span> (scene-&gt;<a class="code" href="classScene.html#a3">Intersect</a>(bounceRay, &amp;gatherIsect)) {
00333                                         <span class="comment">// Compute exitant radiance at final gather intersection</span>
00334                                         <a class="code" href="classBSDF.html">BSDF</a> *gatherBSDF = gatherIsect.<a class="code" href="structIntersection.html#a1">GetBSDF</a>(bounceRay);
00335                                         <a class="code" href="classVector.html">Vector</a> bounceWo = -bounceRay.<a class="code" href="classRay.html#o1">d</a>;
00336                                         <a class="code" href="classSpectrum.html">Spectrum</a> Lindir =
00337                                                 LPhoton(<a class="code" href="classPhotonIntegrator.html#r20">directMap</a>, <a class="code" href="classPhotonIntegrator.html#r17">nDirectPaths</a>, <a class="code" href="classPhotonIntegrator.html#r3">nLookup</a>,
00338                                                         gatherBSDF, gatherIsect, bounceWo, <a class="code" href="classPhotonIntegrator.html#r6">maxDistSquared</a>) +
00339                                                 LPhoton(<a class="code" href="classPhotonIntegrator.html#r21">indirectMap</a>, <a class="code" href="classPhotonIntegrator.html#r18">nIndirectPaths</a>, <a class="code" href="classPhotonIntegrator.html#r3">nLookup</a>,
00340                                                         gatherBSDF, gatherIsect, bounceWo, <a class="code" href="classPhotonIntegrator.html#r6">maxDistSquared</a>) +
00341                                                 LPhoton(<a class="code" href="classPhotonIntegrator.html#r19">causticMap</a>, <a class="code" href="classPhotonIntegrator.html#r16">nCausticPaths</a>, <a class="code" href="classPhotonIntegrator.html#r3">nLookup</a>,
00342                                                         gatherBSDF, gatherIsect, bounceWo, <a class="code" href="classPhotonIntegrator.html#r6">maxDistSquared</a>);
00343                                         Lindir *= scene-&gt;<a class="code" href="classScene.html#a7">Transmittance</a>(bounceRay);
00344                                         Li += fr * Lindir * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n) / pdf;
00345                                 }
00346                         }
00347                         L += Li / float(gatherSamples);
00348                 }
00349                 <span class="keywordflow">else</span>
00350                         L += LPhoton(<a class="code" href="classPhotonIntegrator.html#r21">indirectMap</a>, <a class="code" href="classPhotonIntegrator.html#r18">nIndirectPaths</a>, <a class="code" href="classPhotonIntegrator.html#r3">nLookup</a>,
00351                                 bsdf, isect, wo, <a class="code" href="classPhotonIntegrator.html#r6">maxDistSquared</a>);
00352                 <span class="keywordflow">if</span> (<a class="code" href="classPhotonIntegrator.html#r4">specularDepth</a>++ &lt; <a class="code" href="classPhotonIntegrator.html#r5">maxSpecularDepth</a>) {
00353                         <a class="code" href="classVector.html">Vector</a> wi;
00354                         <span class="comment">// Trace rays for specular reflection and refraction</span>
00355                         <a class="code" href="classSpectrum.html">Spectrum</a> f = bsdf-&gt;<a class="code" href="classBSDF.html#a0">Sample_f</a>(wo, &amp;wi,
00356                                 <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a2">BSDF_REFLECTION</a> | <a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>));
00357                         <span class="keywordflow">if</span> (!f.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00358                                 <span class="comment">// Compute ray differential _rd_ for specular reflection</span>
00359                                 <a class="code" href="classRayDifferential.html">RayDifferential</a> rd(p, wi);
00360                                 rd.<a class="code" href="classRayDifferential.html#o0">hasDifferentials</a> = <span class="keyword">true</span>;
00361                                 rd.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o0">o</a> = p + isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o9">dpdx</a>;
00362                                 rd.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o0">o</a> = p + isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o10">dpdy</a>;
00363                                 <span class="comment">// Compute differential reflected directions</span>
00364                                 <a class="code" href="classNormal.html">Normal</a> dndx = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o7">dndu</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o11">dudx</a> +
00365                                         bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o8">dndv</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o12">dvdx</a>;
00366                                 <a class="code" href="classNormal.html">Normal</a> dndy = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o7">dndu</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o13">dudy</a> +
00367                                         bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o8">dndv</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o14">dvdy</a>;
00368                                 <a class="code" href="classVector.html">Vector</a> dwodx = -ray.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o1">d</a> - wo, dwody = -ray.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o1">d</a> - wo;
00369                                 <span class="keywordtype">float</span> dDNdx = <a class="code" href="geometry_8h.html#a17">Dot</a>(dwodx, n) + <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, dndx);
00370                                 <span class="keywordtype">float</span> dDNdy = <a class="code" href="geometry_8h.html#a17">Dot</a>(dwody, n) + <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, dndy);
00371                                 rd.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o1">d</a> = wi -
00372                                           dwodx + 2 * <a class="code" href="classVector.html">Vector</a>(<a class="code" href="geometry_8h.html#a17">Dot</a>(wo, n) * dndx +
00373                                                   dDNdx * n);
00374                                 rd.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o1">d</a> = wi -
00375                                           dwody + 2 * Vector(<a class="code" href="geometry_8h.html#a17">Dot</a>(wo, n) * dndy +
00376                                                   dDNdy * n);
00377                                 L += scene-&gt;<a class="code" href="classScene.html#a6">Li</a>(rd, sample) * f * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n);
00378                         }
00379                         f = bsdf-&gt;<a class="code" href="classBSDF.html#a0">Sample_f</a>(wo, &amp;wi,
00380                                 <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a3">BSDF_TRANSMISSION</a> | <a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>));
00381                         <span class="keywordflow">if</span> (!f.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00382                                 <span class="comment">// Compute ray differential _rd_ for specular transmission</span>
00383                                 <a class="code" href="classRayDifferential.html">RayDifferential</a> rd(p, wi);
00384                                 rd.<a class="code" href="classRayDifferential.html#o0">hasDifferentials</a> = <span class="keyword">true</span>;
00385                                 rd.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o0">o</a> = p + isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o9">dpdx</a>;
00386                                 rd.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o0">o</a> = p + isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o10">dpdy</a>;
00387                                 
00388                                 <span class="keywordtype">float</span> eta = bsdf-&gt;<a class="code" href="classBSDF.html#o1">eta</a>;
00389                                 <a class="code" href="classVector.html">Vector</a> w = -wo;
00390                                 <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(wo, n) &lt; 0) eta = 1.f / eta;
00391                                 
00392                                 <a class="code" href="classNormal.html">Normal</a> dndx = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o7">dndu</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o11">dudx</a> + bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o8">dndv</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o12">dvdx</a>;
00393                                 <a class="code" href="classNormal.html">Normal</a> dndy = bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o7">dndu</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o13">dudy</a> + bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o8">dndv</a> * bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o14">dvdy</a>;
00394                                 
00395                                 <a class="code" href="classVector.html">Vector</a> dwodx = -ray.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o1">d</a> - wo, dwody = -ray.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o1">d</a> - wo;
00396                                 <span class="keywordtype">float</span> dDNdx = <a class="code" href="geometry_8h.html#a17">Dot</a>(dwodx, n) + <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, dndx);
00397                                 <span class="keywordtype">float</span> dDNdy = <a class="code" href="geometry_8h.html#a17">Dot</a>(dwody, n) + <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, dndy);
00398                                 
00399                                 <span class="keywordtype">float</span> mu = eta * <a class="code" href="geometry_8h.html#a17">Dot</a>(w, n) - <a class="code" href="geometry_8h.html#a17">Dot</a>(wi, n);
00400                                 <span class="keywordtype">float</span> dmudx = (eta - (eta*eta*<a class="code" href="geometry_8h.html#a17">Dot</a>(w,n))/<a class="code" href="geometry_8h.html#a17">Dot</a>(wi, n)) * dDNdx;
00401                                 <span class="keywordtype">float</span> dmudy = (eta - (eta*eta*<a class="code" href="geometry_8h.html#a17">Dot</a>(w,n))/<a class="code" href="geometry_8h.html#a17">Dot</a>(wi, n)) * dDNdy;
00402                                 
00403                                 rd.<a class="code" href="classRayDifferential.html#o1">rx</a>.<a class="code" href="classRay.html#o1">d</a> = wi + eta * dwodx - <a class="code" href="classVector.html">Vector</a>(mu * dndx + dmudx * n);
00404                                 rd.<a class="code" href="classRayDifferential.html#o2">ry</a>.<a class="code" href="classRay.html#o1">d</a> = wi + eta * dwody - Vector(mu * dndy + dmudy * n);
00405                                 L += scene-&gt;<a class="code" href="classScene.html#a6">Li</a>(rd, sample) * f * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n);
00406                         }
00407                 }
00408                 --<a class="code" href="classPhotonIntegrator.html#r4">specularDepth</a>;
00409         }
00410         <span class="keywordflow">else</span> {
00411                 <span class="comment">// Handle ray with no intersection</span>
00412                 <span class="keywordflow">if</span> (alpha) *alpha = 0.;
00413                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size(); ++i)
00414                         L += scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[i]-&gt;Le(ray);
00415                 <span class="keywordflow">if</span> (alpha &amp;&amp; !L.<a class="code" href="classSpectrum.html#a15">Black</a>()) *alpha = 1.;
00416                 <span class="keywordflow">return</span> L;
00417         }
00418         <span class="keywordflow">return</span> L;
00419 }
<a name="l00420"></a><a class="code" href="classPhotonIntegrator.html#h1">00420</a> <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="classPhotonIntegrator.html#h1">PhotonIntegrator::LPhoton</a>(
00421                 <a class="code" href="classKdTree.html">KdTree&lt;Photon, PhotonProcess&gt;</a> *map,
00422                 <span class="keywordtype">int</span> nPaths, <span class="keywordtype">int</span> nLookup, <a class="code" href="classBSDF.html">BSDF</a> *bsdf,
00423                 <span class="keyword">const</span> <a class="code" href="structIntersection.html">Intersection</a> &amp;isect, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;wo,
00424                 <span class="keywordtype">float</span> maxDistSquared) {
00425         <a class="code" href="classSpectrum.html">Spectrum</a> L(0.);
00426         <span class="keywordflow">if</span> (!map) <span class="keywordflow">return</span> L;
00427         <a class="code" href="reflection_8h.html#a17">BxDFType</a> nonSpecular = <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a2">BSDF_REFLECTION</a> |
00428                 <a class="code" href="reflection_8h.html#a17a3">BSDF_TRANSMISSION</a> | <a class="code" href="reflection_8h.html#a17a4">BSDF_DIFFUSE</a> | <a class="code" href="reflection_8h.html#a17a5">BSDF_GLOSSY</a>);
00429         <span class="keywordflow">if</span> (bsdf-&gt;<a class="code" href="classBSDF.html#a5">NumComponents</a>(nonSpecular) == 0)
00430                 <span class="keywordflow">return</span> L;
00431         <span class="keyword">static</span> <a class="code" href="classStatsCounter.html">StatsCounter</a> lookups(<span class="stringliteral">"Photon Map"</span>, <span class="stringliteral">"Total lookups"</span>); <span class="comment">// NOBOOK</span>
00432         <span class="comment">// Initialize _PhotonProcess_ object, _proc_, for photon map lookups</span>
00433         <a class="code" href="structPhotonProcess.html">PhotonProcess</a> proc(nLookup, isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>);
00434         proc.<a class="code" href="structPhotonProcess.html#o1">photons</a> =
00435                 (<a class="code" href="structClosePhoton.html">ClosePhoton</a> *)alloca(nLookup * <span class="keyword">sizeof</span>(<a class="code" href="structClosePhoton.html">ClosePhoton</a>));
00436         <span class="comment">// Do photon map lookup</span>
00437         ++lookups;  <span class="comment">// NOBOOK</span>
00438         map-&gt;<a class="code" href="classKdTree.html#a3">Lookup</a>(isect.<a class="code" href="structIntersection.html#o0">dg</a>.<a class="code" href="structDifferentialGeometry.html#o0">p</a>, proc, maxDistSquared);
00439         <span class="comment">// Accumulate light from nearby photons</span>
00440         <span class="keyword">static</span> <a class="code" href="classStatsRatio.html">StatsRatio</a> foundRate(<span class="stringliteral">"Photon Map"</span>, <span class="stringliteral">"Photons found per lookup"</span>); <span class="comment">// NOBOOK</span>
00441         foundRate.<a class="code" href="classStatsRatio.html#a1">Add</a>(proc.<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a>, 1); <span class="comment">// NOBOOK</span>
00442         <span class="keywordtype">float</span> scale = 1.f / (float(nPaths) * maxDistSquared * <a class="code" href="pbrt_8h.html#a6">M_PI</a>);
00443         <span class="comment">// Estimate reflected light from photons</span>
00444         ClosePhoton *photons = proc.<a class="code" href="structPhotonProcess.html#o1">photons</a>;
00445         <span class="keywordtype">int</span> nFound = proc.<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a>;
00446         <a class="code" href="classNormal.html">Normal</a> Nf = <a class="code" href="geometry_8h.html#a17">Dot</a>(wo, bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>) &lt; 0 ? -bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a> :
00447                 bsdf-&gt;<a class="code" href="classBSDF.html#o0">dgShading</a>.<a class="code" href="structDifferentialGeometry.html#o1">nn</a>;
00448         <span class="keywordflow">if</span> (bsdf-&gt;<a class="code" href="classBSDF.html#a5">NumComponents</a>(<a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a2">BSDF_REFLECTION</a> |
00449                         <a class="code" href="reflection_8h.html#a17a3">BSDF_TRANSMISSION</a> | <a class="code" href="reflection_8h.html#a17a5">BSDF_GLOSSY</a>)) &gt; 0) {
00450                 <span class="comment">// Compute exitant radiance from photons for glossy surface</span>
00451                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nFound; ++i) {
00452                         <a class="code" href="reflection_8h.html#a17">BxDFType</a> flag = <a class="code" href="geometry_8h.html#a17">Dot</a>(Nf, photons[i].photon-&gt;wi) &gt; 0.f ?
00453                                 <a class="code" href="reflection_8h.html#a17a8">BSDF_ALL_REFLECTION</a> : <a class="code" href="reflection_8h.html#a17a9">BSDF_ALL_TRANSMISSION</a>;
00454                         L += bsdf-&gt;<a class="code" href="classBSDF.html#a10">f</a>(wo, photons[i].photon-&gt;wi, flag) *
00455                                 (scale * photons[i].<a class="code" href="structClosePhoton.html#o0">photon</a>-&gt;<a class="code" href="structPhoton.html#o1">alpha</a>);
00456                 }
00457         }
00458         <span class="keywordflow">else</span> {
00459                 <span class="comment">// Compute exitant radiance from photons for diffuse surface</span>
00460                 <a class="code" href="classSpectrum.html">Spectrum</a> Lr(0.), Lt(0.);
00461                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nFound; ++i)
00462                         <span class="keywordflow">if</span> (<a class="code" href="geometry_8h.html#a17">Dot</a>(Nf, photons[i].photon-&gt;wi) &gt; 0.f)
00463                                 Lr += photons[i].<a class="code" href="structClosePhoton.html#o0">photon</a>-&gt;<a class="code" href="structPhoton.html#o1">alpha</a>;
00464                         <span class="keywordflow">else</span>
00465                                 Lt += photons[i].photon-&gt;alpha;
00466                 L += (scale * <a class="code" href="pbrt_8h.html#a7">INV_PI</a>) * (Lr * bsdf-&gt;<a class="code" href="classBSDF.html#a11">rho</a>(wo, <a class="code" href="reflection_8h.html#a17a8">BSDF_ALL_REFLECTION</a>) +
00467                         Lt * bsdf-&gt;<a class="code" href="classBSDF.html#a11">rho</a>(wo, <a class="code" href="reflection_8h.html#a17a9">BSDF_ALL_TRANSMISSION</a>));
00468         }
00469         <span class="keywordflow">return</span> L;
00470 }
00471 PhotonProcess::PhotonProcess(u_int mp, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;P)
00472         : p(P) {
00473         photons = 0;
00474         nLookup = mp;
00475         foundPhotons = 0;
00476 }
00477 <span class="keywordtype">void</span> <a class="code" href="structPhotonProcess.html#a1">PhotonProcess::operator()</a>(<span class="keyword">const</span> <a class="code" href="structPhoton.html">Photon</a> &amp;photon,
00478                 <span class="keywordtype">float</span> distSquared, <span class="keywordtype">float</span> &amp;maxDistSquared)<span class="keyword"> const </span>{
00479         <span class="keyword">static</span> <a class="code" href="classStatsPercentage.html">StatsPercentage</a> discarded(<span class="stringliteral">"Photon Map"</span>, <span class="stringliteral">"Discarded photons"</span>); <span class="comment">// NOBOOK</span>
00480         discarded.<a class="code" href="classStatsPercentage.html#a0">Add</a>(0, 1); <span class="comment">// NOBOOK</span>
00481         <span class="keywordflow">if</span> (<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a> &lt; <a class="code" href="structPhotonProcess.html#o2">nLookup</a>) {
00482                 <span class="comment">// Add photon to unordered array of photons</span>
00483                 <a class="code" href="structPhotonProcess.html#o1">photons</a>[<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a>++] = <a class="code" href="structClosePhoton.html">ClosePhoton</a>(&amp;photon, distSquared);
00484                 <span class="keywordflow">if</span> (<a class="code" href="structPhotonProcess.html#o3">foundPhotons</a> == <a class="code" href="structPhotonProcess.html#o2">nLookup</a>) {
00485                         std::make_heap(&amp;photons[0], &amp;photons[nLookup]);
00486                         maxDistSquared = <a class="code" href="structPhotonProcess.html#o1">photons</a>[0].<a class="code" href="structClosePhoton.html#o1">distanceSquared</a>;
00487                 }
00488         }
00489         <span class="keywordflow">else</span> {
00490                 <span class="comment">// Remove most distant photon from heap and add new photon</span>
00491                 discarded.<a class="code" href="classStatsPercentage.html#a0">Add</a>(1, 0); <span class="comment">// NOBOOK</span>
00492                 std::pop_heap(&amp;photons[0], &amp;photons[nLookup]);
00493                 <a class="code" href="structPhotonProcess.html#o1">photons</a>[<a class="code" href="structPhotonProcess.html#o2">nLookup</a>-1] = <a class="code" href="structClosePhoton.html">ClosePhoton</a>(&amp;photon, distSquared);
00494                 std::push_heap(&amp;photons[0], &amp;photons[nLookup]);
00495                 maxDistSquared = <a class="code" href="structPhotonProcess.html#o1">photons</a>[0].<a class="code" href="structClosePhoton.html#o1">distanceSquared</a>;
00496         }
00497 }
<a name="l00498"></a><a class="code" href="photonmap_8cpp.html#a0">00498</a> <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <a class="code" href="pbrt_8h.html#a2">DLLEXPORT</a> <a class="code" href="classSurfaceIntegrator.html">SurfaceIntegrator</a> *<a class="code" href="whitted_8cpp.html#a0">CreateSurfaceIntegrator</a>(<span class="keyword">const</span> <a class="code" href="classParamSet.html">ParamSet</a> &amp;params) {
00499         <span class="keywordtype">int</span> nCaustic = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"causticphotons"</span>, 20000);
00500         <span class="keywordtype">int</span> nDirect = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"directphotons"</span>, 100000);
00501         <span class="keywordtype">int</span> nIndirect = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"indirectphotons"</span>, 100000);
00502         <span class="keywordtype">int</span> nUsed = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"nused"</span>, 50);
00503         <span class="keywordtype">int</span> maxDepth = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"maxdepth"</span>, 5);
00504         <span class="keywordtype">bool</span> finalGather = params.<a class="code" href="classParamSet.html#a23">FindOneBool</a>(<span class="stringliteral">"finalgather"</span>, <span class="keyword">true</span>);
00505         <span class="keywordtype">bool</span> directPhotons = params.<a class="code" href="classParamSet.html#a23">FindOneBool</a>(<span class="stringliteral">"directwithphotons"</span>, <span class="keyword">false</span>);
00506         <span class="keywordtype">int</span> gatherSamples = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"finalgathersamples"</span>, 32);
00507         <span class="keywordtype">float</span> maxDist = params.<a class="code" href="classParamSet.html#a21">FindOneFloat</a>(<span class="stringliteral">"maxdist"</span>, .1f);
00508         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classPhotonIntegrator.html">PhotonIntegrator</a>(nCaustic, nDirect, nIndirect,
00509                 nUsed, maxDepth, maxDist, finalGather, gatherSamples,
00510                 directPhotons);
00511 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Mon Apr 25 19:00:23 2005 for pbrt by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
