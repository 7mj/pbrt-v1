<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pbrt: transport.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>transport.cpp</h1><a href="transport_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> * pbrt source code Copyright(c) 1998-2005 Matt Pharr and Greg Humphreys</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * All Rights Reserved.</span>
00006 <span class="comment"> * For educational use only; commercial use expressly forbidden.</span>
00007 <span class="comment"> * NO WARRANTY, express or implied, for this software.</span>
00008 <span class="comment"> * (See file License.txt for complete license)</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">// transport.cpp*</span>
00012 <span class="preprocessor">#include "<a class="code" href="transport_8h.html">transport.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="scene_8h.html">scene.h</a>"</span>
00014 <span class="comment">// Integrator Method Definitions</span>
<a name="l00015"></a><a class="code" href="classIntegrator.html#a0">00015</a> <a class="code" href="classIntegrator.html#a0">Integrator::~Integrator</a>() {
00016 }
00017 <span class="comment">// Integrator Utility Functions</span>
<a name="l00018"></a><a class="code" href="transport_8h.html#a0">00018</a> <a class="code" href="pbrt_8h.html#a1">COREDLL</a> <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="transport_8h.html#a0">UniformSampleAllLights</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene,
00019                 <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p, <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;n, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;wo,
00020                 <a class="code" href="classBSDF.html">BSDF</a> *bsdf, <span class="keyword">const</span> <a class="code" href="structSample.html">Sample</a> *sample,
00021                 <span class="keywordtype">int</span> *lightSampleOffset, <span class="keywordtype">int</span> *bsdfSampleOffset,
00022                 <span class="keywordtype">int</span> *bsdfComponentOffset) {
00023         <a class="code" href="classSpectrum.html">Spectrum</a> L(0.);
00024         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size(); ++i) {
00025                 <a class="code" href="classLight.html">Light</a> *light = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[i];
00026                 <span class="keywordtype">int</span> nSamples = (sample &amp;&amp; lightSampleOffset) ?
00027                         sample-&gt;<a class="code" href="structSample.html#o6">n2D</a>[lightSampleOffset[i]] : 1;
00028                 <span class="comment">// Estimate direct lighting from _light_ samples</span>
00029                 <a class="code" href="classSpectrum.html">Spectrum</a> Ld(0.);
00030                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nSamples; ++j)
00031                         Ld += <a class="code" href="transport_8cpp.html#a3">EstimateDirect</a>(scene, light, p, n, wo, bsdf,
00032                                 sample, lightSampleOffset[i], bsdfSampleOffset[i],
00033                                 bsdfComponentOffset[i], j);
00034                 L += Ld / nSamples;
00035         }
00036         <span class="keywordflow">return</span> L;
00037 }
<a name="l00038"></a><a class="code" href="transport_8h.html#a1">00038</a> <a class="code" href="pbrt_8h.html#a1">COREDLL</a> <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="transport_8h.html#a1">UniformSampleOneLight</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene,
00039                 <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p, <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;n,
00040                 <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;wo, <a class="code" href="classBSDF.html">BSDF</a> *bsdf, <span class="keyword">const</span> <a class="code" href="structSample.html">Sample</a> *sample,
00041                 <span class="keywordtype">int</span> lightSampleOffset, <span class="keywordtype">int</span> lightNumOffset,
00042                 <span class="keywordtype">int</span> bsdfSampleOffset, <span class="keywordtype">int</span> bsdfComponentOffset) {
00043         <span class="comment">// Randomly choose a single light to sample, _light_</span>
00044         <span class="keywordtype">int</span> nLights = int(scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size());
00045         <span class="keywordtype">int</span> lightNum;
00046         <span class="keywordflow">if</span> (lightNumOffset != -1)
00047                 lightNum = <a class="code" href="pbrt_8h.html#a106">Floor2Int</a>(sample-&gt;<a class="code" href="structSample.html#o7">oneD</a>[lightNumOffset][0] *
00048                                                          nLights);
00049         <span class="keywordflow">else</span>
00050                 lightNum = <a class="code" href="pbrt_8h.html#a106">Floor2Int</a>(<a class="code" href="pbrt_8h.html#a108">RandomFloat</a>() * nLights);
00051         lightNum = min(lightNum, nLights-1);
00052         <a class="code" href="classLight.html">Light</a> *light = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[lightNum];
00053         <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)nLights *
00054                 <a class="code" href="transport_8cpp.html#a3">EstimateDirect</a>(scene, light, p, n, wo, bsdf, sample,
00055                         lightSampleOffset, bsdfSampleOffset,
00056                         bsdfComponentOffset, 0);
00057 }
<a name="l00058"></a><a class="code" href="transport_8h.html#a2">00058</a> <a class="code" href="pbrt_8h.html#a1">COREDLL</a> <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="transport_8h.html#a2">WeightedSampleOneLight</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene,
00059                 <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p, <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;n,
00060                 <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;wo, <a class="code" href="classBSDF.html">BSDF</a> *bsdf,
00061                 <span class="keyword">const</span> <a class="code" href="structSample.html">Sample</a> *sample, <span class="keywordtype">int</span> lightSampleOffset,
00062                 <span class="keywordtype">int</span> lightNumOffset, <span class="keywordtype">int</span> bsdfSampleOffset,
00063                 <span class="keywordtype">int</span> bsdfComponentOffset, <span class="keywordtype">float</span> *&amp;avgY,
00064                 <span class="keywordtype">float</span> *&amp;avgYsample, <span class="keywordtype">float</span> *&amp;cdf,
00065                 <span class="keywordtype">float</span> &amp;overallAvgY) {
00066         <span class="keywordtype">int</span> nLights = int(scene-&gt;<a class="code" href="classScene.html#o1">lights</a>.size());
00067         <span class="comment">// Initialize _avgY_ array if necessary</span>
00068         <span class="keywordflow">if</span> (!avgY) {
00069                 avgY = <span class="keyword">new</span> <span class="keywordtype">float</span>[nLights];
00070                 avgYsample = <span class="keyword">new</span> <span class="keywordtype">float</span>[nLights];
00071                 cdf = <span class="keyword">new</span> <span class="keywordtype">float</span>[nLights+1];
00072                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nLights; ++i)
00073                         avgY[i] = avgYsample[i] = 0.;
00074         }
00075         <a class="code" href="classSpectrum.html">Spectrum</a> L(0.);
00076         <span class="keywordflow">if</span> (overallAvgY == 0.) {
00077                 <span class="comment">// Sample one light uniformly and initialize luminance arrays</span>
00078                 L = <a class="code" href="transport_8h.html#a1">UniformSampleOneLight</a>(scene, p, n,
00079                     wo, bsdf, sample, lightSampleOffset,
00080                         lightNumOffset, bsdfSampleOffset,
00081                         bsdfComponentOffset);
00082                 <span class="keywordtype">float</span> luminance = L.<a class="code" href="classSpectrum.html#a23">y</a>();
00083                 overallAvgY = luminance;
00084                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nLights; ++i)
00085                         avgY[i] = luminance;
00086         }
00087         <span class="keywordflow">else</span> {
00088                 <span class="comment">// Choose _light_ according to average reflected luminance</span>
00089                 <span class="keywordtype">float</span> c, lightSampleWeight;
00090                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nLights; ++i)
00091                         avgYsample[i] = max(avgY[i], .1f * overallAvgY);
00092                 <a class="code" href="pbrt_8h.html#a89">ComputeStep1dCDF</a>(avgYsample, nLights, &amp;c, cdf);
00093                 <span class="keywordtype">float</span> t = <a class="code" href="pbrt_8h.html#a90">SampleStep1d</a>(avgYsample, cdf, c, nLights,
00094                         sample-&gt;<a class="code" href="structSample.html#o7">oneD</a>[lightNumOffset][0], &amp;lightSampleWeight);
00095                 <span class="keywordtype">int</span> lightNum = min(<a class="code" href="pbrt_8h.html#a105">Float2Int</a>(nLights * t), nLights-1);
00096                 <a class="code" href="classLight.html">Light</a> *light = scene-&gt;<a class="code" href="classScene.html#o1">lights</a>[lightNum];
00097                 L = <a class="code" href="transport_8cpp.html#a3">EstimateDirect</a>(scene, light, p, n, wo, bsdf,
00098                         sample, lightSampleOffset, bsdfSampleOffset,
00099                         bsdfComponentOffset, 0);
00100                 <span class="comment">// Update _avgY_ array with reflected radiance due to light</span>
00101                 <span class="keywordtype">float</span> luminance = L.<a class="code" href="classSpectrum.html#a23">y</a>();
00102                 avgY[lightNum] =
00103                         <a class="code" href="pbrt_8h.html#a112">ExponentialAverage</a>(avgY[lightNum], luminance, .99f);
00104                 overallAvgY =
00105                         <a class="code" href="pbrt_8h.html#a112">ExponentialAverage</a>(overallAvgY, luminance, .999f);
00106                 L /= lightSampleWeight;
00107         }
00108         <span class="keywordflow">return</span> L;
00109 }
<a name="l00110"></a><a class="code" href="transport_8cpp.html#a3">00110</a> <a class="code" href="classSpectrum.html">Spectrum</a> <a class="code" href="transport_8cpp.html#a3">EstimateDirect</a>(<span class="keyword">const</span> <a class="code" href="classScene.html">Scene</a> *scene,
00111         <span class="keyword">const</span> <a class="code" href="classLight.html">Light</a> *light, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> &amp;p,
00112                 <span class="keyword">const</span> <a class="code" href="classNormal.html">Normal</a> &amp;n, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;wo,
00113                 <a class="code" href="classBSDF.html">BSDF</a> *bsdf, <span class="keyword">const</span> <a class="code" href="structSample.html">Sample</a> *sample, <span class="keywordtype">int</span> lightSamp,
00114                 <span class="keywordtype">int</span> bsdfSamp, <span class="keywordtype">int</span> bsdfComponent, u_int sampleNum) {
00115         <a class="code" href="classSpectrum.html">Spectrum</a> Ld(0.);
00116         <span class="comment">// Find light and BSDF sample values for direct lighting estimate</span>
00117         <span class="keywordtype">float</span> ls1, ls2, bs1, bs2, bcs;
00118         <span class="keywordflow">if</span> (lightSamp != -1 &amp;&amp; bsdfSamp != -1 &amp;&amp;
00119                 sampleNum &lt; sample-&gt;<a class="code" href="structSample.html#o6">n2D</a>[lightSamp] &amp;&amp;
00120                 sampleNum &lt; sample-&gt;<a class="code" href="structSample.html#o6">n2D</a>[bsdfSamp]) {
00121                 ls1 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[lightSamp][2*sampleNum];
00122                 ls2 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[lightSamp][2*sampleNum+1];
00123                 bs1 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[bsdfSamp][2*sampleNum];
00124                 bs2 = sample-&gt;<a class="code" href="structSample.html#o8">twoD</a>[bsdfSamp][2*sampleNum+1];
00125                 bcs = sample-&gt;<a class="code" href="structSample.html#o7">oneD</a>[bsdfComponent][sampleNum];
00126         }
00127         <span class="keywordflow">else</span> {
00128                 ls1 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00129                 ls2 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00130                 bs1 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00131                 bs2 = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00132                 bcs = <a class="code" href="pbrt_8h.html#a108">RandomFloat</a>();
00133         }
00134         <span class="comment">// Sample light source with multiple importance sampling</span>
00135         <a class="code" href="classVector.html">Vector</a> wi;
00136         <span class="keywordtype">float</span> lightPdf, bsdfPdf;
00137         <a class="code" href="structVisibilityTester.html">VisibilityTester</a> visibility;
00138         <a class="code" href="classSpectrum.html">Spectrum</a> Li = light-&gt;<a class="code" href="classLight.html#a2">Sample_L</a>(p, n,
00139                 ls1, ls2, &amp;wi, &amp;lightPdf, &amp;visibility);
00140         <span class="keywordflow">if</span> (lightPdf &gt; 0. &amp;&amp; !Li.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00141                 <a class="code" href="classSpectrum.html">Spectrum</a> f = bsdf-&gt;<a class="code" href="classBSDF.html#a10">f</a>(wo, wi);
00142                 <span class="keywordflow">if</span> (!f.<a class="code" href="classSpectrum.html#a15">Black</a>() &amp;&amp; visibility.<a class="code" href="structVisibilityTester.html#a2">Unoccluded</a>(scene)) {
00143                         <span class="comment">// Add light's contribution to reflected radiance</span>
00144                         Li *= visibility.<a class="code" href="structVisibilityTester.html#a3">Transmittance</a>(scene);
00145                         <span class="keywordflow">if</span> (light-&gt;<a class="code" href="classLight.html#a4">IsDeltaLight</a>())
00146                                 Ld += f * Li * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n) / lightPdf;
00147                         <span class="keywordflow">else</span> {
00148                                 bsdfPdf = bsdf-&gt;<a class="code" href="classBSDF.html#a2">Pdf</a>(wo, wi);
00149                                 <span class="keywordtype">float</span> weight = <a class="code" href="mc_8h.html#a14">PowerHeuristic</a>(1, lightPdf, 1, bsdfPdf);
00150                                 Ld += f * Li * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n) * weight / lightPdf;
00151                         }
00152                 }
00153         }
00154         <span class="comment">// Sample BSDF with multiple importance sampling</span>
00155         <span class="keywordflow">if</span> (!light-&gt;<a class="code" href="classLight.html#a4">IsDeltaLight</a>()) {
00156                 <a class="code" href="reflection_8h.html#a17">BxDFType</a> flags = <a class="code" href="reflection_8h.html#a17">BxDFType</a>(<a class="code" href="reflection_8h.html#a17a10">BSDF_ALL</a> &amp; ~<a class="code" href="reflection_8h.html#a17a6">BSDF_SPECULAR</a>);
00157                 <a class="code" href="classSpectrum.html">Spectrum</a> f = bsdf-&gt;<a class="code" href="classBSDF.html#a0">Sample_f</a>(wo, &amp;wi,
00158                         bs1, bs2, bcs, &amp;bsdfPdf, flags);
00159                 <span class="keywordflow">if</span> (!f.<a class="code" href="classSpectrum.html#a15">Black</a>() &amp;&amp; bsdfPdf &gt; 0.) {
00160                         lightPdf = light-&gt;<a class="code" href="classLight.html#a7">Pdf</a>(p, n, wi);
00161                         <span class="keywordflow">if</span> (lightPdf &gt; 0.) {
00162                                 <span class="comment">// Add light contribution from BSDF sampling</span>
00163                                 <span class="keywordtype">float</span> weight = <a class="code" href="mc_8h.html#a14">PowerHeuristic</a>(1, bsdfPdf, 1, lightPdf);
00164                                 <a class="code" href="structIntersection.html">Intersection</a> lightIsect;
00165                                 <a class="code" href="classSpectrum.html">Spectrum</a> Li(0.f);
00166                                 <a class="code" href="classRayDifferential.html">RayDifferential</a> ray(p, wi);
00167                                 <span class="keywordflow">if</span> (scene-&gt;<a class="code" href="classScene.html#a3">Intersect</a>(ray, &amp;lightIsect)) {
00168                                         <span class="keywordflow">if</span> (lightIsect.<a class="code" href="structIntersection.html#o1">primitive</a>-&gt;<a class="code" href="classPrimitive.html#a7">GetAreaLight</a>() == light)
00169                                                 Li = lightIsect.<a class="code" href="structIntersection.html#a2">Le</a>(-wi);
00170                                 }
00171                                 <span class="keywordflow">else</span>
00172                                         Li = light-&gt;<a class="code" href="classLight.html#a5">Le</a>(ray);
00173                                 <span class="keywordflow">if</span> (!Li.<a class="code" href="classSpectrum.html#a15">Black</a>()) {
00174                                         Li *= scene-&gt;<a class="code" href="classScene.html#a7">Transmittance</a>(ray);
00175                                         Ld += f * Li * <a class="code" href="geometry_8h.html#a20">AbsDot</a>(wi, n) * weight / bsdfPdf;
00176                                 }
00177                         }
00178                 }
00179         }
00180         <span class="keywordflow">return</span> Ld;
00181 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Mon Apr 25 19:00:25 2005 for pbrt by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
