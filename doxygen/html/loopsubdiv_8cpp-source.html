<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pbrt: loopsubdiv.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>loopsubdiv.cpp</h1><a href="loopsubdiv_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> * pbrt source code Copyright(c) 1998-2005 Matt Pharr and Greg Humphreys</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * All Rights Reserved.</span>
00006 <span class="comment"> * For educational use only; commercial use expressly forbidden.</span>
00007 <span class="comment"> * NO WARRANTY, express or implied, for this software.</span>
00008 <span class="comment"> * (See file License.txt for complete license)</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">// loopsubdiv.cpp*</span>
00012 <span class="preprocessor">#include "<a class="code" href="shape_8h.html">shape.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="paramset_8h.html">paramset.h</a>"</span>
00014 <span class="preprocessor">#include "<a class="code" href="dynload_8h.html">dynload.h</a>"</span>
00015 <span class="preprocessor">#include "<a class="code" href="texture_8h.html">texture.h</a>"</span>
00016 <span class="preprocessor">#include &lt;set&gt;</span>
00017 <span class="preprocessor">#include &lt;map&gt;</span>
00018 <span class="keyword">using</span> std::set;
00019 <span class="keyword">using</span> std::map;
00020 <span class="comment">// LoopSubdiv Macros</span>
<a name="l00021"></a><a class="code" href="loopsubdiv_8cpp.html#a0">00021</a> <span class="preprocessor">#define NEXT(i) (((i)+1)%3)</span>
<a name="l00022"></a><a class="code" href="loopsubdiv_8cpp.html#a1">00022</a> <span class="preprocessor"></span><span class="preprocessor">#define PREV(i) (((i)+2)%3)</span>
00023 <span class="preprocessor"></span><span class="comment">// LoopSubdiv Local Structures</span>
00024 <span class="keyword">struct </span><a class="code" href="structSDFace.html">SDFace</a>;
00025 <span class="keyword">struct </span><a class="code" href="structSDFace.html">SDFace</a>;
<a name="l00026"></a><a class="code" href="structSDVertex.html">00026</a> <span class="keyword">struct </span><a class="code" href="structSDVertex.html">SDVertex</a> {
00027         <span class="comment">// SDVertex Constructor</span>
<a name="l00028"></a><a class="code" href="structSDVertex.html#a0">00028</a>         <a class="code" href="structSDVertex.html">SDVertex</a>(<a class="code" href="classPoint.html">Point</a> pt = <a class="code" href="classPoint.html">Point</a>(0,0,0))
00029                 : <a class="code" href="structSDVertex.html#o0">P</a>(pt), <a class="code" href="structSDVertex.html#o1">startFace</a>(NULL), <a class="code" href="structSDVertex.html#o2">child</a>(NULL),
00030                 <a class="code" href="structSDVertex.html#o3">regular</a>(false), <a class="code" href="structSDVertex.html#o4">boundary</a>(false) {
00031         }
00032         <span class="comment">// SDVertex Methods</span>
00033         <span class="keywordtype">int</span> <a class="code" href="structSDVertex.html#a1">valence</a>();
00034         <span class="keywordtype">void</span> oneRing(<a class="code" href="classPoint.html">Point</a> *P);
<a name="l00035"></a><a class="code" href="structSDVertex.html#o0">00035</a>         <a class="code" href="classPoint.html">Point</a> <a class="code" href="structSDVertex.html#o0">P</a>;
<a name="l00036"></a><a class="code" href="structSDVertex.html#o1">00036</a>         <a class="code" href="structSDFace.html">SDFace</a> *<a class="code" href="structSDVertex.html#o1">startFace</a>;
<a name="l00037"></a><a class="code" href="structSDVertex.html#o2">00037</a>         <a class="code" href="structSDVertex.html">SDVertex</a> *<a class="code" href="structSDVertex.html#o2">child</a>;
<a name="l00038"></a><a class="code" href="structSDVertex.html#o3">00038</a>         <span class="keywordtype">bool</span> <a class="code" href="structSDVertex.html#o3">regular</a>, <a class="code" href="structSDVertex.html#o4">boundary</a>;
00039 };
<a name="l00040"></a><a class="code" href="structSDFace.html">00040</a> <span class="keyword">struct </span><a class="code" href="structSDFace.html">SDFace</a> {
00041         <span class="comment">// SDFace Constructor</span>
<a name="l00042"></a><a class="code" href="structSDFace.html#a0">00042</a>         <a class="code" href="structSDFace.html#a0">SDFace</a>() {
00043                 <span class="keywordtype">int</span> i;
00044                 <span class="keywordflow">for</span> (i = 0; i &lt; 3; ++i) {
00045                         <a class="code" href="structSDFace.html#o0">v</a>[i] = NULL;
00046                         <a class="code" href="structSDFace.html#o1">f</a>[i] = NULL;
00047                 }
00048                 <span class="keywordflow">for</span> (i = 0; i &lt; 4; ++i)
00049                         <a class="code" href="structSDFace.html#o2">children</a>[i] = NULL;
00050         }
00051         <span class="comment">// SDFace Methods</span>
<a name="l00052"></a><a class="code" href="structSDFace.html#a1">00052</a>         <span class="keywordtype">int</span> <a class="code" href="structSDFace.html#a1">vnum</a>(<a class="code" href="structSDVertex.html">SDVertex</a> *vert)<span class="keyword"> const </span>{
00053                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)
00054                         <span class="keywordflow">if</span> (<a class="code" href="structSDFace.html#o0">v</a>[i] == vert) <span class="keywordflow">return</span> i;
00055                 <a class="code" href="util_8cpp.html#a17">Severe</a>(<span class="stringliteral">"Basic logic error in SDFace::vnum()"</span>);
00056                 <span class="keywordflow">return</span> -1;
00057         }
<a name="l00058"></a><a class="code" href="structSDFace.html#a2">00058</a>         <a class="code" href="structSDFace.html">SDFace</a> *<a class="code" href="structSDFace.html#a2">nextFace</a>(<a class="code" href="structSDVertex.html">SDVertex</a> *vert) {
00059                 <span class="keywordflow">return</span> <a class="code" href="structSDFace.html#o1">f</a>[vnum(vert)];
00060         }
<a name="l00061"></a><a class="code" href="structSDFace.html#a3">00061</a>         <a class="code" href="structSDFace.html">SDFace</a> *<a class="code" href="structSDFace.html#a3">prevFace</a>(<a class="code" href="structSDVertex.html">SDVertex</a> *vert) {
00062                 <span class="keywordflow">return</span> <a class="code" href="structSDFace.html#o1">f</a>[<a class="code" href="loopsubdiv_8cpp.html#a1">PREV</a>(vnum(vert))];
00063         }
<a name="l00064"></a><a class="code" href="structSDFace.html#a4">00064</a>         <a class="code" href="structSDVertex.html">SDVertex</a> *<a class="code" href="structSDFace.html#a4">nextVert</a>(<a class="code" href="structSDVertex.html">SDVertex</a> *vert) {
00065                 <span class="keywordflow">return</span> <a class="code" href="structSDFace.html#o0">v</a>[<a class="code" href="loopsubdiv_8cpp.html#a0">NEXT</a>(vnum(vert))];
00066         }
<a name="l00067"></a><a class="code" href="structSDFace.html#a5">00067</a>         <a class="code" href="structSDVertex.html">SDVertex</a> *<a class="code" href="structSDFace.html#a5">prevVert</a>(<a class="code" href="structSDVertex.html">SDVertex</a> *vert) {
00068                 <span class="keywordflow">return</span> <a class="code" href="structSDFace.html#o0">v</a>[<a class="code" href="loopsubdiv_8cpp.html#a1">PREV</a>(vnum(vert))];
00069         }
<a name="l00070"></a><a class="code" href="structSDFace.html#a6">00070</a>         <a class="code" href="structSDVertex.html">SDVertex</a> *<a class="code" href="structSDFace.html#a6">otherVert</a>(<a class="code" href="structSDVertex.html">SDVertex</a> *v0, <a class="code" href="structSDVertex.html">SDVertex</a> *v1) {
00071                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)
00072                         <span class="keywordflow">if</span> (<a class="code" href="structSDFace.html#o0">v</a>[i] != v0 &amp;&amp; <a class="code" href="structSDFace.html#o0">v</a>[i] != v1)
00073                                 <span class="keywordflow">return</span> v[i];
00074                 <a class="code" href="util_8cpp.html#a17">Severe</a>(<span class="stringliteral">"Basic logic error in SDVertex::otherVert()"</span>);
00075                 <span class="keywordflow">return</span> NULL;
00076         }
<a name="l00077"></a><a class="code" href="structSDFace.html#o0">00077</a>         <a class="code" href="structSDVertex.html">SDVertex</a> *<a class="code" href="structSDFace.html#o0">v</a>[3];
<a name="l00078"></a><a class="code" href="structSDFace.html#o1">00078</a>         <a class="code" href="structSDFace.html">SDFace</a> *<a class="code" href="structSDFace.html#o1">f</a>[3];
<a name="l00079"></a><a class="code" href="structSDFace.html#o2">00079</a>         <a class="code" href="structSDFace.html">SDFace</a> *<a class="code" href="structSDFace.html#o2">children</a>[4];
00080 };
<a name="l00081"></a><a class="code" href="structSDEdge.html">00081</a> <span class="keyword">struct </span><a class="code" href="structSDEdge.html">SDEdge</a> {
00082         <span class="comment">// SDEdge Constructor</span>
<a name="l00083"></a><a class="code" href="structSDEdge.html#a0">00083</a>         <a class="code" href="structSDEdge.html">SDEdge</a>(<a class="code" href="structSDVertex.html">SDVertex</a> *v0 = NULL, <a class="code" href="structSDVertex.html">SDVertex</a> *v1 = NULL) {
00084                 <a class="code" href="structSDEdge.html#o0">v</a>[0] = min(v0, v1);
00085                 <a class="code" href="structSDEdge.html#o0">v</a>[1] = max(v0, v1);
00086                 <a class="code" href="structSDEdge.html#o1">f</a>[0] = <a class="code" href="structSDEdge.html#o1">f</a>[1] = NULL;
00087                 <a class="code" href="structSDEdge.html#o2">f0edgeNum</a> = -1;
00088         }
00089         <span class="comment">// SDEdge Comparison Function</span>
<a name="l00090"></a><a class="code" href="structSDEdge.html#a1">00090</a>         <span class="keywordtype">bool</span> <a class="code" href="structSDEdge.html#a1">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="structSDEdge.html">SDEdge</a> &amp;e2)<span class="keyword"> const </span>{
00091                 <span class="keywordflow">if</span> (<a class="code" href="structSDEdge.html#o0">v</a>[0] == e2.<a class="code" href="structSDEdge.html#o0">v</a>[0]) <span class="keywordflow">return</span> <a class="code" href="structSDEdge.html#o0">v</a>[1] &lt; e2.<a class="code" href="structSDEdge.html#o0">v</a>[1];
00092                 <span class="keywordflow">return</span> <a class="code" href="structSDEdge.html#o0">v</a>[0] &lt; e2.<a class="code" href="structSDEdge.html#o0">v</a>[0];
00093         }
<a name="l00094"></a><a class="code" href="structSDEdge.html#o0">00094</a>         <a class="code" href="structSDVertex.html">SDVertex</a> *<a class="code" href="structSDEdge.html#o0">v</a>[2];
<a name="l00095"></a><a class="code" href="structSDEdge.html#o1">00095</a>         <a class="code" href="structSDFace.html">SDFace</a> *<a class="code" href="structSDEdge.html#o1">f</a>[2];
<a name="l00096"></a><a class="code" href="structSDEdge.html#o2">00096</a>         <span class="keywordtype">int</span> <a class="code" href="structSDEdge.html#o2">f0edgeNum</a>;
00097 };
00098 <span class="comment">// LoopSubdiv Declarations</span>
<a name="l00099"></a><a class="code" href="classLoopSubdiv.html">00099</a> <span class="keyword">class </span><a class="code" href="classLoopSubdiv.html">LoopSubdiv</a> : <span class="keyword">public</span> <a class="code" href="classShape.html">Shape</a> {
00100 <span class="keyword">public</span>:
00101         <span class="comment">// LoopSubdiv Public Methods</span>
00102         <a class="code" href="classLoopSubdiv.html">LoopSubdiv</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a> &amp;o2w, <span class="keywordtype">bool</span> ro,
00103                    <span class="keywordtype">int</span> nt, <span class="keywordtype">int</span> nv, <span class="keyword">const</span> <span class="keywordtype">int</span> *vi,
00104                    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> *P, <span class="keywordtype">int</span> nlevels);
00105         <a class="code" href="classLoopSubdiv.html#a1">~LoopSubdiv</a>();
00106         <span class="keywordtype">bool</span> <a class="code" href="classLoopSubdiv.html#a2">CanIntersect</a>() <span class="keyword">const</span>;
00107         <span class="keywordtype">void</span> <a class="code" href="classLoopSubdiv.html#a3">Refine</a>(vector&lt;<a class="code" href="classReference.html">Reference&lt;Shape&gt;</a> &gt; &amp;refined) <span class="keyword">const</span>;
00108         <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classLoopSubdiv.html#a4">ObjectBound</a>() <span class="keyword">const</span>;
00109         <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classLoopSubdiv.html#a5">WorldBound</a>() <span class="keyword">const</span>;
00110 <span class="keyword">private</span>:
00111         <span class="comment">// LoopSubdiv Private Methods</span>
<a name="l00112"></a><a class="code" href="classLoopSubdiv.html#h0">00112</a>         <span class="keyword">static</span> <span class="keywordtype">float</span> <a class="code" href="classLoopSubdiv.html#h0">beta</a>(<span class="keywordtype">int</span> valence) {
00113                 <span class="keywordflow">if</span> (valence == 3) <span class="keywordflow">return</span> 3.f/16.f;
00114                 <span class="keywordflow">else</span> <span class="keywordflow">return</span> 3.f / (8.f * valence);
00115         }
00116         <span class="keyword">static</span> <a class="code" href="classPoint.html">Point</a> weightOneRing(<a class="code" href="structSDVertex.html">SDVertex</a> *vert, <span class="keywordtype">float</span> beta);
00117         <span class="keyword">static</span> <a class="code" href="classPoint.html">Point</a> weightBoundary(<a class="code" href="structSDVertex.html">SDVertex</a> *vert, <span class="keywordtype">float</span> beta);
<a name="l00118"></a><a class="code" href="classLoopSubdiv.html#h3">00118</a>         <span class="keyword">static</span> <span class="keywordtype">float</span> <a class="code" href="classLoopSubdiv.html#h3">gamma</a>(<span class="keywordtype">int</span> valence) {
00119                 <span class="keywordflow">return</span> 1.f / (valence + 3.f / (8.f * beta(valence)));
00120         }
00121         <span class="comment">// LoopSubdiv Private Data</span>
<a name="l00122"></a><a class="code" href="classLoopSubdiv.html#r0">00122</a>         <span class="keywordtype">int</span> <a class="code" href="classLoopSubdiv.html#r0">nLevels</a>;
<a name="l00123"></a><a class="code" href="classLoopSubdiv.html#r1">00123</a>         vector&lt;SDVertex *&gt; <a class="code" href="classLoopSubdiv.html#r1">vertices</a>;
<a name="l00124"></a><a class="code" href="classLoopSubdiv.html#r2">00124</a>         vector&lt;SDFace *&gt; <a class="code" href="classLoopSubdiv.html#r2">faces</a>;
00125 };
00126 <span class="comment">// LoopSubdiv Inline Functions</span>
<a name="l00127"></a><a class="code" href="structSDVertex.html#a1">00127</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="structSDVertex.html#a1">SDVertex::valence</a>() {
00128         <a class="code" href="structSDFace.html">SDFace</a> *f = <a class="code" href="structSDVertex.html#o1">startFace</a>;
00129         <span class="keywordflow">if</span> (!<a class="code" href="structSDVertex.html#o4">boundary</a>) {
00130                 <span class="comment">// Compute valence of interior vertex</span>
00131                 <span class="keywordtype">int</span> nf = 1;
00132                 <span class="keywordflow">while</span> ((f = f-&gt;<a class="code" href="structSDFace.html#a2">nextFace</a>(<span class="keyword">this</span>)) != startFace)
00133                         ++nf;
00134                 <span class="keywordflow">return</span> nf;
00135         }
00136         <span class="keywordflow">else</span> {
00137                 <span class="comment">// Compute valence of boundary vertex</span>
00138                 <span class="keywordtype">int</span> nf = 1;
00139                 <span class="keywordflow">while</span> ((f = f-&gt;<a class="code" href="structSDFace.html#a2">nextFace</a>(<span class="keyword">this</span>)) != NULL)
00140                         ++nf;
00141                 f = startFace;
00142                 <span class="keywordflow">while</span> ((f = f-&gt;<a class="code" href="structSDFace.html#a3">prevFace</a>(<span class="keyword">this</span>)) != NULL)
00143                         ++nf;
00144                 <span class="keywordflow">return</span> nf+1;
00145         }
00146 }
00147 <span class="comment">// LoopSubdiv Method Definitions</span>
<a name="l00148"></a><a class="code" href="classLoopSubdiv.html#a0">00148</a> <a class="code" href="classLoopSubdiv.html#a0">LoopSubdiv::LoopSubdiv</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a> &amp;o2w, <span class="keywordtype">bool</span> ro,
00149         <span class="keywordtype">int</span> nfaces, <span class="keywordtype">int</span> nvertices,
00150                 <span class="keyword">const</span> <span class="keywordtype">int</span> *vertexIndices,
00151                 <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> *P, <span class="keywordtype">int</span> nl)
00152         : <a class="code" href="classShape.html">Shape</a>(o2w, ro) {
00153         <a class="code" href="classLoopSubdiv.html#r0">nLevels</a> = nl;
00154         <span class="comment">// Allocate _LoopSubdiv_ vertices and faces</span>
00155         <span class="keywordtype">int</span> i;
00156         <a class="code" href="structSDVertex.html">SDVertex</a> *verts = <span class="keyword">new</span> <a class="code" href="structSDVertex.html">SDVertex</a>[nvertices];
00157         <span class="keywordflow">for</span> (i = 0; i &lt; nvertices; ++i) {
00158                 verts[i] = SDVertex(P[i]);
00159                 <a class="code" href="classLoopSubdiv.html#r1">vertices</a>.push_back(&amp;verts[i]);
00160         }
00161         <a class="code" href="structSDFace.html">SDFace</a> *fs = <span class="keyword">new</span> <a class="code" href="structSDFace.html">SDFace</a>[nfaces];
00162         <span class="keywordflow">for</span> (i = 0; i &lt; nfaces; ++i)
00163                 <a class="code" href="classLoopSubdiv.html#r2">faces</a>.push_back(&amp;fs[i]);
00164         <span class="comment">// Set face to vertex pointers</span>
00165         <span class="keyword">const</span> <span class="keywordtype">int</span> *vp = vertexIndices;
00166         <span class="keywordflow">for</span> (i = 0; i &lt; nfaces; ++i) {
00167                 SDFace *f = <a class="code" href="classLoopSubdiv.html#r2">faces</a>[i];
00168                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 3; ++j) {
00169                         SDVertex *v = <a class="code" href="classLoopSubdiv.html#r1">vertices</a>[vp[j]];
00170                         f-&gt;<a class="code" href="structSDFace.html#o0">v</a>[j] = v;
00171                         v-&gt;<a class="code" href="structSDVertex.html#o1">startFace</a> = f;
00172                 }
00173                 vp += 3;
00174         }
00175         <span class="comment">// Set neighbor pointers in _faces_</span>
00176         set&lt;SDEdge&gt; edges;
00177         <span class="keywordflow">for</span> (i = 0; i &lt; nfaces; ++i) {
00178                 SDFace *f = <a class="code" href="classLoopSubdiv.html#r2">faces</a>[i];
00179                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edgeNum = 0; edgeNum &lt; 3; ++edgeNum) {
00180                         <span class="comment">// Update neighbor pointer for _edgeNum_</span>
00181                         <span class="keywordtype">int</span> v0 = edgeNum, v1 = <a class="code" href="loopsubdiv_8cpp.html#a0">NEXT</a>(edgeNum);
00182                         <a class="code" href="structSDEdge.html">SDEdge</a> e(f-&gt;<a class="code" href="structSDFace.html#o0">v</a>[v0], f-&gt;<a class="code" href="structSDFace.html#o0">v</a>[v1]);
00183                         <span class="keywordflow">if</span> (edges.find(e) == edges.end()) {
00184                                 <span class="comment">// Handle new edge</span>
00185                                 e.<a class="code" href="structSDEdge.html#o1">f</a>[0] = f;
00186                                 e.<a class="code" href="structSDEdge.html#o2">f0edgeNum</a> = edgeNum;
00187                                 edges.insert(e);
00188                         }
00189                         <span class="keywordflow">else</span> {
00190                                 <span class="comment">// Handle previously-seen edge</span>
00191                                 e = *edges.find(e);
00192                                 e.<a class="code" href="structSDEdge.html#o1">f</a>[0]-&gt;<a class="code" href="structSDFace.html#o1">f</a>[e.<a class="code" href="structSDEdge.html#o2">f0edgeNum</a>] = f;
00193                                 f-&gt;<a class="code" href="structSDFace.html#o1">f</a>[edgeNum] = e.<a class="code" href="structSDEdge.html#o1">f</a>[0];
00194                                 edges.erase(e);
00195                         }
00196                 }
00197         }
00198         <span class="comment">// Finish vertex initialization</span>
00199         <span class="keywordflow">for</span> (i = 0; i &lt; nvertices; ++i) {
00200                 SDVertex *v = <a class="code" href="classLoopSubdiv.html#r1">vertices</a>[i];
00201                 SDFace *f = v-&gt;<a class="code" href="structSDVertex.html#o1">startFace</a>;
00202                 <span class="keywordflow">do</span> {
00203                         f = f-&gt;<a class="code" href="structSDFace.html#a2">nextFace</a>(v);
00204                 } <span class="keywordflow">while</span> (f &amp;&amp; f != v-&gt;<a class="code" href="structSDVertex.html#o1">startFace</a>);
00205                 v-&gt;<a class="code" href="structSDVertex.html#o4">boundary</a> = (f == NULL);
00206                 <span class="keywordflow">if</span> (!v-&gt;<a class="code" href="structSDVertex.html#o4">boundary</a> &amp;&amp; v-&gt;<a class="code" href="structSDVertex.html#a1">valence</a>() == 6)
00207                         v-&gt;<a class="code" href="structSDVertex.html#o3">regular</a> = <span class="keyword">true</span>;
00208                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (v-&gt;<a class="code" href="structSDVertex.html#o4">boundary</a> &amp;&amp; v-&gt;<a class="code" href="structSDVertex.html#a1">valence</a>() == 4)
00209                         v-&gt;<a class="code" href="structSDVertex.html#o3">regular</a> = <span class="keyword">true</span>;
00210                 <span class="keywordflow">else</span>
00211                         v-&gt;<a class="code" href="structSDVertex.html#o3">regular</a> = <span class="keyword">false</span>;
00212         }
00213 }
<a name="l00214"></a><a class="code" href="classLoopSubdiv.html#a1">00214</a> <a class="code" href="classLoopSubdiv.html#a1">LoopSubdiv::~LoopSubdiv</a>() {
00215         <span class="keyword">delete</span>[] <a class="code" href="classLoopSubdiv.html#r1">vertices</a>[0];
00216         <span class="keyword">delete</span>[] <a class="code" href="classLoopSubdiv.html#r2">faces</a>[0];
00217 }
<a name="l00218"></a><a class="code" href="classLoopSubdiv.html#a4">00218</a> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classLoopSubdiv.html#a4">LoopSubdiv::ObjectBound</a>()<span class="keyword"> const </span>{
00219         <a class="code" href="classBBox.html">BBox</a> b;
00220         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="classLoopSubdiv.html#r1">vertices</a>.size(); i++)
00221                 b = <a class="code" href="geometry_8cpp.html#a1">Union</a>(b, <a class="code" href="classLoopSubdiv.html#r1">vertices</a>[i]-&gt;P);
00222         <span class="keywordflow">return</span> b;
00223 }
<a name="l00224"></a><a class="code" href="classLoopSubdiv.html#a5">00224</a> <a class="code" href="classBBox.html">BBox</a> <a class="code" href="classLoopSubdiv.html#a5">LoopSubdiv::WorldBound</a>()<span class="keyword"> const </span>{
00225         <a class="code" href="classBBox.html">BBox</a> b;
00226         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; <a class="code" href="classLoopSubdiv.html#r1">vertices</a>.size(); i++)
00227                 b = <a class="code" href="geometry_8cpp.html#a1">Union</a>(b, ObjectToWorld(<a class="code" href="classLoopSubdiv.html#r1">vertices</a>[i]-&gt;P));
00228         <span class="keywordflow">return</span> b;
00229 }
<a name="l00230"></a><a class="code" href="classLoopSubdiv.html#a2">00230</a> <span class="keywordtype">bool</span> <a class="code" href="classLoopSubdiv.html#a2">LoopSubdiv::CanIntersect</a>()<span class="keyword"> const </span>{
00231         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00232 }
00233 <span class="keywordtype">void</span>
<a name="l00234"></a><a class="code" href="classLoopSubdiv.html#a3">00234</a> <a class="code" href="classLoopSubdiv.html#a3">LoopSubdiv::Refine</a>(vector&lt;<a class="code" href="classReference.html">Reference&lt;Shape&gt;</a> &gt; &amp;refined)<span class="keyword"></span>
00235 <span class="keyword">const </span>{
00236         vector&lt;SDFace *&gt; f = <a class="code" href="classLoopSubdiv.html#r2">faces</a>;
00237         vector&lt;SDVertex *&gt; v = <a class="code" href="classLoopSubdiv.html#r1">vertices</a>;
00238         <a class="code" href="classObjectArena.html">ObjectArena&lt;SDVertex&gt;</a> vertexArena;
00239         <a class="code" href="classObjectArena.html">ObjectArena&lt;SDFace&gt;</a> faceArena;
00240         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classLoopSubdiv.html#r0">nLevels</a>; ++i) {
00241                 <span class="comment">// Update _f_ and _v_ for next level of subdivision</span>
00242                 vector&lt;SDFace *&gt; newFaces;
00243                 vector&lt;SDVertex *&gt; newVertices;
00244                 <span class="comment">// Allocate next level of children in mesh tree</span>
00245                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> j = 0; j &lt; v.size(); ++j) {
00246                         v[j]-&gt;child = <span class="keyword">new</span> (vertexArena) <a class="code" href="structSDVertex.html">SDVertex</a>;
00247                         v[j]-&gt;child-&gt;regular = v[j]-&gt;regular;
00248                         v[j]-&gt;child-&gt;boundary = v[j]-&gt;boundary;
00249                         newVertices.push_back(v[j]-&gt;child);
00250                 }
00251                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> j = 0; j &lt; f.size(); ++j)
00252                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 4; ++k) {
00253                                 f[j]-&gt;children[k] = <span class="keyword">new</span> (faceArena) <a class="code" href="structSDFace.html">SDFace</a>;
00254                                 newFaces.push_back(f[j]-&gt;children[k]);
00255                         }
00256                 <span class="comment">// Update vertex positions and create new edge vertices</span>
00257                 <span class="comment">// Update vertex positions for even vertices</span>
00258                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> j = 0; j &lt; v.size(); ++j) {
00259                         <span class="keywordflow">if</span> (!v[j]-&gt;boundary) {
00260                                 <span class="comment">// Apply one-ring rule for even vertex</span>
00261                                 <span class="keywordflow">if</span> (v[j]-&gt;regular)
00262                                         v[j]-&gt;child-&gt;P = <a class="code" href="classLoopSubdiv.html#h1">weightOneRing</a>(v[j], 1.f/16.f);
00263                                 <span class="keywordflow">else</span>
00264                                         v[j]-&gt;child-&gt;P =
00265                                             <a class="code" href="classLoopSubdiv.html#h1">weightOneRing</a>(v[j], <a class="code" href="classLoopSubdiv.html#h0">beta</a>(v[j]-&gt;valence()));
00266                         }
00267                         <span class="keywordflow">else</span> {
00268                                 <span class="comment">// Apply boundary rule for even vertex</span>
00269                                 v[j]-&gt;child-&gt;P = <a class="code" href="classLoopSubdiv.html#h2">weightBoundary</a>(v[j], 1.f/8.f);
00270                         }
00271                 }
00272                 <span class="comment">// Compute new odd edge vertices</span>
00273                 map&lt;SDEdge, SDVertex *&gt; edgeVerts;
00274                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> j = 0; j &lt; f.size(); ++j) {
00275                         <a class="code" href="structSDFace.html">SDFace</a> *face = f[j];
00276                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 3; ++k) {
00277                                 <span class="comment">// Compute odd vertex on _k_th edge</span>
00278                                 <a class="code" href="structSDEdge.html">SDEdge</a> edge(face-&gt;<a class="code" href="structSDFace.html#o0">v</a>[k], face-&gt;<a class="code" href="structSDFace.html#o0">v</a>[<a class="code" href="loopsubdiv_8cpp.html#a0">NEXT</a>(k)]);
00279                                 <a class="code" href="structSDVertex.html">SDVertex</a> *vert = edgeVerts[edge];
00280                                 <span class="keywordflow">if</span> (!vert) {
00281                                         <span class="comment">// Create and initialize new odd vertex</span>
00282                                         vert = <span class="keyword">new</span> (vertexArena) <a class="code" href="structSDVertex.html">SDVertex</a>;
00283                                         newVertices.push_back(vert);
00284                                         vert-&gt;<a class="code" href="structSDVertex.html#o3">regular</a> = <span class="keyword">true</span>;
00285                                         vert-&gt;<a class="code" href="structSDVertex.html#o4">boundary</a> = (face-&gt;<a class="code" href="structSDFace.html#o1">f</a>[k] == NULL);
00286                                         vert-&gt;<a class="code" href="structSDVertex.html#o1">startFace</a> = face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[3];
00287                                         <span class="comment">// Apply edge rules to compute new vertex position</span>
00288                                         <span class="keywordflow">if</span> (vert-&gt;<a class="code" href="structSDVertex.html#o4">boundary</a>) {
00289                                                 vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a> =  0.5f * edge.<a class="code" href="structSDEdge.html#o0">v</a>[0]-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00290                                                 vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a> += 0.5f * edge.<a class="code" href="structSDEdge.html#o0">v</a>[1]-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00291                                         }
00292                                         <span class="keywordflow">else</span> {
00293                                                 vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a> =  3.f/8.f * edge.<a class="code" href="structSDEdge.html#o0">v</a>[0]-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00294                                                 vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a> += 3.f/8.f * edge.<a class="code" href="structSDEdge.html#o0">v</a>[1]-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00295                                                 vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a> += 1.f/8.f *
00296                                                         face-&gt;<a class="code" href="structSDFace.html#a6">otherVert</a>(edge.<a class="code" href="structSDEdge.html#o0">v</a>[0], edge.<a class="code" href="structSDEdge.html#o0">v</a>[1])-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00297                                                 vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a> += 1.f/8.f *
00298                                                         face-&gt;<a class="code" href="structSDFace.html#o1">f</a>[k]-&gt;<a class="code" href="structSDFace.html#a6">otherVert</a>(edge.<a class="code" href="structSDEdge.html#o0">v</a>[0], edge.<a class="code" href="structSDEdge.html#o0">v</a>[1])-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00299                                         }
00300                                         edgeVerts[edge] = vert;
00301                                 }
00302                         }
00303                 }
00304                 <span class="comment">// Update new mesh topology</span>
00305                 <span class="comment">// Update even vertex face pointers</span>
00306                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> j = 0; j &lt; v.size(); ++j) {
00307                         <a class="code" href="structSDVertex.html">SDVertex</a> *vert = v[j];
00308                         <span class="keywordtype">int</span> vertNum = vert-&gt;<a class="code" href="structSDVertex.html#o1">startFace</a>-&gt;<a class="code" href="structSDFace.html#a1">vnum</a>(vert);
00309                         vert-&gt;<a class="code" href="structSDVertex.html#o2">child</a>-&gt;<a class="code" href="structSDVertex.html#o1">startFace</a> =
00310                             vert-&gt;<a class="code" href="structSDVertex.html#o1">startFace</a>-&gt;<a class="code" href="structSDFace.html#o2">children</a>[vertNum];
00311                 }
00312                 <span class="comment">// Update face neighbor pointers</span>
00313                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> j = 0; j &lt; f.size(); ++j) {
00314                         <a class="code" href="structSDFace.html">SDFace</a> *face = f[j];
00315                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 3; ++k) {
00316                                 <span class="comment">// Update children _f_ pointers for siblings</span>
00317                                 face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[3]-&gt;<a class="code" href="structSDFace.html#o1">f</a>[k] = face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[<a class="code" href="loopsubdiv_8cpp.html#a0">NEXT</a>(k)];
00318                                 face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[k]-&gt;<a class="code" href="structSDFace.html#o1">f</a>[<a class="code" href="loopsubdiv_8cpp.html#a0">NEXT</a>(k)] = face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[3];
00319                                 <span class="comment">// Update children _f_ pointers for neighbor children</span>
00320                                 <a class="code" href="structSDFace.html">SDFace</a> *f2 = face-&gt;<a class="code" href="structSDFace.html#o1">f</a>[k];
00321                                 face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[k]-&gt;<a class="code" href="structSDFace.html#o1">f</a>[k] =
00322                                         f2 ? f2-&gt;<a class="code" href="structSDFace.html#o2">children</a>[f2-&gt;<a class="code" href="structSDFace.html#a1">vnum</a>(face-&gt;<a class="code" href="structSDFace.html#o0">v</a>[k])] : NULL;
00323                                 f2 = face-&gt;<a class="code" href="structSDFace.html#o1">f</a>[<a class="code" href="loopsubdiv_8cpp.html#a1">PREV</a>(k)];
00324                                 face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[k]-&gt;<a class="code" href="structSDFace.html#o1">f</a>[<a class="code" href="loopsubdiv_8cpp.html#a1">PREV</a>(k)] =
00325                                         f2 ? f2-&gt;<a class="code" href="structSDFace.html#o2">children</a>[f2-&gt;<a class="code" href="structSDFace.html#a1">vnum</a>(face-&gt;<a class="code" href="structSDFace.html#o0">v</a>[k])] : NULL;
00326                         }
00327                 }
00328                 <span class="comment">// Update face vertex pointers</span>
00329                 <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> j = 0; j &lt; f.size(); ++j) {
00330                         <a class="code" href="structSDFace.html">SDFace</a> *face = f[j];
00331                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 3; ++k) {
00332                                 <span class="comment">// Update child vertex pointer to new even vertex</span>
00333                                 face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[k]-&gt;<a class="code" href="structSDFace.html#o0">v</a>[k] = face-&gt;<a class="code" href="structSDFace.html#o0">v</a>[k]-&gt;<a class="code" href="structSDVertex.html#o2">child</a>;
00334                                 <span class="comment">// Update child vertex pointer to new odd vertex</span>
00335                                 <a class="code" href="structSDVertex.html">SDVertex</a> *vert =
00336                                         edgeVerts[<a class="code" href="structSDEdge.html">SDEdge</a>(face-&gt;<a class="code" href="structSDFace.html#o0">v</a>[k], face-&gt;<a class="code" href="structSDFace.html#o0">v</a>[<a class="code" href="loopsubdiv_8cpp.html#a0">NEXT</a>(k)])];
00337                                 face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[k]-&gt;<a class="code" href="structSDFace.html#o0">v</a>[<a class="code" href="loopsubdiv_8cpp.html#a0">NEXT</a>(k)] = vert;
00338                                 face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[<a class="code" href="loopsubdiv_8cpp.html#a0">NEXT</a>(k)]-&gt;<a class="code" href="structSDFace.html#o0">v</a>[k] = vert;
00339                                 face-&gt;<a class="code" href="structSDFace.html#o2">children</a>[3]-&gt;<a class="code" href="structSDFace.html#o0">v</a>[k] = vert;
00340                         }
00341                 }
00342                 <span class="comment">// Prepare for next level of subdivision</span>
00343                 f = newFaces;
00344                 v = newVertices;
00345         }
00346         <span class="comment">// Push vertices to limit surface</span>
00347         <a class="code" href="classPoint.html">Point</a> *Plimit = <span class="keyword">new</span> <a class="code" href="classPoint.html">Point</a>[v.size()];
00348         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; v.size(); ++i) {
00349                 <span class="keywordflow">if</span> (v[i]-&gt;boundary)
00350                         Plimit[i] =
00351                             <a class="code" href="classLoopSubdiv.html#h2">weightBoundary</a>(v[i], 1.f/5.f);
00352                 <span class="keywordflow">else</span>
00353                         Plimit[i] =
00354                             <a class="code" href="classLoopSubdiv.html#h1">weightOneRing</a>(v[i], <a class="code" href="classLoopSubdiv.html#h3">gamma</a>(v[i]-&gt;valence()));
00355         }
00356         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; v.size(); ++i)
00357                 v[i]-&gt;P = Plimit[i];
00358         <span class="comment">// Compute vertex tangents on limit surface</span>
00359         vector&lt;Normal&gt; Ns;
00360         Ns.reserve(v.size());
00361         <span class="keywordtype">int</span> ringSize = 16;
00362         Point *Pring = <span class="keyword">new</span> Point[ringSize];
00363         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; v.size(); ++i) {
00364                 <a class="code" href="structSDVertex.html">SDVertex</a> *vert = v[i];
00365                 <a class="code" href="classVector.html">Vector</a> S(0,0,0), T(0,0,0);
00366                 <span class="keywordtype">int</span> valence = vert-&gt;<a class="code" href="structSDVertex.html#a1">valence</a>();
00367                 <span class="keywordflow">if</span> (valence &gt; ringSize) {
00368                         ringSize = valence;
00369                         <span class="keyword">delete</span>[] Pring;
00370                         Pring = <span class="keyword">new</span> Point[ringSize];
00371                 }
00372                 vert-&gt;<a class="code" href="structSDVertex.html#a2">oneRing</a>(Pring);
00373         
00374                 <span class="keywordflow">if</span> (!vert-&gt;<a class="code" href="structSDVertex.html#o4">boundary</a>) {
00375                         <span class="comment">// Compute tangents of interior face</span>
00376                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; valence; ++k) {
00377                                 S += cosf(2.f*<a class="code" href="pbrt_8h.html#a6">M_PI</a>*k/valence) * <a class="code" href="classVector.html">Vector</a>(Pring[k]);
00378                                 T += sinf(2.f*<a class="code" href="pbrt_8h.html#a6">M_PI</a>*k/valence) * Vector(Pring[k]);
00379                         }
00380                 }
00381                 <span class="keywordflow">else</span> {
00382                         <span class="comment">// Compute tangents of boundary face</span>
00383                         S = Pring[valence-1] - Pring[0];
00384                         <span class="keywordflow">if</span> (valence == 2)
00385                                 T = <a class="code" href="classVector.html">Vector</a>(Pring[0] + Pring[1] - 2 * vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a>);
00386                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (valence == 3)
00387                                 T = Pring[1] - vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00388                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (valence == 4) <span class="comment">// regular</span>
00389                                 T = Vector(-1*Pring[0] + 2*Pring[1] + 2*Pring[2] +
00390                                         -1*Pring[3] + -2*vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a>);
00391                         <span class="keywordflow">else</span> {
00392                                 <span class="keywordtype">float</span> theta = <a class="code" href="pbrt_8h.html#a6">M_PI</a> / float(valence-1);
00393                                 T = Vector(sinf(theta) * (Pring[0] + Pring[valence-1]));
00394                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; k &lt; valence-1; ++k) {
00395                                         <span class="keywordtype">float</span> wt = (2*cosf(theta) - 2) * sinf((k) * theta);
00396                                         T += Vector(wt * Pring[k]);
00397                                 }
00398                                 T = -T;
00399                         }
00400                 }
00401                 Ns.push_back(<a class="code" href="classNormal.html">Normal</a>(<a class="code" href="geometry_8h.html#a6">Cross</a>(S, T)));
00402         }
00403         <span class="comment">// Create _TriangleMesh_ from subdivision mesh</span>
00404         <a class="code" href="pbrt_8h.html#a51">u_int</a> ntris = <a class="code" href="pbrt_8h.html#a51">u_int</a>(f.size());
00405         <span class="keywordtype">int</span> *verts = <span class="keyword">new</span> <span class="keywordtype">int</span>[3*ntris];
00406         <span class="keywordtype">int</span> *vp = verts;
00407         <a class="code" href="pbrt_8h.html#a51">u_int</a> totVerts = <a class="code" href="pbrt_8h.html#a51">u_int</a>(v.size());
00408         map&lt;SDVertex *, int&gt; usedVerts;
00409         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; totVerts; ++i)
00410                 usedVerts[v[i]] = i;
00411         <span class="keywordflow">for</span> (<a class="code" href="pbrt_8h.html#a51">u_int</a> i = 0; i &lt; ntris; ++i) {
00412                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 3; ++j) {
00413                         *vp = usedVerts[f[i]-&gt;v[j]];
00414                         ++vp;
00415                 }
00416         }
00417         <a class="code" href="classParamSet.html">ParamSet</a> paramSet;
00418         paramSet.<a class="code" href="classParamSet.html#a4">AddInt</a>(<span class="stringliteral">"indices"</span>, verts, 3*ntris);
00419         paramSet.<a class="code" href="classParamSet.html#a6">AddPoint</a>(<span class="stringliteral">"P"</span>, Plimit, totVerts);
00420         paramSet.<a class="code" href="classParamSet.html#a8">AddNormal</a>(<span class="stringliteral">"N"</span>, &amp;Ns[0], <span class="keywordtype">int</span>(Ns.size()));
00421         refined.push_back(<a class="code" href="dynload_8h.html#a1">MakeShape</a>(<span class="stringliteral">"trianglemesh"</span>, ObjectToWorld,
00422                         reverseOrientation, paramSet));
00423         <span class="keyword">delete</span>[] verts;
00424         <span class="keyword">delete</span>[] Plimit;
00425 }
<a name="l00426"></a><a class="code" href="classLoopSubdiv.html#h1">00426</a> <a class="code" href="classPoint.html">Point</a> <a class="code" href="classLoopSubdiv.html#h1">LoopSubdiv::weightOneRing</a>(<a class="code" href="structSDVertex.html">SDVertex</a> *vert, <span class="keywordtype">float</span> beta) {
00427         <span class="comment">// Put _vert_ one-ring in _Pring_</span>
00428         <span class="keywordtype">int</span> valence = vert-&gt;<a class="code" href="structSDVertex.html#a1">valence</a>();
00429         <a class="code" href="classPoint.html">Point</a> *Pring = (<a class="code" href="classPoint.html">Point</a> *)alloca(valence * <span class="keyword">sizeof</span>(<a class="code" href="classPoint.html">Point</a>));
00430         vert-&gt;<a class="code" href="structSDVertex.html#a2">oneRing</a>(Pring);
00431         Point P = (1 - valence * beta) * vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00432         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; valence; ++i)
00433                 P += beta * Pring[i];
00434         <span class="keywordflow">return</span> P;
00435 }
<a name="l00436"></a><a class="code" href="structSDVertex.html#a2">00436</a> <span class="keywordtype">void</span> <a class="code" href="structSDVertex.html#a2">SDVertex::oneRing</a>(<a class="code" href="classPoint.html">Point</a> *P) {
00437         <span class="keywordflow">if</span> (!<a class="code" href="structSDVertex.html#o4">boundary</a>) {
00438                 <span class="comment">// Get one ring vertices for interior vertex</span>
00439                 <a class="code" href="structSDFace.html">SDFace</a> *face = <a class="code" href="structSDVertex.html#o1">startFace</a>;
00440                 <span class="keywordflow">do</span> {
00441                         *P++ = face-&gt;<a class="code" href="structSDFace.html#a4">nextVert</a>(<span class="keyword">this</span>)-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00442                         face = face-&gt;<a class="code" href="structSDFace.html#a2">nextFace</a>(<span class="keyword">this</span>);
00443                 } <span class="keywordflow">while</span> (face != startFace);
00444         }
00445         <span class="keywordflow">else</span> {
00446                 <span class="comment">// Get one ring vertices for boundary vertex</span>
00447                 <a class="code" href="structSDFace.html">SDFace</a> *face = <a class="code" href="structSDVertex.html#o1">startFace</a>, *f2;
00448                 <span class="keywordflow">while</span> ((f2 = face-&gt;<a class="code" href="structSDFace.html#a2">nextFace</a>(<span class="keyword">this</span>)) != NULL)
00449                         face = f2;
00450                 *P++ = face-&gt;<a class="code" href="structSDFace.html#a4">nextVert</a>(<span class="keyword">this</span>)-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00451                 <span class="keywordflow">do</span> {
00452                         *P++ = face-&gt;<a class="code" href="structSDFace.html#a5">prevVert</a>(<span class="keyword">this</span>)-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00453                         face = face-&gt;<a class="code" href="structSDFace.html#a3">prevFace</a>(<span class="keyword">this</span>);
00454                 } <span class="keywordflow">while</span> (face != NULL);
00455         }
00456 }
<a name="l00457"></a><a class="code" href="classLoopSubdiv.html#h2">00457</a> <a class="code" href="classPoint.html">Point</a> <a class="code" href="classLoopSubdiv.html#h2">LoopSubdiv::weightBoundary</a>(<a class="code" href="structSDVertex.html">SDVertex</a> *vert,
00458                                  <span class="keywordtype">float</span> beta) {
00459         <span class="comment">// Put _vert_ one-ring in _Pring_</span>
00460         <span class="keywordtype">int</span> valence = vert-&gt;<a class="code" href="structSDVertex.html#a1">valence</a>();
00461         <a class="code" href="classPoint.html">Point</a> *Pring = (<a class="code" href="classPoint.html">Point</a> *)alloca(valence * <span class="keyword">sizeof</span>(<a class="code" href="classPoint.html">Point</a>));
00462         vert-&gt;<a class="code" href="structSDVertex.html#a2">oneRing</a>(Pring);
00463         Point P = (1-2*beta) * vert-&gt;<a class="code" href="structSDVertex.html#o0">P</a>;
00464         P += beta * Pring[0];
00465         P += beta * Pring[valence-1];
00466         <span class="keywordflow">return</span> P;
00467 }
<a name="l00468"></a><a class="code" href="loopsubdiv_8cpp.html#a2">00468</a> <span class="keyword">extern</span> <span class="stringliteral">"C"</span> <a class="code" href="pbrt_8h.html#a2">DLLEXPORT</a> <a class="code" href="classShape.html">Shape</a> *<a class="code" href="trianglemesh_8cpp.html#a0">CreateShape</a>(<span class="keyword">const</span> <a class="code" href="classTransform.html">Transform</a> &amp;o2w,
00469                 <span class="keywordtype">bool</span> reverseOrientation, <span class="keyword">const</span> <a class="code" href="classParamSet.html">ParamSet</a> &amp;params) {
00470         <span class="keywordtype">int</span> nlevels = params.<a class="code" href="classParamSet.html#a22">FindOneInt</a>(<span class="stringliteral">"nlevels"</span>, 3);
00471         <span class="keywordtype">int</span> nps, nIndices;
00472         <span class="keyword">const</span> <span class="keywordtype">int</span> *vi = params.<a class="code" href="classParamSet.html#a31">FindInt</a>(<span class="stringliteral">"indices"</span>, &amp;nIndices);
00473         <span class="keyword">const</span> <a class="code" href="classPoint.html">Point</a> *P = params.<a class="code" href="classParamSet.html#a33">FindPoint</a>(<span class="stringliteral">"P"</span>, &amp;nps);
00474         <span class="keywordflow">if</span> (!vi || !P) <span class="keywordflow">return</span> NULL;
00475 
00476         <span class="comment">// don't actually use this for now...</span>
00477         string scheme = params.<a class="code" href="classParamSet.html#a28">FindOneString</a>(<span class="stringliteral">"scheme"</span>, <span class="stringliteral">"loop"</span>);
00478 
00479         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classLoopSubdiv.html">LoopSubdiv</a>(o2w, reverseOrientation, nIndices/3, nps,
00480                 vi, P, nlevels);
00481 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Mon Apr 25 19:00:22 2005 for pbrt by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
